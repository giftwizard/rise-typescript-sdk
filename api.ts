/* tslint:disable */
/* eslint-disable */
/**
 * Rise.ai API Documentation
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 2.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError, operationServerMap } from './base';

/**
 * Once a user has completed the installation process and given your app permission to access their data, use the authorization code we sent you, together with your secret key, to request an access token and a refresh token. (The access token is only valid for 5 minutes.).
 */
export interface AccessTokenRequest {
    /**
     * Value must be set to \"authorization_code\"
     */
    'grant_type'?: string;
    /**
     * The App ID as defined
     */
    'client_id'?: string;
    /**
     * The Secret Key for your app
     */
    'client_secret'?: string;
    /**
     * The authorization code received from us.
     */
    'code'?: string;
}
export interface Action {
    /**
     * 
     */
    'service'?: object;
    /**
     * 
     */
    'systemHelper'?: object;
    /**
     * 
     */
    'spiAction'?: object;
}
/**
 * 
 */
export interface ActionAttributes {
    /**
     * Indicates if this action run is part of a retry attempt If it\'s not null, it\'s a retry action run
     */
    'retry'?: object;
}
/**
 * 
 */
export interface ActionCompletedRequest {
    /**
     * The execution identifier that was given to the spi provider when we invoked the action
     */
    'executionIdentifier'?: string;
    /**
     * The result of invoking the action. Must conform to the output schema configured by the action provider.
     */
    'result'?: object;
}
/**
 * 
 */
export interface ActionData {
    /**
     * Action\'s id.
     */
    'id'?: string;
    /**
     * Action\'s data.
     */
    'action'?: object;
}
/**
 * 
 */
export interface ActionEvent {
    /**
     * 
     */
    'bodyAsJson'?: string;
}
/**
 * 
 */
export interface ActionInitiator {
    /**
     * The type of the initiator (e.g., app, user)
     */
    'type'?: string;
    /**
     * ID of the initiator
     */
    'id'?: string;
}
/**
 * Details of the API client creating this Transaction.
 */
export interface ActionInitiator1 {
    /**
     * The type of the initiator (e.g., app, user)
     */
    'type'?: ActionInitiator1TypeEnum;
    /**
     * ID of the initiator
     */
    'id'?: string;
}

export const ActionInitiator1TypeEnum = {
    App: 'APP',
    User: 'USER'
} as const;

export type ActionInitiator1TypeEnum = typeof ActionInitiator1TypeEnum[keyof typeof ActionInitiator1TypeEnum];

/**
 * Information about the initiator of the WalletAction, such as the app or user that initiated the action. Set when the WalletAction is created.
 */
export interface ActionInitiator2 {
    /**
     * The type of the initiator (e.g., app, user)
     */
    'type'?: ActionInitiator2TypeEnum;
    /**
     * ID of the initiator
     */
    'id'?: string;
}

export const ActionInitiator2TypeEnum = {
    App: 'APP',
    User: 'USER'
} as const;

export type ActionInitiator2TypeEnum = typeof ActionInitiator2TypeEnum[keyof typeof ActionInitiator2TypeEnum];

/**
 * Details of the API client creating this Gift Card.
 */
export interface ActionInitiator3 {
    /**
     * The type of the initiator (e.g., app, user)
     */
    'type'?: ActionInitiator3TypeEnum;
    /**
     * ID of the initiator
     */
    'id'?: string;
}

export const ActionInitiator3TypeEnum = {
    App: 'APP',
    User: 'USER'
} as const;

export type ActionInitiator3TypeEnum = typeof ActionInitiator3TypeEnum[keyof typeof ActionInitiator3TypeEnum];

/**
 * 
 */
export interface ActionRetryRequest {
    /**
     * The activation context
     */
    'activationContext'?: object;
    /**
     * The action to retry
     */
    'actionToRetryData'?: object;
}
/**
 * 
 */
export interface ActionSettings {
    /**
     * List of actions that cannot be deleted. Default: Empty. All actions are deletable by default.
     */
    'permanentActionIds'?: Array<string>;
    /**
     * List of actions that cannot be edited. Default: Empty. All actions are editable by default.
     */
    'readonlyActionIds'?: Array<string>;
    /**
     * Whether the option to add a delay is disabled for the automation.
     */
    'disableDelayAddition'?: boolean;
    /**
     * Whether the option to add a condition is disabled for the automation.
     */
    'disableConditionAddition'?: boolean;
}
/**
 * Map of all actions that the automation may execute. The key is the action ID, and the value is the action configuration.
 */
export interface Actions {
    'key'?: string;
    'value'?: object;
}
/**
 * Map of action id to action data.
 */
export interface Actions1 {
    'key'?: string;
    'value'?: object;
}
/**
 * 
 */
export interface ActionsData {
    /**
     * Ids of the first level actions.
     */
    'rootActionIds'?: Array<string>;
    'actions'?: Actions1;
}
/**
 * 
 */
export interface Activation {
    /**
     * Activation ID
     */
    'id'?: string;
    /**
     * Activation automation
     */
    'automation'?: object;
}
/**
 * 
 */
export interface ActivationContext {
    /**
     * Activation ID
     */
    'activationId'?: string;
    /**
     * Action ID
     */
    'actionId'?: string;
    /**
     * Configuration ID
     */
    'configurationId'?: string;
    /**
     * Configuration Correlation ID
     */
    'configurationCorrelationId'?: string;
    /**
     * name of the event. intended to keep backwards compatibility, probably not in use.
     */
    'eventName'?: string;
    /**
     * Event slug, also probably not in use
     */
    'eventSlug'?: string;
    /**
     * Enriched event payload
     */
    'enrichedEventPayload'?: string;
    /**
     * Raw event payload
     */
    'rawEventPayload'?: string;
    /**
     * Actions
     */
    'actions'?: Array<object>;
    /**
     * Activation status
     */
    'activationStatus'?: string;
    /**
     * External ID
     */
    'externalId'?: string;
    /**
     * Automation
     */
    'automationV2'?: object;
    /**
     * Output
     */
    'output'?: string;
}
/**
 * 
 */
export interface ActivationRequest {
    /**
     * Activation\'s ID.
     */
    'activationId'?: string;
    /**
     * Configuration\'s ID.
     */
    'configurationId'?: string;
    /**
     * 
     */
    'configurationCorrelationId'?: string;
    /**
     * Received event name.
     */
    'eventName'?: string;
    /**
     * Received event slug.
     */
    'eventSlug'?: string;
    /**
     * Received event payload.
     */
    'eventPayload'?: string;
    /**
     * List of action data.
     */
    'actions'?: Array<object>;
    /**
     * External ID.
     */
    'externalId'?: string;
    /**
     * The source of this activation
     */
    'source'?: object;
    /**
     * Actions tree
     */
    'actionsMap'?: object;
    /**
     * Automation V2. Used for reporting domain event until activation request will be deprecated.
     */
    'automation'?: object;
    /**
     * Trigger entity for the activation, available for v2 and v3 automations only
     */
    'triggerSchema'?: object;
}
/**
 * 
 */
export interface ActivationResumeAfterDelay {
    /**
     * Activation identifier
     */
    'id'?: string;
    /**
     * Activation schedule identifier
     */
    'scheduleId'?: string;
    /**
     * Activation schedule due date
     */
    'scheduleDate'?: string;
    /**
     * Activation payload
     */
    'payload'?: object;
    /**
     * Activation Automation
     */
    'automation'?: object;
    /**
     * Scheduled action identifier - with the intent to execute that action\'s post actions
     */
    'scheduledActionId'?: string;
    /**
     * Optional - external entity id that this activation is related to
     */
    'externalEntityId'?: string;
}
/**
 * 
 */
export interface ActivationScheduleCompleted {
    /**
     * Activation identifier
     */
    'id'?: string;
    /**
     * Activation schedule identifier
     */
    'scheduleId'?: string;
    /**
     * Activation schedule due date
     */
    'scheduleDate'?: string;
    /**
     * Activation payload
     */
    'payload'?: object;
    /**
     * Activation Automation
     */
    'automation'?: object;
    /**
     * Optional - external entity id that this activation is related to
     */
    'externalEntityId'?: string;
}
/**
 * 
 */
export interface ActivationScheduleRequested {
    /**
     * Activation identifier
     */
    'id'?: string;
    /**
     * Activation schedule request date
     */
    'requestedDate'?: string;
    /**
     * Activation schedule due date
     */
    'scheduleDate'?: string;
    /**
     * Activation payload
     */
    'payload'?: object;
    /**
     * Activation Automation
     */
    'automation'?: object;
    /**
     * Optional - external entity id that this activation is related to
     */
    'externalEntityId'?: string;
}
/**
 * 
 */
export interface AddCustomerReferenceRequest {
    /**
     * Customer reference
     */
    'customerReference'?: object;
    /**
     * Wallet ID
     */
    'walletId'?: string;
}
/**
 * 
 */
export interface AggregationData {
    /**
     * List of the aggregated data results.
     */
    'results'?: Array<object>;
}
/**
 * Aggregation data.
 */
export interface AggregationData1 {
    /**
     * List of the aggregated data results.
     */
    'results'?: Array<AggregationResults1>;
}
/**
 * @type AggregationResults1
 * 
 */
export type AggregationResults1 = DateHistogramResults | GroupByValueResults | NestedResults | RangeResults | ScalarResult | ValueResults;

/**
 * 
 */

export const AggregationType = {
    Value: 'VALUE',
    Range: 'RANGE',
    Scalar: 'SCALAR',
    DateHistogram: 'DATE_HISTOGRAM',
    Nested: 'NESTED'
} as const;

export type AggregationType = typeof AggregationType[keyof typeof AggregationType];


/**
 * 
 */
export interface AppDefinedAction {
    /**
     * ID of the app that defines the action.
     */
    'appId'?: string;
    /**
     * Action key.
     */
    'actionKey'?: string;
    /**
     * Action input mapping.
     */
    'inputMapping'?: object;
    /**
     * Array of conditions determining whether to skip the action in the automation flow. The action will be skipped if any of the expression groups evaluate to `true`. Actions following a skipped action will still run.
     */
    'skipConditionOrExpressionGroups'?: Array<object>;
    /**
     * List of IDs of actions to run in parallel once the action completes.
     */
    'postActionIds'?: Array<string>;
    /**
     * Optional output schema of the action. It will be used instead the action schema in case it\'s provided.
     */
    'overrideOutputSchema'?: object;
}
/**
 * 
 */
export interface AppDefinedActionInfo {
    /**
     * Action app ID
     */
    'appId'?: string;
    /**
     * Action key
     */
    'actionKey'?: string;
}
/**
 * 
 */
export interface ApplicationError {
    /**
     * Error code.
     */
    'code'?: string;
    /**
     * Description of the error.
     */
    'description'?: string;
    /**
     * Data related to the error.
     */
    'data'?: object;
}
/**
 * 
 */
export interface ApplicationOrigin {
    /**
     * Application ID.
     */
    'appId'?: string;
    /**
     * External ID to correlate multiple sites to an automation
     */
    'appDefinedExternalId'?: string;
}
/**
 * Automation runtime configuration
 */
export interface AutomationConfiguration {
    /**
     * Status of the automation on the site.
     */
    'status'?: string;
    /**
     * Automation trigger configuration.
     */
    'trigger'?: object;
    /**
     * List of IDs of root actions. Root actions are the first actions to run after the trigger. The actions in the list run in parallel.
     */
    'rootActionIds'?: Array<string>;
    'actions'?: Actions;
}
/**
 * 
 */
export interface AutomationSettings {
    /**
     * Whether the automation is hidden from users. Default: `false`
     */
    'hidden'?: boolean;
    /**
     * Whether the automation is read-only. Default: `false`
     */
    'readonly'?: boolean;
    /**
     * Whether the option to delete the automation from the site is disabled. Default: `false`
     */
    'disableDelete'?: boolean;
    /**
     * Whether the option to change the automation status (from active to inactive and vice versa) is disabled. Default: `false`
     */
    'disableStatusChange'?: boolean;
    /**
     * Automation action settings.
     */
    'actionSettings'?: object;
}
/**
 * 
 */
export interface BatchActivationRequest {
    /**
     * List of Activation-Request.
     */
    'activationRequests'?: Array<object>;
}
/**
 * Information about the billing address of the buyer.
 */
export interface BillingInfo {
    /**
     * The street address of the billing address.
     */
    'address1'?: string;
    /**
     * An optional additional field for the street address of the billing address.address
     */
    'address2'?: string;
    /**
     * The city of the billing address.
     */
    'city'?: string;
    /**
     * The company of the person associated with the billing address.
     */
    'company'?: string;
    /**
     * The name of the country of the billing address.
     */
    'country'?: string;
    /**
     * The name of the region of the billing address.
     */
    'state'?: string;
    /**
     * The postal code of the billing address.
     */
    'zip'?: string;
    /**
     * province code of the billing address.
     */
    'stateCode'?: string;
    /**
     * country code of the billing address.
     */
    'countryCode'?: string;
    /**
     * The latitude of the billing address.
     */
    'latitude'?: string;
    /**
     * The longitude of the billing address.
     */
    'longitude'?: string;
}
/**
 * Billing information of the buyer.
 */
export interface BillingInfo1 {
    /**
     * The street address of the billing address.
     */
    'address1'?: string;
    /**
     * An optional additional field for the street address of the billing address.address
     */
    'address2'?: string;
    /**
     * The city of the billing address.
     */
    'city'?: string;
    /**
     * The company of the person associated with the billing address.
     */
    'company'?: string;
    /**
     * The name of the country of the billing address.
     */
    'country'?: string;
    /**
     * The name of the region of the billing address.
     */
    'state'?: string;
    /**
     * The postal code of the billing address.
     */
    'zip'?: string;
    /**
     * province code of the billing address.
     */
    'stateCode'?: string;
    /**
     * country code of the billing address.
     */
    'countryCode'?: string;
    /**
     * The latitude of the billing address.
     */
    'latitude'?: string;
    /**
     * The longitude of the billing address.
     */
    'longitude'?: string;
}
/**
 * 
 */

export const BlockType = {
    Unknown: 'UNKNOWN',
    Or: 'OR',
    And: 'AND'
} as const;

export type BlockType = typeof BlockType[keyof typeof BlockType];


export interface Body {
    /**
     * 
     */
    'createdEvent'?: object;
    /**
     * 
     */
    'updatedEvent'?: object;
    /**
     * 
     */
    'deletedEvent'?: object;
    /**
     * 
     */
    'actionEvent'?: object;
}
/**
 * 
 */
export interface BoolValue {
    /**
     * 
     */
    'boolValue'?: boolean;
}
/**
 * 
 */
export interface BulkActionMetadata {
    /**
     * Number of items that were successfully processed.
     */
    'totalSuccesses'?: number;
    /**
     * Number of items that couldn\'t be processed.
     */
    'totalFailures'?: number;
    /**
     * Number of failures without details because detailed failure threshold was exceeded.
     */
    'undetailedFailures'?: number;
}
/**
 * 
 */
export interface BulkCancelEventRequest {
    /**
     * gger key whose events you want to cancel. For example, `form_submitted` or `invoice_due`.
     */
    'triggerKey'?: string;
    /**
     * Repeated list of external_entity_id, representing the related resources\' IDs.
     */
    'externalEntityIds'?: Array<string>;
}
/**
 * 
 */
export interface BulkCancelEventResponse {
    /**
     * Trigger key related to the canceled event.
     */
    'triggerKey'?: string;
    /**
     * List of results for each item in the bulk cancel event request.
     */
    'results'?: Array<object>;
    /**
     * Metadata for the overall bulk action, including success and failure counts.
     */
    'bulkActionMetadata'?: object;
}
/**
 * 
 */
export interface BulkCancelEventResult {
    /**
     * Metadata of the item, including its ID and success or failure status.
     */
    'itemMetadata'?: object;
    /**
     * ID of the related resource in GUID format.
     */
    'externalEntityId'?: string;
}
/**
 * 
 */
export interface BulkDeleteGiftCardsByFilterRequest {
    /**
     * WQL expression
     */
    'query'?: object;
    /**
     * MSID from which to delete the gift cards
     */
    'metaSiteId'?: string;
    /**
     * Expected gift card amount to delete
     */
    'expectedAmount'?: number;
}
/**
 * 
 */
export interface BulkDeleteGiftCardsByFilterResponse {
    /**
     * 
     */
    'jobId'?: string;
}
export interface BulkOptions {
    /**
     * @deprecated
     */
    'bulkOptions'?: BulkOptionsBulkOptions;
}
/**
 * Bulk Options. (**Deprecated**: Use `wallet_action_start_options` instead.)
 */
export interface BulkOptionsBulkOptions {
    /**
     * ID of the bulk that issued the gift card or transaction.
     */
    'bulkId'?: string;
    /**
     * Indicates whether the gift card or transaction is a liability.
     */
    'liability'?: boolean;
    /**
     * Internal note about the bulk
     */
    'note'?: string;
}
/**
 * 
 */
export interface BulkReportEventRequest {
    /**
     * ey as defined in your app\'s trigger configuration in the app dashboard. For example, `form_submitted` or `invoice_due`.
     */
    'triggerKey'?: string;
    /**
     * Repeated list of event details for bulk reporting.
     */
    'eventsInfo'?: Array<object>;
}
/**
 * 
 */
export interface BulkReportEventResponse {
    /**
     * Trigger key associated with the event.
     */
    'triggerKey'?: string;
    /**
     * List of results for each item in the bulk report event request.
     */
    'results'?: Array<object>;
    /**
     * Metadata for the overall bulk action, including success and failure counts.
     */
    'bulkActionMetadata'?: object;
}
/**
 * 
 */
export interface BulkReportEventResult {
    /**
     * Metadata for the individual item in the request.
     */
    'itemMetadata'?: object;
    /**
     * Event details for the item in the request.
     */
    'eventInfo'?: object;
    /**
     * The activation IDs of triggered ReportEvents.
     */
    'activationIds'?: Array<string>;
}
/**
 * 
 */
export interface BulkUpdateWalletActionTagsByFilterRequest {
    /**
     * Filter
     */
    'filter'?: object;
    /**
     * List of Tags to assign
     */
    'assignTags'?: object;
    /**
     * List of Tags to unAssign
     */
    'unassignTags'?: object;
}
/**
 * 
 */
export interface BulkUpdateWalletActionTagsByFilterResponse {
    /**
     * Job ID
     */
    'jobId'?: string;
}
/**
 * 
 */
export interface BulkUpdateWalletActionTagsRequest {
    /**
     * List of wallet-actions that their tags will update.
     */
    'ids'?: Array<string>;
    /**
     * List of Tags to assign
     */
    'assignTags'?: object;
    /**
     * List of Tags to unAssign
     */
    'unassignTags'?: object;
}
/**
 * 
 */
export interface BulkUpdateWalletActionTagsResponse {
    /**
     * Results
     */
    'results'?: Array<object>;
    /**
     * Metadata regarding the bulk update operation
     */
    'bulkActionMetadata'?: object;
}
/**
 * 
 */
export interface BulkUpdateWalletActionTagsResult {
    /**
     * Metadata regarding the specific single update operation
     */
    'itemMetadata'?: object;
}
/**
 * Information about the buyer of a GiftCard Order.
 */
export interface BuyerInfo {
    /**
     * The buyer\'s first name.
     */
    'firstName'?: string;
    /**
     * The buyer\'s last name.
     */
    'lastName'?: string;
    /**
     * The buyer\'s email address.
     */
    'email'?: string;
    /**
     * deprecated
     */
    'billingAddress'?: string;
    /**
     * The buyer\'s customer ID in the source sales channel (if it exists).
     */
    'sourceCustomerId'?: string;
    /**
     * Billing information of the buyer.
     */
    'billingInfo'?: object;
}
/**
 * Information about the buyer.
 */
export interface BuyerInfo1 {
    /**
     * The buyer\'s first name.
     */
    'firstName'?: string;
    /**
     * The buyer\'s last name.
     */
    'lastName'?: string;
    /**
     * The buyer\'s email address.
     */
    'email'?: string;
    /**
     * deprecated (**Deprecated**: Use `billing_info` instead.)
     * @deprecated
     */
    'billingAddress'?: string;
    /**
     * The buyer\'s customer ID in the source sales channel (if it exists).
     */
    'sourceCustomerId'?: string;
    'billingInfo'?: BillingInfo1;
}
export interface By {
    /**
     * 
     */
    'id'?: string;
    /**
     * 
     */
    'identifier'?: string;
    /**
     * 
     */
    'configurationCorrelationId'?: string;
    /**
     * 
     */
    'activationId'?: string;
    /**
     * 
     */
    'identifierPattern'?: string;
}
export interface CampaignOptions {
    /**
     * @deprecated
     */
    'campaignOptions'?: CampaignOptionsCampaignOptions;
}
/**
 * Bulk Options. (**Deprecated**: Use `bulk_options` instead.)
 */
export interface CampaignOptionsCampaignOptions {
    /**
     * 
     */
    'campaignId'?: string;
    /**
     * 
     */
    'liability'?: boolean;
}
/**
 * 
 */
export interface CancelEventRequest {
    /**
     * ID of the related resource in GUID format. For example, `fc81a355-3429-50fc-a4c7-def486e828f3`.  Typically, this ID is defined in your system, but you can also use any resource GUID, such as contact ID, member ID, or invoice ID. See [Choose the right `externalEntityId`](https://dev.wix.com/docs/rest/business-management/automations/triggered-events/reporting-and-canceling-events#choose-the-right-externalentityid) for more information.
     */
    'externalEntityId'?: string;
    /**
     * er key whose event you want to cancel. For example, `form_submitted` or `invoice_due`.
     */
    'triggerKey'?: string;
}
/**
 * 
 */

export const CancellationReason = {
    EventCancelled: 'EVENT_CANCELLED',
    AutomationDeactivated: 'AUTOMATION_DEACTIVATED',
    AutomationDeleted: 'AUTOMATION_DELETED',
    CancelledByRefreshPayload: 'CANCELLED_BY_REFRESH_PAYLOAD',
    CancelledByGdprRequest: 'CANCELLED_BY_GDPR_REQUEST'
} as const;

export type CancellationReason = typeof CancellationReason[keyof typeof CancellationReason];


/**
 * 
 */
export interface CancelledStatusInfo {
    /**
     * Cancellation reason
     */
    'reason'?: string;
    /**
     * Identity (such as user, app, etc.) that caused the cancellation.
     */
    'initiator'?: object;
}
/**
 * 
 */
export interface Case {
    /**
     * Case\'s condition.
     */
    'condition'?: object;
    /**
     * Case\'s post actions.
     */
    'postActions'?: Array<object>;
    /**
     * Case\'s post actions ids.
     */
    'postActionsIds'?: Array<string>;
}
/**
 * 
 */
export interface ConditionAction {
    /**
     * The condition evaluates to `true` if either of the expression groups evaluate to `true`.
     */
    'orExpressionGroups'?: Array<object>;
    /**
     * List of IDs of actions to run when the entire condition is evaluated to `true`.
     */
    'truePostActionIds'?: Array<string>;
    /**
     * List of IDs of actions to run when the entire condition is evaluated to `false`.
     */
    'falsePostActionIds'?: Array<string>;
}
/**
 * 
 */
export interface ConditionActionInfo {
    /**
     * Indicates that the condition `if` clause evaluated to `true`.
     */
    'passed'?: boolean;
    'expressionResults'?: ExpressionResults;
}
/**
 * 
 */
export interface ConditionBlock {
    /**
     * 
     */
    'type'?: string;
    /**
     * 
     */
    'lineExpressions'?: Array<string>;
}
/**
 * 
 */
export interface ConditionExpressionGroup {
    /**
     * Expression group operator.
     */
    'operator'?: string;
    /**
     * List of boolean expressions to be evaluated with the given operator.
     */
    'booleanExpressions'?: Array<string>;
}
/**
 * 
 */
export interface ConditionFilter {
    /**
     * condition evaluates to `true` if either of the blocks evaluate to `true` (aka OR between all).
     */
    'conditionBlocks'?: Array<object>;
    /**
     * Actions to perform when condition_blocks evaluates to `true`.
     */
    'postActions'?: Array<object>;
    /**
     * Action\'s post actions ids.
     */
    'postActionsIds'?: Array<string>;
    /**
     * Actions to perform when condition_blocks evaluates to `false`.
     */
    'elsePostActions'?: Array<object>;
}
/**
 * 
 */
export interface ConsumeReportEventRequest {
    /**
     * Repeated list of event details for bulk reporting.
     */
    'eventsInfo'?: Array<object>;
    /**
     * trigger app id
     */
    'triggerAppId'?: string;
    /**
     * trigger key
     */
    'triggerKey'?: string;
}
/**
 * 
 */
export interface ContactDetails {
    /**
     * Email of the wallet.
     */
    'email'?: string;
    /**
     * Phone number of the wallet.
     */
    'phone'?: string;
    /**
     * First name of the wallet.
     */
    'firstName'?: string;
    /**
     * Last name of the wallet.
     */
    'lastName'?: string;
}
/**
 * 
 */
export interface ContactDetails1 {
    /**
     * Email of the wallet.
     */
    'email'?: string;
    /**
     * Phone number of the wallet.
     */
    'phone'?: string;
    /**
     * First name of the wallet.
     */
    'firstName'?: string;
    /**
     * Last name of the wallet.
     */
    'lastName'?: string;
}
/**
 * 
 */
export interface CountGiftCardsRequest {
    /**
     * [API Query Language](https://platform.rise.ai/docs/#tag/About-API-Query-Language) filter to count gift cards.
     */
    'filter'?: object;
}
/**
 * 
 */
export interface CountGiftCardsResponse {
    /**
     * The number of gift cards that match the provided filter.
     */
    'count'?: number;
}
/**
 * 
 */
export interface CountGiftCardsResponse1 {
    /**
     * The number of gift cards that match the provided filter.
     */
    'count'?: number;
}
/**
 * 
 */
export interface CountWalletsResponse {
    /**
     * Number of wallets matching the filter.
     */
    'count'?: number;
}
/**
 * 
 */
export interface CreateAccessTokenResponse {
    /**
     * Created access token.
     */
    'access_token'?: string;
    /**
     * Type of the created access token. Always `”Bearer”`.
     */
    'token_type'?: string;
    /**
     * Time the access token expires in seconds. Always `14400` (4 hours).
     */
    'expires_in'?: number;
}
/**
 * 
 */
export interface CreateCustomerReferenceRequest {
    /**
     * Customer reference
     */
    'customerReference'?: object;
}
/**
 * @type CreateGiftCard428Response
 */
export type CreateGiftCard428Response = EXISTINGIDEMPOTENCYKEY | INVALIDCODE | INVALIDEXPIRATIONDATE;

/**
 * 
 */
export interface CreateGiftCardResponse {
    'giftCard'?: GiftCard1;
}
/**
 * 
 */
export interface CreateMigrationWalletActionRequest {
    /**
     * WalletAction to be created.
     */
    'walletAction'?: object;
    /**
     * ID of the giftcard that belongs to the wallet.
     */
    'giftCardId'?: string;
}
/**
 * 
 */
export interface CreateOrderRequest {
    /**
     * Order to be created.
     */
    'order'?: object;
}
/**
 * 
 */
export interface CreateOrderResponse {
    'order'?: GiftCardOrder1;
}
/**
 * 
 */
export interface CreateRecipientRequest {
    /**
     * Recipient to be created.
     */
    'recipient'?: object;
    /**
     * Optional information about some side effects regarding the creation of the Recipient.
     */
    'sideEffects'?: object;
}
/**
 * 
 */
export interface CreateRecipientResponse {
    /**
     * The created Recipient.
     */
    'recipient'?: object;
}
/**
 * 
 */
export interface CreateRecipientResponse1 {
    'recipient'?: Recipient1;
}
/**
 * @type CreateWalletAction400Response
 */
export type CreateWalletAction400Response = DISABLEDATDATESET | EXPIRATIONDATEINTHEPAST | STARTLATERTHANEXPIRATION;

/**
 * 
 */
export interface CreateWalletActionByCustomerReferenceRequest {
    /**
     * CustomerReference of the customer for which to create the wallet action.
     */
    'customerReference'?: object;
    /**
     * WalletAction to be created.
     */
    'walletAction'?: object;
    /**
     * The currency for the new wallet, if no wallet already exists.
     */
    'newWalletCurrency'?: string;
}
/**
 * 
 */
export interface CreateWalletActionByCustomerReferenceResponse {
    /**
     * The created WalletAction.
     */
    'walletAction'?: object;
    /**
     * The wallet to which the wallet action was added.
     */
    'wallet'?: object;
}
/**
 * 
 */
export interface CreateWalletActionByCustomerReferenceResponse1 {
    'walletAction'?: WalletAction1;
    'wallet'?: Wallet1;
}
/**
 * 
 */
export interface CreateWalletActionResponse {
    'walletAction'?: WalletAction1;
}
/**
 * 
 */
export interface CreateWalletRequest {
    /**
     * Initial Customer Reference for the wallet.
     */
    'customerReference'?: object;
    /**
     * Initial amount of store credit.
     */
    'initialValue'?: string;
    /**
     * Currency of the wallet.
     */
    'currency'?: string;
}
/**
 * 
 */
export interface CreateWalletResponse {
    /**
     * Created wallet.
     */
    'wallet'?: object;
    /**
     * ID of the walletAction (store credit) created by this request.
     */
    'walletActionId'?: string;
}
/**
 * 
 */
export interface CreateWalletResponse1 {
    'wallet'?: Wallet3;
    /**
     * ID of the walletAction (store credit) created by this request.
     */
    'walletActionId'?: string;
}
/**
 * 
 */
export interface CreateWalletV2Request {
    /**
     * Currency of the wallet.
     */
    'currency'?: string;
    /**
     * Contact details of the wallet.
     */
    'contactDetails'?: object;
    /**
     * Optional initial Customer Reference for the wallet.
     */
    'customerReference'?: object;
}
/**
 * 
 */
export interface CreateWalletV2Response {
    /**
     * Created wallet.
     */
    'wallet'?: object;
}
export interface CursorPaging {
    'cursorPaging'?: PagingMethodCursorPaging;
}
/**
 * 
 */
export interface CursorPagingMetadata {
    /**
     * Number of items returned in the response.
     */
    'count'?: number;
    /**
     * Offset that was requested.
     */
    'cursors'?: object;
    /**
     * Indicates if there are more results after the current page. If `true`, another page of results can be retrieved. If `false`, this is the last page.
     */
    'hasNext'?: boolean;
}
/**
 * Paging metadata
 */
export interface CursorPagingMetadata1 {
    /**
     * Number of items returned in the response.
     */
    'count'?: number;
    'cursors'?: Cursors1;
    /**
     * Indicates if there are more results after the current page. If `true`, another page of results can be retrieved. If `false`, this is the last page.
     */
    'hasNext'?: boolean;
}
/**
 * Paging metadata. Contains cursor which can be used in next query.
 */
export interface CursorPagingMetadata2 {
    /**
     * Number of items returned in current page.
     */
    'count'?: number;
    'cursors'?: Cursors4;
    /**
     * Whether there are more pages to retrieve following the current page.  + `true`: Another page of results can be retrieved. + `false`: This is the last page.
     */
    'hasNext'?: boolean;
}
/**
 * Paging metadata
 */
export interface CursorPagingMetadata3 {
    /**
     * Number of items returned in the response.
     */
    'count'?: number;
    'cursors'?: Cursors5;
    /**
     * Indicates if there are more results after the current page. If `true`, another page of results can be retrieved. If `false`, this is the last page.
     */
    'hasNext'?: boolean;
}
/**
 * 
 */
export interface Cursors {
    /**
     * Cursor pointing to next page in the list of results.
     */
    'next'?: string;
    /**
     * Cursor pointing to previous page in the list of results.
     */
    'prev'?: string;
}
/**
 * Offset that was requested.
 */
export interface Cursors1 {
    /**
     * Cursor pointing to next page in the list of results.
     */
    'next'?: string;
    /**
     * Cursor pointing to previous page in the list of results.
     */
    'prev'?: string;
}
/**
 * Cursors to navigate through the result pages using `next` and `prev`. Returned if cursor paging is used.
 */
export interface Cursors2 {
    /**
     * Cursor string pointing to the next page in the list of results.
     */
    'next'?: string;
    /**
     * Cursor pointing to the previous page in the list of results.
     */
    'prev'?: string;
}
/**
 * Cursors to navigate through the result pages using `next` and `prev`. Returned if cursor paging is used.
 */
export interface Cursors3 {
    /**
     * Cursor pointing to next page in the list of results.
     */
    'next'?: string;
    /**
     * Cursor pointing to previous page in the list of results.
     */
    'prev'?: string;
}
/**
 * Cursor strings that point to the next page, previous page, or both.
 */
export interface Cursors4 {
    /**
     * Cursor string pointing to the next page in the list of results.
     */
    'next'?: string;
    /**
     * Cursor pointing to the previous page in the list of results.
     */
    'prev'?: string;
}
/**
 * Offset that was requested.
 */
export interface Cursors5 {
    /**
     * Cursor pointing to next page in the list of results.
     */
    'next'?: string;
    /**
     * Cursor pointing to previous page in the list of results.
     */
    'prev'?: string;
}
/**
 * A reference to a customer in a specific source channel, containing the channel, tenant, and customer ID of the customer in that source, as well as the customer\'s first name, last name, phone number, and email address.
 */
export interface CustomerReference {
    /**
     * Source channel, i.e. Shopify.
     */
    'sourceChannelId'?: string;
    /**
     * Tenant ID in Source, i.e. shop ID.
     */
    'sourceTenantId'?: string;
    /**
     * Customer ID in Source.
     */
    'sourceCustomerId'?: string;
    /**
     * First name.
     */
    'firstName'?: string;
    /**
     * Last name.
     */
    'lastName'?: string;
    /**
     * Phone number.
     */
    'phone'?: string;
    /**
     * Email address.
     */
    'email'?: string;
}
/**
 * A reference to a customer in a specific source channel, containing the channel, tenant, and customer ID of the customer in that source, as well as the customer\'s first name, last name, phone number, and email address.
 */
export interface CustomerReference1 {
    /**
     * Source channel, i.e. Shopify.
     */
    'sourceChannelId'?: string;
    /**
     * Tenant ID in Source, i.e. shop ID.
     */
    'sourceTenantId'?: string;
    /**
     * Customer ID in Source.
     */
    'sourceCustomerId'?: string;
    /**
     * First name.
     */
    'firstName'?: string;
    /**
     * Last name.
     */
    'lastName'?: string;
    /**
     * Phone number.
     */
    'phone'?: string;
    /**
     * Email address.
     */
    'email'?: string;
}
/**
 * Retrieved Customer reference.
 */
export interface CustomerReference2 {
    /**
     * Source channel, i.e. Shopify.
     */
    'sourceChannelId'?: string;
    /**
     * Tenant ID in Source, i.e. shop ID.
     */
    'sourceTenantId'?: string;
    /**
     * Customer ID in Source.
     */
    'sourceCustomerId'?: string;
    /**
     * First name.
     */
    'firstName'?: string;
    /**
     * Last name.
     */
    'lastName'?: string;
    /**
     * Phone number.
     */
    'phone'?: string;
    /**
     * Email address.
     */
    'email'?: string;
}
/**
 * CustomerReference of the customer for which to create the wallet action.
 */
export interface CustomerReference3 {
    /**
     * Source channel, i.e. Shopify.
     */
    'sourceChannelId': string;
    /**
     * Tenant ID in Source, i.e. shop ID.
     */
    'sourceTenantId': string;
    /**
     * Customer ID in Source.
     */
    'sourceCustomerId': string;
    /**
     * First name.
     */
    'firstName'?: string;
    /**
     * Last name.
     */
    'lastName'?: string;
    /**
     * Phone number.
     */
    'phone'?: string;
    /**
     * Email address.
     */
    'email': string;
}
/**
 * Initial Customer Reference for the wallet.
 */
export interface CustomerReference4 {
    /**
     * Source channel, i.e. Shopify.
     */
    'sourceChannelId': string;
    /**
     * Tenant ID in Source, i.e. shop ID.
     */
    'sourceTenantId': string;
    /**
     * Customer ID in Source.
     */
    'sourceCustomerId': string;
    /**
     * First name.
     */
    'firstName'?: string;
    /**
     * Last name.
     */
    'lastName'?: string;
    /**
     * Phone number.
     */
    'phone'?: string;
    /**
     * Email address.
     */
    'email': string;
}
/**
 * The customer reference with which to create or retrieve the wallet.
 */
export interface CustomerReference5 {
    /**
     * Source channel, i.e. Shopify.
     */
    'sourceChannelId': string;
    /**
     * Tenant ID in Source, i.e. shop ID.
     */
    'sourceTenantId': string;
    /**
     * Customer ID in Source.
     */
    'sourceCustomerId': string;
    /**
     * First name.
     */
    'firstName'?: string;
    /**
     * Last name.
     */
    'lastName'?: string;
    /**
     * Phone number.
     */
    'phone'?: string;
    /**
     * Email address.
     */
    'email': string;
}
/**
 * 
 */
export interface CustomerReferenceQuery {
    /**
     * CustomerReference source (i.e. source channel, tenant, and customer IDs)
     */
    'customerReferenceSource'?: object;
}
export interface DISABLEDATDATESET {
    /**
     * Error message
     */
    'message': string;
    'details': DISABLEDATDATESETDetails;
}
export interface DISABLEDATDATESETDetails {
    'applicationError': DISABLEDATDATESETDetailsApplicationError;
}
export interface DISABLEDATDATESETDetailsApplicationError {
    /**
     * Error code: DISABLED_AT_DATE_SET
     */
    'code': DISABLEDATDATESETDetailsApplicationErrorCodeEnum;
    /**
     * Error description
     */
    'description': string;
    'data'?: object;
}

export const DISABLEDATDATESETDetailsApplicationErrorCodeEnum = {
    DisabledAtDateSet: 'DISABLED_AT_DATE_SET'
} as const;

export type DISABLEDATDATESETDetailsApplicationErrorCodeEnum = typeof DISABLEDATDATESETDetailsApplicationErrorCodeEnum[keyof typeof DISABLEDATDATESETDetailsApplicationErrorCodeEnum];

/**
 * 
 */
export interface DateHistogramAggregation {
    /**
     * Interval for date histogram aggregation.
     */
    'interval'?: string;
}
/**
 * 
 */
export interface DateHistogramResult {
    /**
     * Date in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format.
     */
    'value'?: string;
    /**
     * Number of entities in the bucket.
     */
    'count'?: number;
}
export interface DateHistogramResults {
    'dateHistogram'?: NestedAggregationResults1OneOf4DateHistogram;
}
/**
 * @type DecreaseBalance428Response
 */
export type DecreaseBalance428Response = EXISTINGIDEMPOTENCYKEY | INSUFFICIENTFUNDS;

/**
 * 
 */
export interface DecreaseBalanceResponse {
    'transaction'?: Transaction2;
    /**
     * GiftCard balance after Transaction.
     */
    'balance'?: string;
    /**
     * Transaction Currency.
     */
    'currency'?: string;
}
/**
 * 
 */
export interface DelayAction {
    /**
     * Value expressing the amount of time to wait from a specific date or from the time the action is executed.
     */
    'offsetExpression'?: string;
    /**
     * Time unit for delay offset.
     */
    'offsetTimeUnit'?: string;
    /**
     * The action due date. If defined without an offset, the automation will wait until this date to execute the next step. If an offset is defined, it\'s calculated from this date. The date is expressed in the number of milliseconds since the Unix Epoch (1 January, 1970 UTC).
     */
    'dueDateEpochExpression'?: string;
    /**
     * List of IDs of actions to run in parallel after the delay.
     */
    'postActionIds'?: Array<string>;
}
/**
 * 
 */
export interface DelayActionInfo {
    /**
     * Enriched and refreshed payload
     */
    'payload'?: object;
}
/**
 * 
 */
export interface DelayHelper {
    /**
     * jsonata expression, for example: triggerName + eventId
     */
    'scheduleIdentifier'?: string;
    /**
     * decide how long we should wait
     */
    'delay'?: object;
    /**
     * Delay\'s post actions.
     */
    'postActions'?: Array<object>;
    /**
     * Optional: if true, any new schedule with the same schedule identifier will override the existing one. If false, the new schedule will be ignored.
     */
    'overrideable'?: boolean;
    /**
     * Delay\'s post actions ids.
     */
    'postActionsIds'?: Array<string>;
}
/**
 * 
 */
export interface DisableGiftCardResponse {
    'giftCard'?: GiftCard4;
}
/**
 * @type DisableWalletAction428Response
 */
export type DisableWalletAction428Response = WALLETACTIONALREADYEXPIRED | WALLETACTIONNOTACTIVE;

/**
 * 
 */
export interface DisableWalletActionRequest {
    /**
     * ID of the WalletAction to delete.
     */
    'walletActionId'?: string;
    /**
     * The revision of the WalletAction.
     */
    'revision'?: string;
}
/**
 * 
 */
export interface DisableWalletActionResponse {
    'walletAction'?: WalletAction3;
}
/**
 * 
 */

export const Domain = {
    User: 'USER',
    Wix: 'WIX',
    WixAccount: 'WIX_ACCOUNT'
} as const;

export type Domain = typeof Domain[keyof typeof Domain];


/**
 * 
 */
export interface DoubleValue {
    /**
     * 
     */
    'value'?: number;
}
/**
 * 
 */
export interface DraftInfo {
    /**
     * Optional - automationId of the original automation.
     */
    'originalAutomationId'?: string;
}
export interface EXISTINGIDEMPOTENCYKEY {
    /**
     * Error message
     */
    'message': string;
    'details': EXISTINGIDEMPOTENCYKEYDetails;
}
export interface EXISTINGIDEMPOTENCYKEYDetails {
    'applicationError': EXISTINGIDEMPOTENCYKEYDetailsApplicationError;
}
export interface EXISTINGIDEMPOTENCYKEYDetailsApplicationError {
    /**
     * Error code: EXISTING_IDEMPOTENCY_KEY
     */
    'code': EXISTINGIDEMPOTENCYKEYDetailsApplicationErrorCodeEnum;
    /**
     * Error description
     */
    'description': string;
    'data'?: object;
}

export const EXISTINGIDEMPOTENCYKEYDetailsApplicationErrorCodeEnum = {
    ExistingIdempotencyKey: 'EXISTING_IDEMPOTENCY_KEY'
} as const;

export type EXISTINGIDEMPOTENCYKEYDetailsApplicationErrorCodeEnum = typeof EXISTINGIDEMPOTENCYKEYDetailsApplicationErrorCodeEnum[keyof typeof EXISTINGIDEMPOTENCYKEYDetailsApplicationErrorCodeEnum];

export interface EXPIRATIONDATEINTHEPAST {
    /**
     * Error message
     */
    'message': string;
    'details': EXPIRATIONDATEINTHEPASTDetails;
}
export interface EXPIRATIONDATEINTHEPASTDetails {
    'applicationError': EXPIRATIONDATEINTHEPASTDetailsApplicationError;
}
export interface EXPIRATIONDATEINTHEPASTDetailsApplicationError {
    /**
     * Error code: EXPIRATION_DATE_IN_THE_PAST
     */
    'code': EXPIRATIONDATEINTHEPASTDetailsApplicationErrorCodeEnum;
    /**
     * Error description
     */
    'description': string;
    'data'?: object;
}

export const EXPIRATIONDATEINTHEPASTDetailsApplicationErrorCodeEnum = {
    ExpirationDateInThePast: 'EXPIRATION_DATE_IN_THE_PAST'
} as const;

export type EXPIRATIONDATEINTHEPASTDetailsApplicationErrorCodeEnum = typeof EXPIRATIONDATEINTHEPASTDetailsApplicationErrorCodeEnum[keyof typeof EXPIRATIONDATEINTHEPASTDetailsApplicationErrorCodeEnum];

/**
 * 
 */
export interface EmailParams {
    /**
     * Indicates whether to skip email dispatch for the WalletAction. The default is false.
     */
    'skipEmailDispatch'?: boolean;
    /**
     * ID of the email template to be used for the WalletAction, if default template is to be overridden.
     */
    'overrideTemplateId'?: string;
}
/**
 * Settings for email notifications related to the WalletAction. This field is used to specify whether to skip email dispatch or override the template ID for email notifications.
 */
export interface EmailParams1 {
    /**
     * Indicates whether to skip email dispatch for the WalletAction. The default is false.
     */
    'skipEmailDispatch'?: boolean;
    /**
     * ID of the email template to be used for the WalletAction, if default template is to be overridden.
     */
    'overrideTemplateId'?: string;
}
/**
 * 
 */
export interface EndMigrationWalletActionRequest {
    /**
     * ID of the WalletAction to be ended.
     */
    'walletActionId'?: string;
    /**
     * ID of the giftcard that belongs to the wallet.
     */
    'giftCardId'?: string;
    /**
     * Amount of the WalletAction to subtract from the wallet.
     */
    'amountToSubtract'?: string;
}
/**
 * 
 */
export interface Enrichment {
    /**
     * Enrichment input mappings.
     */
    'inputMappings'?: Array<object>;
}
/**
 * 
 */
export interface Enrichments {
    /**
     * Whether the studio site enrichment is wanted.
     */
    'studioSite'?: object;
}
/**
 * 
 */
export interface EntityCreatedEvent {
    /**
     * 
     */
    'entityAsJson'?: string;
    /**
     * Indicates the event was triggered by a restore-from-trashbin operation for a previously deleted entity
     */
    'restoreInfo'?: object;
}
/**
 * 
 */
export interface EntityDeletedEvent {
    /**
     * Entity that was deleted
     */
    'deletedEntityAsJson'?: string;
}
/**
 * 
 */
export interface EntityUpdatedEvent {
    /**
     * Since platformized APIs only expose PATCH and not PUT we can\'t assume that the fields sent from the client are the actual diff. This means that to generate a list of changed fields (as opposed to sent fields) one needs to traverse both objects. We don\'t want to impose this on all developers and so we leave this traversal to the notification recipients which need it.
     */
    'currentEntityAsJson'?: string;
}
/**
 * 
 */

export const ErrorReason = {
    UnexpectedErrorReason: 'UNEXPECTED_ERROR_REASON',
    ScheduleDateEvaluationFailed: 'SCHEDULE_DATE_EVALUATION_FAILED'
} as const;

export type ErrorReason = typeof ErrorReason[keyof typeof ErrorReason];


/**
 * 
 */
export interface EventInfo {
    /**
     * Event payload, formatted as key:value pairs. Must comply with the payload schema if you provided one when configuring your trigger.
     */
    'payload'?: object;
    /**
     * ID of the related resource in GUID format.
     */
    'externalEntityId'?: string;
    /**
     * Idempotency information for the event.
     */
    'idempotency'?: object;
}
/**
 * 
 */
export interface ExecuteFromActionRequest {
    /**
     * Requested action id
     */
    'actionId'?: string;
    /**
     * Optional: an activation id to link this action to
     */
    'activationId'?: string;
    /**
     * Activation payload
     */
    'payload'?: object;
    /**
     * Configuration correlation id to run this action from
     */
    'configurationCorrelationId'?: string;
    /**
     * Optional - schedule id that this action was scheduled from
     */
    'scheduleId'?: string;
    /**
     * Optional - an external entity id that this execution is related to
     */
    'externalEntityId'?: string;
    /**
     * Optional - Activation automation
     */
    'automation'?: object;
}
/**
 * @type Expiration1
 * The expiration date to apply to the Gift Card.
 */
export type Expiration1 = FixedDate | RelativeExpiresAt;

export interface ExpirationType {
    /**
     * Expiration date
     */
    'fixedDate'?: string;
    /**
     * Relative Expiration period
     */
    'relative'?: object;
}
/**
 * 
 */
export interface ExpressionEvaluationResult {
    /**
     * Indicates if the expression was evaluated to true or false
     */
    'passed'?: boolean;
    /**
     * Indicates if there was an error in the evaluation process
     */
    'error'?: boolean;
}
/**
 * Collects results per each expression evaluation that took place
 */
export interface ExpressionResults {
    'key'?: string;
    'value'?: object;
}
/**
 * 
 */
export interface ExtendedFields {
    'namespaces'?: Namespaces;
}
/**
 * 
 */
export interface ExternalEvent {
    /**
     * Event type indicator
     */
    'name'?: string;
    /**
     * Short description or identifier of the event
     */
    'description'?: string;
}
/**
 * Information about an external event that lead to the transaction.
 */
export interface ExternalEvent1 {
    /**
     * Event type indicator
     */
    'name'?: ExternalEvent1NameEnum;
    /**
     * Short description or identifier of the event
     */
    'description'?: string;
}

export const ExternalEvent1NameEnum = {
    Order: 'ORDER',
    Refund: 'REFUND',
    Referral: 'REFERRAL',
    SignUp: 'SIGN_UP',
    Membership: 'MEMBERSHIP',
    Compensation: 'COMPENSATION',
    Other: 'OTHER'
} as const;

export type ExternalEvent1NameEnum = typeof ExternalEvent1NameEnum[keyof typeof ExternalEvent1NameEnum];

/**
 * Information about the external event that triggered the WalletAction, such as type of event and a short description or identifier of the event.
 */
export interface ExternalEvent2 {
    /**
     * Event type indicator
     */
    'name'?: ExternalEvent2NameEnum;
    /**
     * Short description or identifier of the event
     */
    'description'?: string;
}

export const ExternalEvent2NameEnum = {
    Order: 'ORDER',
    Refund: 'REFUND',
    Referral: 'REFERRAL',
    SignUp: 'SIGN_UP',
    Membership: 'MEMBERSHIP',
    Compensation: 'COMPENSATION',
    Other: 'OTHER'
} as const;

export type ExternalEvent2NameEnum = typeof ExternalEvent2NameEnum[keyof typeof ExternalEvent2NameEnum];

/**
 * 
 */

export const ExternalEventType = {
    Order: 'ORDER',
    Refund: 'REFUND',
    Referral: 'REFERRAL',
    SignUp: 'SIGN_UP',
    Membership: 'MEMBERSHIP',
    Compensation: 'COMPENSATION',
    Other: 'OTHER'
} as const;

export type ExternalEventType = typeof ExternalEventType[keyof typeof ExternalEventType];


/**
 * 
 */
export interface FailedStatusInfo {
    /**
     * Error description
     */
    'errorDescription'?: string;
    /**
     * Error code
     */
    'errorCode'?: string;
}
/**
 * 
 */
export interface FailureInfo {
    /**
     * Description of the error that caused the action to fail.
     */
    'errorDescription'?: string;
}
/**
 * 
 */
export interface FieldMask {
    /**
     * 
     */
    'paths'?: Array<string>;
}
/**
 * 
 */
export interface Fields {
    'key'?: string;
    'value'?: object;
}
/**
 * 
 */
export interface Fields1 {
    'key'?: string;
    'value'?: Value1;
}
/**
 * 
 */
export interface Fields2 {
    'key'?: string;
    'value'?: Kind;
}
/**
 * Filter object.  Learn more about [filtering](https://dev.wix.com/docs/rest/articles/getting-started/api-query-language#filters).
 */
export interface Filter {
    'fields'?: Fields1;
}
/**
 * Filter object in the following format: `\"filter\" : { \"fieldName1\": \"value1\", \"fieldName2\":{\"$operator\":\"value2\"} }` Example of operators: `$eq`, `$ne`, `$lt`, `$lte`, `$gt`, `$gte`, `$in`, `$hasSome`, `$hasAll`, `$startsWith`, `$contains`
 */
export interface Filter1 {
    'fields'?: Fields1;
}
/**
 * [API Query Language](https://platform.rise.ai/docs/#tag/About-API-Query-Language) filter to count gift cards.
 */
export interface Filter2 {
    'fields'?: Fields2;
}
/**
 * Filter by which to count wallets.
 */
export interface Filter3 {
    'fields'?: Fields1;
}
/**
 * Contact filter object.
 */
export interface Filter4 {
    'fields'?: Fields1;
}
/**
 * 
 */
export interface FilterValueSelection {
    /**
     * Values that can help the user filter certain automations, values will look like \"<filter_id>__<selected_value>\"
     */
    'selectedFilterValues'?: Array<string>;
}
/**
 * 
 */
export interface FilterableAppDefinedActions {
    /**
     * App defined action identifiers, each identifier in form `${appId}_${actionKey}`
     */
    'actionIdentifiers'?: Array<string>;
}
/**
 * Expiration date
 */
export interface FixedDate {
    /**
     * Expiration date
     */
    'fixedDate'?: string;
}
/**
 * 
 */

export const FraudType = {
    UnknownFraudType: 'UNKNOWN_FRAUD_TYPE',
    None: 'NONE',
    ShopifyIndication: 'SHOPIFY_INDICATION',
    RiseBoughtWithGiftCard: 'RISE_BOUGHT_WITH_GIFT_CARD',
    RiseBoughtWithDiscount: 'RISE_BOUGHT_WITH_DISCOUNT'
} as const;

export type FraudType = typeof FraudType[keyof typeof FraudType];


/**
 * 
 */
export interface FulfillOrderRequest {
    /**
     * Order ID or Source Identifiers of the Order to fulfill.
     */
    'query'?: object;
}
/**
 * Data about the gift cards that were already fulfilled for this Line Item.
 */
export interface FulfilledData {
    /**
     * List of the IDs of the Gift Cards that were already fulfilled for this Line Item.
     */
    'giftCardIds'?: Array<string>;
}
/**
 * Data about the gift cards that were already fulfilled for this Line Item.
 */
export interface FulfilledData1 {
    /**
     * List of the IDs of the Gift Cards that were already fulfilled for this Line Item.
     */
    'giftCardIds'?: Array<string>;
}
/**
 * 
 */

export const FulfillmentStatus = {
    UnknownFulfillmentStatus: 'UNKNOWN_FULFILLMENT_STATUS',
    Pending: 'PENDING',
    Fulfilled: 'FULFILLED',
    InProgress: 'IN_PROGRESS',
    NotFulfilled: 'NOT_FULFILLED',
    Delayed: 'DELAYED'
} as const;

export type FulfillmentStatus = typeof FulfillmentStatus[keyof typeof FulfillmentStatus];


/**
 * 
 */
export interface FutureDateActivationOffset {
    /**
     * The offset value. The value is always taken as negative, so that the automation runs before the trigger date. To create an offset that causes the automation to run after the trigger date, use a delay action.
     */
    'preScheduledEventOffsetExpression'?: string;
    /**
     * Time unit for the scheduled event offset.
     */
    'scheduledEventOffsetTimeUnit'?: string;
}
export interface GIFTCARDDISABLED {
    /**
     * Error message
     */
    'message': string;
    'details': GIFTCARDDISABLEDDetails;
}
export interface GIFTCARDDISABLEDDetails {
    'applicationError': GIFTCARDDISABLEDDetailsApplicationError;
}
export interface GIFTCARDDISABLEDDetailsApplicationError {
    /**
     * Error code: GIFT_CARD_DISABLED
     */
    'code': GIFTCARDDISABLEDDetailsApplicationErrorCodeEnum;
    /**
     * Error description
     */
    'description': string;
    'data'?: object;
}

export const GIFTCARDDISABLEDDetailsApplicationErrorCodeEnum = {
    GiftCardDisabled: 'GIFT_CARD_DISABLED'
} as const;

export type GIFTCARDDISABLEDDetailsApplicationErrorCodeEnum = typeof GIFTCARDDISABLEDDetailsApplicationErrorCodeEnum[keyof typeof GIFTCARDDISABLEDDetailsApplicationErrorCodeEnum];

export interface GIFTCARDEXPIRED {
    /**
     * Error message
     */
    'message': string;
    'details': GIFTCARDEXPIREDDetails;
}
export interface GIFTCARDEXPIREDDetails {
    'applicationError': GIFTCARDEXPIREDDetailsApplicationError;
}
export interface GIFTCARDEXPIREDDetailsApplicationError {
    /**
     * Error code: GIFT_CARD_EXPIRED
     */
    'code': GIFTCARDEXPIREDDetailsApplicationErrorCodeEnum;
    /**
     * Error description
     */
    'description': string;
    'data'?: object;
}

export const GIFTCARDEXPIREDDetailsApplicationErrorCodeEnum = {
    GiftCardExpired: 'GIFT_CARD_EXPIRED'
} as const;

export type GIFTCARDEXPIREDDetailsApplicationErrorCodeEnum = typeof GIFTCARDEXPIREDDetailsApplicationErrorCodeEnum[keyof typeof GIFTCARDEXPIREDDetailsApplicationErrorCodeEnum];

export interface GIFTCARDNOTFOUND {
    /**
     * Error message
     */
    'message': string;
    'details': GIFTCARDNOTFOUNDDetails;
}
export interface GIFTCARDNOTFOUNDDetails {
    'applicationError': GIFTCARDNOTFOUNDDetailsApplicationError;
}
export interface GIFTCARDNOTFOUNDDetailsApplicationError {
    /**
     * Error code: GIFT_CARD_NOT_FOUND
     */
    'code': GIFTCARDNOTFOUNDDetailsApplicationErrorCodeEnum;
    /**
     * Error description
     */
    'description': string;
    'data'?: object;
}

export const GIFTCARDNOTFOUNDDetailsApplicationErrorCodeEnum = {
    GiftCardNotFound: 'GIFT_CARD_NOT_FOUND'
} as const;

export type GIFTCARDNOTFOUNDDetailsApplicationErrorCodeEnum = typeof GIFTCARDNOTFOUNDDetailsApplicationErrorCodeEnum[keyof typeof GIFTCARDNOTFOUNDDetailsApplicationErrorCodeEnum];

/**
 * 
 */
export interface GetCustomerReferenceRequest {
    /**
     * Customer Reference query object.
     */
    'query'?: object;
}
/**
 * 
 */
export interface GetCustomerReferenceResponse {
    'customerReference'?: CustomerReference2;
}
/**
 * @type GetGiftCard428Response
 */
export type GetGiftCard428Response = GIFTCARDDISABLED | GIFTCARDEXPIRED;

/**
 * 
 */
export interface GetGiftCardResponse {
    'giftCard'?: GiftCard2;
}
/**
 * 
 */
export interface GetOrCreateWalletRequest {
    /**
     * The customer reference with which to create or retrieve the wallet.
     */
    'customerReference'?: object;
    /**
     * Currency of the wallet.
     */
    'currency'?: string;
}
/**
 * 
 */
export interface GetOrCreateWalletResponse {
    'wallet'?: Wallet4;
}
/**
 * 
 */
export interface GetOrCreateWalletV2Request {
    /**
     * Contact details of the wallet.
     */
    'contactDetails'?: object;
    /**
     * Optional initial Customer Reference for the wallet.
     */
    'customerReference'?: object;
}
/**
 * 
 */
export interface GetOrderRequest {
    /**
     * ID of the Order to retrieve.
     */
    'orderId'?: string;
}
/**
 * 
 */
export interface GetRecipientRequest {
    /**
     * ID of the Recipient to retrieve.
     */
    'recipientId'?: string;
}
/**
 * 
 */
export interface GetRecipientResponse {
    'recipient'?: Recipient2;
}
/**
 * 
 */
export interface GetRefundableAmountsResponse {
    /**
     * 
     */
    'amounts'?: Array<object>;
}
/**
 * 
 */
export interface GetRefundableAmountsResponse1 {
    /**
     * 
     */
    'amounts'?: Array<RefundableAmount1>;
}
/**
 * 
 */
export interface GetWalletRequest {
    /**
     * Query object.
     */
    'query'?: object;
}
/**
 * 
 */
export interface GetWalletResponse {
    'wallet'?: Wallet2;
}
/**
 * 
 */
export interface GetWalletV2Request {
    /**
     * Query object.
     */
    'query'?: object;
    /**
     * Additional fields to include in the response.
     */
    'fields'?: Array<object>;
}
/**
 * GiftCard is the main entity of GiftCardService. It contains basic information such as gift card code, balance, and expiration date, as well as information about the source of the gift card (e.g., purchase, migration, etc.).
 */
export interface GiftCard {
    /**
     * Unique ID of the Gift Card.
     */
    'id'?: string;
    /**
     * Gift Card code for redemption.
     */
    'code'?: string;
    /**
     * Initial value of the Gift Card.
     */
    'initialValue'?: string;
    /**
     * Current balance of the Gift Card.
     */
    'balance'?: string;
    /**
     * Information about the source of the gift card.
     */
    'sourceInfo'?: object;
    /**
     * Gift Card revision.
     */
    'revision'?: string;
    /**
     * Gift Card currency.
     */
    'currency'?: string;
    /**
     * Gift Card expiration date.
     */
    'expirationDate'?: string;
    /**
     * Gift Card creation date.
     */
    'createdDate'?: string;
    /**
     * Gift Card last update date.
     */
    'updatedDate'?: string;
    /**
     * ID of the last transaction that modified the gift card balance.
     */
    'lastTransactionId'?: string;
    /**
     * Gift Card disable date, if the gift card was disabled.
     */
    'disableDate'?: string;
    /**
     * Gift Card idempotency key, to prevent duplicate creation.
     */
    'idempotencyKey'?: string;
    /**
     * Last 4 characters of the gift card code for easier reference and searching.
     */
    'codeSuffix'?: string;
    /**
     * Transaction details related to the gift card.
     */
    'transactionDetails'?: object;
}
/**
 * The created GiftCard.
 */
export interface GiftCard1 {
    /**
     * Unique ID of the Gift Card.
     */
    'id'?: string;
    /**
     * Gift Card code for redemption.
     */
    'code'?: string;
    /**
     * Initial value of the Gift Card.
     */
    'initialValue'?: string;
    /**
     * Current balance of the Gift Card.
     */
    'balance'?: string;
    'sourceInfo'?: GiftCardSourceInfo1;
    /**
     * Gift Card revision.
     */
    'revision'?: string;
    /**
     * Gift Card currency.
     */
    'currency'?: string;
    /**
     * Gift Card expiration date.
     */
    'expirationDate'?: string;
    /**
     * Gift Card creation date.
     */
    'createdDate'?: string;
    /**
     * Gift Card last update date.
     */
    'updatedDate'?: string;
    /**
     * ID of the last transaction that modified the gift card balance. (**Deprecated**: Use `id` instead.)
     * @deprecated
     */
    'lastTransactionId'?: string;
    /**
     * Gift Card disable date, if the gift card was disabled.
     */
    'disableDate'?: string;
    /**
     * Gift Card idempotency key, to prevent duplicate creation.
     */
    'idempotencyKey'?: string;
    /**
     * Last 4 characters of the gift card code for easier reference and searching.
     */
    'codeSuffix'?: string;
    'transactionDetails'?: TransactionDetails1;
}
/**
 * The retrieved GiftCard.
 */
export interface GiftCard2 {
    /**
     * Unique ID of the Gift Card.
     */
    'id'?: string;
    /**
     * Gift Card code for redemption.
     */
    'code'?: string;
    /**
     * Initial value of the Gift Card.
     */
    'initialValue'?: string;
    /**
     * Current balance of the Gift Card.
     */
    'balance'?: string;
    'sourceInfo'?: GiftCardSourceInfo1;
    /**
     * Gift Card revision.
     */
    'revision'?: string;
    /**
     * Gift Card currency.
     */
    'currency'?: string;
    /**
     * Gift Card expiration date.
     */
    'expirationDate'?: string;
    /**
     * Gift Card creation date.
     */
    'createdDate'?: string;
    /**
     * Gift Card last update date.
     */
    'updatedDate'?: string;
    /**
     * ID of the last transaction that modified the gift card balance. (**Deprecated**: Use `id` instead.)
     * @deprecated
     */
    'lastTransactionId'?: string;
    /**
     * Gift Card disable date, if the gift card was disabled.
     */
    'disableDate'?: string;
    /**
     * Gift Card idempotency key, to prevent duplicate creation.
     */
    'idempotencyKey'?: string;
    /**
     * Last 4 characters of the gift card code for easier reference and searching.
     */
    'codeSuffix'?: string;
    'transactionDetails'?: TransactionDetails1;
}
/**
 * The updated GiftCard.
 */
export interface GiftCard3 {
    /**
     * Unique ID of the Gift Card.
     */
    'id'?: string;
    /**
     * Gift Card code for redemption.
     */
    'code'?: string;
    /**
     * Initial value of the Gift Card.
     */
    'initialValue'?: string;
    /**
     * Current balance of the Gift Card.
     */
    'balance'?: string;
    'sourceInfo'?: GiftCardSourceInfo1;
    /**
     * Gift Card revision.
     */
    'revision'?: string;
    /**
     * Gift Card currency.
     */
    'currency'?: string;
    /**
     * Gift Card expiration date.
     */
    'expirationDate'?: string;
    /**
     * Gift Card creation date.
     */
    'createdDate'?: string;
    /**
     * Gift Card last update date.
     */
    'updatedDate'?: string;
    /**
     * ID of the last transaction that modified the gift card balance. (**Deprecated**: Use `id` instead.)
     * @deprecated
     */
    'lastTransactionId'?: string;
    /**
     * Gift Card disable date, if the gift card was disabled.
     */
    'disableDate'?: string;
    /**
     * Gift Card idempotency key, to prevent duplicate creation.
     */
    'idempotencyKey'?: string;
    /**
     * Last 4 characters of the gift card code for easier reference and searching.
     */
    'codeSuffix'?: string;
    'transactionDetails'?: TransactionDetails1;
}
/**
 * The disabled GiftCard.
 */
export interface GiftCard4 {
    /**
     * Unique ID of the Gift Card.
     */
    'id'?: string;
    /**
     * Gift Card code for redemption.
     */
    'code'?: string;
    /**
     * Initial value of the Gift Card.
     */
    'initialValue'?: string;
    /**
     * Current balance of the Gift Card.
     */
    'balance'?: string;
    'sourceInfo'?: GiftCardSourceInfo1;
    /**
     * Gift Card revision.
     */
    'revision'?: string;
    /**
     * Gift Card currency.
     */
    'currency'?: string;
    /**
     * Gift Card expiration date.
     */
    'expirationDate'?: string;
    /**
     * Gift Card creation date.
     */
    'createdDate'?: string;
    /**
     * Gift Card last update date.
     */
    'updatedDate'?: string;
    /**
     * ID of the last transaction that modified the gift card balance. (**Deprecated**: Use `id` instead.)
     * @deprecated
     */
    'lastTransactionId'?: string;
    /**
     * Gift Card disable date, if the gift card was disabled.
     */
    'disableDate'?: string;
    /**
     * Gift Card idempotency key, to prevent duplicate creation.
     */
    'idempotencyKey'?: string;
    /**
     * Last 4 characters of the gift card code for easier reference and searching.
     */
    'codeSuffix'?: string;
    'transactionDetails'?: TransactionDetails1;
}
/**
 * GiftCard is the main entity of GiftCardService. It contains basic information such as gift card code, balance, and expiration date, as well as information about the source of the gift card (e.g., purchase, migration, etc.).
 */
export interface GiftCard5 {
    /**
     * Unique ID of the Gift Card.
     */
    'id'?: string;
    /**
     * Gift Card code for redemption.
     */
    'code'?: string;
    /**
     * Initial value of the Gift Card.
     */
    'initialValue'?: string;
    /**
     * Current balance of the Gift Card.
     */
    'balance'?: string;
    'sourceInfo'?: GiftCardSourceInfo1;
    /**
     * Gift Card revision.
     */
    'revision'?: string;
    /**
     * Gift Card currency.
     */
    'currency'?: string;
    /**
     * Gift Card expiration date.
     */
    'expirationDate'?: string;
    /**
     * Gift Card creation date.
     */
    'createdDate'?: string;
    /**
     * Gift Card last update date.
     */
    'updatedDate'?: string;
    /**
     * ID of the last transaction that modified the gift card balance. (**Deprecated**: Use `id` instead.)
     * @deprecated
     */
    'lastTransactionId'?: string;
    /**
     * Gift Card disable date, if the gift card was disabled.
     */
    'disableDate'?: string;
    /**
     * Gift Card idempotency key, to prevent duplicate creation.
     */
    'idempotencyKey'?: string;
    /**
     * Last 4 characters of the gift card code for easier reference and searching.
     */
    'codeSuffix'?: string;
    'transactionDetails'?: TransactionDetails1;
}
/**
 * The GiftCard to create.
 */
export interface GiftCard6 {
    /**
     * Unique ID of the Gift Card.
     */
    'id'?: string;
    /**
     * Gift Card code for redemption.
     */
    'code'?: string;
    /**
     * Initial value of the Gift Card.
     */
    'initialValue': string;
    /**
     * Current balance of the Gift Card.
     */
    'balance'?: string;
    'sourceInfo': GiftCardSourceInfo2;
    /**
     * Gift Card revision.
     */
    'revision'?: string;
    /**
     * Gift Card currency.
     */
    'currency'?: string;
    /**
     * Gift Card expiration date.
     */
    'expirationDate'?: string;
    /**
     * Gift Card creation date.
     */
    'createdDate'?: string;
    /**
     * Gift Card last update date.
     */
    'updatedDate'?: string;
    /**
     * ID of the last transaction that modified the gift card balance. (**Deprecated**: Use `id` instead.)
     * @deprecated
     */
    'lastTransactionId'?: string;
    /**
     * Gift Card disable date, if the gift card was disabled.
     */
    'disableDate'?: string;
    /**
     * Gift Card idempotency key, to prevent duplicate creation.
     */
    'idempotencyKey'?: string;
    /**
     * Last 4 characters of the gift card code for easier reference and searching.
     */
    'codeSuffix'?: string;
    'transactionDetails'?: TransactionDetails1;
}
/**
 * The GiftCard to update.
 */
export interface GiftCard7 {
    /**
     * Unique ID of the Gift Card.
     */
    'id'?: string;
    /**
     * Gift Card code for redemption.
     */
    'code'?: string;
    /**
     * Initial value of the Gift Card.
     */
    'initialValue'?: string;
    /**
     * Current balance of the Gift Card.
     */
    'balance'?: string;
    'sourceInfo'?: GiftCardSourceInfo1;
    /**
     * Gift Card revision.
     */
    'revision': string;
    /**
     * Gift Card currency.
     */
    'currency'?: string;
    /**
     * Gift Card expiration date.
     */
    'expirationDate'?: string;
    /**
     * Gift Card creation date.
     */
    'createdDate'?: string;
    /**
     * Gift Card last update date.
     */
    'updatedDate'?: string;
    /**
     * ID of the last transaction that modified the gift card balance. (**Deprecated**: Use `id` instead.)
     * @deprecated
     */
    'lastTransactionId'?: string;
    /**
     * Gift Card disable date, if the gift card was disabled.
     */
    'disableDate'?: string;
    /**
     * Gift Card idempotency key, to prevent duplicate creation.
     */
    'idempotencyKey'?: string;
    /**
     * Last 4 characters of the gift card code for easier reference and searching.
     */
    'codeSuffix'?: string;
    'transactionDetails'?: TransactionDetails1;
}
/**
 * 
 */
export interface GiftCardCodeRegenerated {
    /**
     * previous gift card full code (pii)
     */
    'previousCode'?: string;
    /**
     * the previous code suffix of the gift card
     */
    'previousCodeSuffix'?: string;
    /**
     * updated gift card
     */
    'giftCard'?: object;
}
/**
 * 
 */
export interface GiftCardExpired {
    /**
     * The gift card that expired.
     */
    'giftCard'?: object;
}
/**
 * 
 */
export interface GiftCardGiftCardServiceV1RiseGiftCardsCountPostCountGiftCardsRequestBody {
    'filter'?: Filter2;
}
/**
 * 
 */
export interface GiftCardGiftCardServiceV1RiseGiftCardsGiftCardIdPatchUpdateGiftCardRequestBody {
    'giftCard': GiftCard7;
}
/**
 * 
 */
export interface GiftCardGiftCardServiceV1RiseGiftCardsPostCreateGiftCardRequestBody {
    'giftCard': GiftCard6;
}
/**
 * 
 */
export interface GiftCardGiftCardServiceV1RiseGiftCardsQueryPostQueryGiftCardsRequestBody {
    'query': PagingMethod;
}
/**
 * 
 */
export interface GiftCardGiftCardServiceV1RiseGiftCardsSearchPostSearchGiftCardsRequestBody {
    'search'?: PagingMethod;
}
/**
 * 
 */
export interface GiftCardGiftCardServiceV1RiseGiftCardsTransactionGiftCardIdIncreasePostIncreaseBalanceRequestBody {
    'transaction': Transaction3;
}
/**
 * 
 */
export interface GiftCardIdempotencyKeyDetails {
    /**
     * Idempotency Key
     */
    'idempotencyKey'?: string;
}
/**
 * Information about the Gift Card associated with a Wallet.
 */
export interface GiftCardInfo {
    /**
     * Gift Card Code
     */
    'code'?: string;
    /**
     * Current Gift Card Balance
     */
    'balance'?: string;
    /**
     * Gift Card Currency
     */
    'currency'?: string;
    /**
     * Gift Card Code Suffix
     */
    'codeSuffix'?: string;
}
/**
 * Information about the Gift Card associated with this Wallet.
 */
export interface GiftCardInfo1 {
    /**
     * Gift Card Code
     */
    'code'?: string;
    /**
     * Current Gift Card Balance
     */
    'balance'?: string;
    /**
     * Gift Card Currency
     */
    'currency'?: string;
    /**
     * Gift Card Code Suffix
     */
    'codeSuffix'?: string;
}
/**
 * The details of an order line item that is a Gift Card.
 */
export interface GiftCardLineItem {
    /**
     * Line Item ID in Rise.
     */
    'id'?: string;
    /**
     * Line Item ID in Source Channel.
     */
    'sourceLineItemId'?: string;
    /**
     * Product Variant ID in Source Channel.
     */
    'sourceVariantId'?: string;
    /**
     * The line Item\'s Gifting Information.
     */
    'giftingInfo'?: object;
    /**
     * Number of Gift Cards to create for this Line Item.
     */
    'quantity'?: number;
    /**
     * Number of Gift Cards that were already fulfilled for this Line Item.
     */
    'fulfilledQuantity'?: number;
    /**
     * Price of the Line Item.
     */
    'price'?: string;
    /**
     * The initial value to apply to the Gift Card.
     */
    'giftCardInitialValue'?: string;
    /**
     * Date and time the Line Item was last updated.
     */
    'updatedDate'?: string;
    /**
     * Data about the gift cards that were already fulfilled for this Line Item.
     */
    'fulfilledData'?: object;
    /**
     * The expiration date to apply to the Gift Card.
     */
    'giftCardExpiration'?: object;
    /**
     * Side effect for the gift card creation flow.
     */
    'sideEffects'?: object;
    /**
     * The encrypted code to create the Gift Card with.
     */
    'giftCardEncryptedCode'?: string;
}
/**
 * The details of an order line item that is a Gift Card.
 */
export interface GiftCardLineItem1 {
    /**
     * Line Item ID in Rise.
     */
    'id'?: string;
    /**
     * Line Item ID in Source Channel.
     */
    'sourceLineItemId'?: string;
    /**
     * Product Variant ID in Source Channel.
     */
    'sourceVariantId'?: string;
    'giftingInfo'?: GiftingInfo1;
    /**
     * Number of Gift Cards to create for this Line Item.
     */
    'quantity'?: number;
    /**
     * Number of Gift Cards that were already fulfilled for this Line Item.
     */
    'fulfilledQuantity'?: number;
    /**
     * Price of the Line Item.
     */
    'price'?: string;
    /**
     * The initial value to apply to the Gift Card.
     */
    'giftCardInitialValue'?: string;
    /**
     * Date and time the Line Item was last updated.
     */
    'updatedDate'?: string;
    'fulfilledData'?: FulfilledData1;
    'giftCardExpiration'?: Expiration1;
    'sideEffects'?: SideEffects1;
    /**
     * The encrypted code to create the Gift Card with.
     */
    'giftCardEncryptedCode'?: string;
}
export interface GiftCardOptions {
    /**
     * Detailed information about a Gift Card issued from an order.
     */
    'orderOptions'?: object;
    /**
     * Bulk Options (deprecated)
     */
    'campaignOptions'?: object;
    /**
     * Detailed information about a Gift Card or Gift Card Transaction whose source is a migration from Rise V1 or another platform.
     */
    'migrationOptions'?: object;
    /**
     * Detailed information about a Gift Card that belongs to a Store Credit Wallet.
     */
    'storeCreditOptions'?: object;
    /**
     * Detailed information about a Gift Card issued from a workflow.
     */
    'workflowOptions'?: object;
    /**
     * Detailed information about a Gift Card or Gift Card transaction issued from a bulk.
     */
    'bulkOptions'?: object;
    /**
     * Detailed information about a Gift Card that was created manually.
     */
    'manualOptions'?: object;
}
/**
 * A Gift Card Order is a reflection of an order in a Sales Channel that includes a Gift Card.
 */
export interface GiftCardOrder {
    /**
     * Order ID.
     */
    'id'?: string;
    /**
     * Revision number, which increments by 1 each time the Order is updated. To prevent conflicting changes, the current revision must be passed when updating the Order.  Ignored when creating a Order.
     */
    'revision'?: string;
    /**
     * Date and time the Order was created.
     */
    'createdDate'?: string;
    /**
     * Date and time the Order was last updated.
     */
    'updatedDate'?: string;
    /**
     * Source sales channel, i.e. Shopify.
     */
    'sourceChannelId'?: string;
    /**
     * Tenant ID in source sales channel, i.e. shop ID.
     */
    'sourceTenantId'?: string;
    /**
     * Order ID in source sales channel.
     */
    'sourceOrderId'?: string;
    /**
     * The order number in source sales channel.
     */
    'sourceOrderNumber'?: string;
    /**
     * The total amount of the order that contains the Gift Card.
     */
    'totalAmount'?: string;
    /**
     * The order\'s currency.
     */
    'currency'?: string;
    /**
     * Note to be added to the order.
     */
    'note'?: string;
    /**
     * The payment status of the order.
     */
    'paymentStatus'?: string;
    /**
     * Fulfillment status of the order in Rise.
     */
    'fulfillmentStatus'?: string;
    /**
     * Status of the order in Rise.
     */
    'status'?: string;
    /**
     * Information about the buyer.
     */
    'buyerInfo'?: object;
    /**
     * Date and time to fulfill the order by creating Gift Cards. Default is now.
     */
    'scheduleFulfillAt'?: string;
    /**
     * Date and time the order was fulfilled in Rise by creating Gift Cards.
     */
    'riseFulfilledAt'?: string;
    /**
     * Date and time the order was marked fulfilled in the Source sales channel.
     */
    'sourceFulfilledAt'?: string;
    /**
     * The line items in the order that are Gift Cards.
     */
    'lineItems'?: Array<object>;
    /**
     * The fraud message.
     */
    'fraudMessage'?: string;
    /**
     * The fraud logic type.
     */
    'fraudType'?: string;
    /**
     * Location ID in Source.
     */
    'sourceLocationId'?: string;
}
/**
 * The created Order.
 */
export interface GiftCardOrder1 {
    /**
     * Order ID.
     */
    'id'?: string;
    /**
     * Revision number, which increments by 1 each time the Order is updated. To prevent conflicting changes, the current revision must be passed when updating the Order.  Ignored when creating a Order.
     */
    'revision'?: string;
    /**
     * Date and time the Order was created.
     */
    'createdDate'?: string;
    /**
     * Date and time the Order was last updated.
     */
    'updatedDate'?: string;
    /**
     * Source sales channel, i.e. Shopify.
     */
    'sourceChannelId'?: string;
    /**
     * Tenant ID in source sales channel, i.e. shop ID.
     */
    'sourceTenantId'?: string;
    /**
     * Order ID in source sales channel.
     */
    'sourceOrderId'?: string;
    /**
     * The order number in source sales channel.
     */
    'sourceOrderNumber'?: string;
    /**
     * The total amount of the order that contains the Gift Card.
     */
    'totalAmount'?: string;
    /**
     * The order\'s currency.
     */
    'currency'?: string;
    /**
     * Note to be added to the order.
     */
    'note'?: string;
    /**
     * The payment status of the order.
     */
    'paymentStatus'?: GiftCardOrder1PaymentStatusEnum;
    /**
     * Fulfillment status of the order in Rise.
     */
    'fulfillmentStatus'?: GiftCardOrder1FulfillmentStatusEnum;
    /**
     * Status of the order in Rise.
     */
    'status'?: GiftCardOrder1StatusEnum;
    'buyerInfo'?: BuyerInfo1;
    /**
     * Date and time to fulfill the order by creating Gift Cards. Default is now.
     */
    'scheduleFulfillAt'?: string;
    /**
     * Date and time the order was fulfilled in Rise by creating Gift Cards.
     */
    'riseFulfilledAt'?: string;
    /**
     * Date and time the order was marked fulfilled in the Source sales channel.
     */
    'sourceFulfilledAt'?: string;
    /**
     * The line items in the order that are Gift Cards.
     */
    'lineItems'?: Array<GiftCardLineItem1>;
    /**
     * The fraud message.
     */
    'fraudMessage'?: string;
    /**
     * The fraud logic type.
     */
    'fraudType'?: GiftCardOrder1FraudTypeEnum;
    /**
     * Location ID in Source.
     */
    'sourceLocationId'?: string;
}

export const GiftCardOrder1PaymentStatusEnum = {
    UnknownPaymentStatus: 'UNKNOWN_PAYMENT_STATUS',
    NotPaid: 'NOT_PAID',
    PartiallyPaid: 'PARTIALLY_PAID',
    Paid: 'PAID',
    Refunded: 'REFUNDED',
    PartiallyRefunded: 'PARTIALLY_REFUNDED',
    Canceled: 'CANCELED'
} as const;

export type GiftCardOrder1PaymentStatusEnum = typeof GiftCardOrder1PaymentStatusEnum[keyof typeof GiftCardOrder1PaymentStatusEnum];
export const GiftCardOrder1FulfillmentStatusEnum = {
    UnknownFulfillmentStatus: 'UNKNOWN_FULFILLMENT_STATUS',
    Pending: 'PENDING',
    Fulfilled: 'FULFILLED',
    InProgress: 'IN_PROGRESS',
    NotFulfilled: 'NOT_FULFILLED',
    Delayed: 'DELAYED'
} as const;

export type GiftCardOrder1FulfillmentStatusEnum = typeof GiftCardOrder1FulfillmentStatusEnum[keyof typeof GiftCardOrder1FulfillmentStatusEnum];
export const GiftCardOrder1StatusEnum = {
    UnknownOrderStatus: 'UNKNOWN_ORDER_STATUS',
    Valid: 'VALID',
    Rejected: 'REJECTED',
    Suspicious: 'SUSPICIOUS'
} as const;

export type GiftCardOrder1StatusEnum = typeof GiftCardOrder1StatusEnum[keyof typeof GiftCardOrder1StatusEnum];
export const GiftCardOrder1FraudTypeEnum = {
    UnknownFraudType: 'UNKNOWN_FRAUD_TYPE',
    None: 'NONE',
    ShopifyIndication: 'SHOPIFY_INDICATION',
    RiseBoughtWithGiftCard: 'RISE_BOUGHT_WITH_GIFT_CARD',
    RiseBoughtWithDiscount: 'RISE_BOUGHT_WITH_DISCOUNT'
} as const;

export type GiftCardOrder1FraudTypeEnum = typeof GiftCardOrder1FraudTypeEnum[keyof typeof GiftCardOrder1FraudTypeEnum];

/**
 * Updated Order.
 */
export interface GiftCardOrder2 {
    /**
     * Order ID.
     */
    'id'?: string;
    /**
     * Revision number, which increments by 1 each time the Order is updated. To prevent conflicting changes, the current revision must be passed when updating the Order.  Ignored when creating a Order.
     */
    'revision'?: string;
    /**
     * Date and time the Order was created.
     */
    'createdDate'?: string;
    /**
     * Date and time the Order was last updated.
     */
    'updatedDate'?: string;
    /**
     * Source sales channel, i.e. Shopify.
     */
    'sourceChannelId'?: string;
    /**
     * Tenant ID in source sales channel, i.e. shop ID.
     */
    'sourceTenantId'?: string;
    /**
     * Order ID in source sales channel.
     */
    'sourceOrderId'?: string;
    /**
     * The order number in source sales channel.
     */
    'sourceOrderNumber'?: string;
    /**
     * The total amount of the order that contains the Gift Card.
     */
    'totalAmount'?: string;
    /**
     * The order\'s currency.
     */
    'currency'?: string;
    /**
     * Note to be added to the order.
     */
    'note'?: string;
    /**
     * The payment status of the order.
     */
    'paymentStatus'?: GiftCardOrder2PaymentStatusEnum;
    /**
     * Fulfillment status of the order in Rise.
     */
    'fulfillmentStatus'?: GiftCardOrder2FulfillmentStatusEnum;
    /**
     * Status of the order in Rise.
     */
    'status'?: GiftCardOrder2StatusEnum;
    'buyerInfo'?: BuyerInfo1;
    /**
     * Date and time to fulfill the order by creating Gift Cards. Default is now.
     */
    'scheduleFulfillAt'?: string;
    /**
     * Date and time the order was fulfilled in Rise by creating Gift Cards.
     */
    'riseFulfilledAt'?: string;
    /**
     * Date and time the order was marked fulfilled in the Source sales channel.
     */
    'sourceFulfilledAt'?: string;
    /**
     * The line items in the order that are Gift Cards.
     */
    'lineItems'?: Array<GiftCardLineItem1>;
    /**
     * The fraud message.
     */
    'fraudMessage'?: string;
    /**
     * The fraud logic type.
     */
    'fraudType'?: GiftCardOrder2FraudTypeEnum;
    /**
     * Location ID in Source.
     */
    'sourceLocationId'?: string;
}

export const GiftCardOrder2PaymentStatusEnum = {
    UnknownPaymentStatus: 'UNKNOWN_PAYMENT_STATUS',
    NotPaid: 'NOT_PAID',
    PartiallyPaid: 'PARTIALLY_PAID',
    Paid: 'PAID',
    Refunded: 'REFUNDED',
    PartiallyRefunded: 'PARTIALLY_REFUNDED',
    Canceled: 'CANCELED'
} as const;

export type GiftCardOrder2PaymentStatusEnum = typeof GiftCardOrder2PaymentStatusEnum[keyof typeof GiftCardOrder2PaymentStatusEnum];
export const GiftCardOrder2FulfillmentStatusEnum = {
    UnknownFulfillmentStatus: 'UNKNOWN_FULFILLMENT_STATUS',
    Pending: 'PENDING',
    Fulfilled: 'FULFILLED',
    InProgress: 'IN_PROGRESS',
    NotFulfilled: 'NOT_FULFILLED',
    Delayed: 'DELAYED'
} as const;

export type GiftCardOrder2FulfillmentStatusEnum = typeof GiftCardOrder2FulfillmentStatusEnum[keyof typeof GiftCardOrder2FulfillmentStatusEnum];
export const GiftCardOrder2StatusEnum = {
    UnknownOrderStatus: 'UNKNOWN_ORDER_STATUS',
    Valid: 'VALID',
    Rejected: 'REJECTED',
    Suspicious: 'SUSPICIOUS'
} as const;

export type GiftCardOrder2StatusEnum = typeof GiftCardOrder2StatusEnum[keyof typeof GiftCardOrder2StatusEnum];
export const GiftCardOrder2FraudTypeEnum = {
    UnknownFraudType: 'UNKNOWN_FRAUD_TYPE',
    None: 'NONE',
    ShopifyIndication: 'SHOPIFY_INDICATION',
    RiseBoughtWithGiftCard: 'RISE_BOUGHT_WITH_GIFT_CARD',
    RiseBoughtWithDiscount: 'RISE_BOUGHT_WITH_DISCOUNT'
} as const;

export type GiftCardOrder2FraudTypeEnum = typeof GiftCardOrder2FraudTypeEnum[keyof typeof GiftCardOrder2FraudTypeEnum];

/**
 * A Gift Card Order is a reflection of an order in a Sales Channel that includes a Gift Card.
 */
export interface GiftCardOrder3 {
    /**
     * Order ID.
     */
    'id'?: string;
    /**
     * Revision number, which increments by 1 each time the Order is updated. To prevent conflicting changes, the current revision must be passed when updating the Order.  Ignored when creating a Order.
     */
    'revision'?: string;
    /**
     * Date and time the Order was created.
     */
    'createdDate'?: string;
    /**
     * Date and time the Order was last updated.
     */
    'updatedDate'?: string;
    /**
     * Source sales channel, i.e. Shopify.
     */
    'sourceChannelId'?: string;
    /**
     * Tenant ID in source sales channel, i.e. shop ID.
     */
    'sourceTenantId'?: string;
    /**
     * Order ID in source sales channel.
     */
    'sourceOrderId'?: string;
    /**
     * The order number in source sales channel.
     */
    'sourceOrderNumber'?: string;
    /**
     * The total amount of the order that contains the Gift Card.
     */
    'totalAmount'?: string;
    /**
     * The order\'s currency.
     */
    'currency'?: string;
    /**
     * Note to be added to the order.
     */
    'note'?: string;
    /**
     * The payment status of the order.
     */
    'paymentStatus'?: GiftCardOrder3PaymentStatusEnum;
    /**
     * Fulfillment status of the order in Rise.
     */
    'fulfillmentStatus'?: GiftCardOrder3FulfillmentStatusEnum;
    /**
     * Status of the order in Rise.
     */
    'status'?: GiftCardOrder3StatusEnum;
    'buyerInfo'?: BuyerInfo1;
    /**
     * Date and time to fulfill the order by creating Gift Cards. Default is now.
     */
    'scheduleFulfillAt'?: string;
    /**
     * Date and time the order was fulfilled in Rise by creating Gift Cards.
     */
    'riseFulfilledAt'?: string;
    /**
     * Date and time the order was marked fulfilled in the Source sales channel.
     */
    'sourceFulfilledAt'?: string;
    /**
     * The line items in the order that are Gift Cards.
     */
    'lineItems'?: Array<GiftCardLineItem1>;
    /**
     * The fraud message.
     */
    'fraudMessage'?: string;
    /**
     * The fraud logic type.
     */
    'fraudType'?: GiftCardOrder3FraudTypeEnum;
    /**
     * Location ID in Source.
     */
    'sourceLocationId'?: string;
}

export const GiftCardOrder3PaymentStatusEnum = {
    UnknownPaymentStatus: 'UNKNOWN_PAYMENT_STATUS',
    NotPaid: 'NOT_PAID',
    PartiallyPaid: 'PARTIALLY_PAID',
    Paid: 'PAID',
    Refunded: 'REFUNDED',
    PartiallyRefunded: 'PARTIALLY_REFUNDED',
    Canceled: 'CANCELED'
} as const;

export type GiftCardOrder3PaymentStatusEnum = typeof GiftCardOrder3PaymentStatusEnum[keyof typeof GiftCardOrder3PaymentStatusEnum];
export const GiftCardOrder3FulfillmentStatusEnum = {
    UnknownFulfillmentStatus: 'UNKNOWN_FULFILLMENT_STATUS',
    Pending: 'PENDING',
    Fulfilled: 'FULFILLED',
    InProgress: 'IN_PROGRESS',
    NotFulfilled: 'NOT_FULFILLED',
    Delayed: 'DELAYED'
} as const;

export type GiftCardOrder3FulfillmentStatusEnum = typeof GiftCardOrder3FulfillmentStatusEnum[keyof typeof GiftCardOrder3FulfillmentStatusEnum];
export const GiftCardOrder3StatusEnum = {
    UnknownOrderStatus: 'UNKNOWN_ORDER_STATUS',
    Valid: 'VALID',
    Rejected: 'REJECTED',
    Suspicious: 'SUSPICIOUS'
} as const;

export type GiftCardOrder3StatusEnum = typeof GiftCardOrder3StatusEnum[keyof typeof GiftCardOrder3StatusEnum];
export const GiftCardOrder3FraudTypeEnum = {
    UnknownFraudType: 'UNKNOWN_FRAUD_TYPE',
    None: 'NONE',
    ShopifyIndication: 'SHOPIFY_INDICATION',
    RiseBoughtWithGiftCard: 'RISE_BOUGHT_WITH_GIFT_CARD',
    RiseBoughtWithDiscount: 'RISE_BOUGHT_WITH_DISCOUNT'
} as const;

export type GiftCardOrder3FraudTypeEnum = typeof GiftCardOrder3FraudTypeEnum[keyof typeof GiftCardOrder3FraudTypeEnum];

/**
 * Order to be created.
 */
export interface GiftCardOrder4 {
    /**
     * Order ID.
     */
    'id'?: string;
    /**
     * Revision number, which increments by 1 each time the Order is updated. To prevent conflicting changes, the current revision must be passed when updating the Order.  Ignored when creating a Order.
     */
    'revision'?: string;
    /**
     * Date and time the Order was created.
     */
    'createdDate'?: string;
    /**
     * Date and time the Order was last updated.
     */
    'updatedDate'?: string;
    /**
     * Source sales channel, i.e. Shopify.
     */
    'sourceChannelId'?: string;
    /**
     * Tenant ID in source sales channel, i.e. shop ID.
     */
    'sourceTenantId'?: string;
    /**
     * Order ID in source sales channel.
     */
    'sourceOrderId'?: string;
    /**
     * The order number in source sales channel.
     */
    'sourceOrderNumber'?: string;
    /**
     * The total amount of the order that contains the Gift Card.
     */
    'totalAmount'?: string;
    /**
     * The order\'s currency.
     */
    'currency'?: string;
    /**
     * Note to be added to the order.
     */
    'note'?: string;
    /**
     * The payment status of the order.
     */
    'paymentStatus'?: GiftCardOrder4PaymentStatusEnum;
    /**
     * Fulfillment status of the order in Rise.
     */
    'fulfillmentStatus'?: GiftCardOrder4FulfillmentStatusEnum;
    /**
     * Status of the order in Rise.
     */
    'status'?: GiftCardOrder4StatusEnum;
    'buyerInfo'?: BuyerInfo1;
    /**
     * Date and time to fulfill the order by creating Gift Cards. Default is now.
     */
    'scheduleFulfillAt'?: string;
    /**
     * Date and time the order was fulfilled in Rise by creating Gift Cards.
     */
    'riseFulfilledAt'?: string;
    /**
     * Date and time the order was marked fulfilled in the Source sales channel.
     */
    'sourceFulfilledAt'?: string;
    /**
     * The line items in the order that are Gift Cards.
     */
    'lineItems'?: Array<GiftCardLineItem1>;
    /**
     * The fraud message.
     */
    'fraudMessage'?: string;
    /**
     * The fraud logic type.
     */
    'fraudType'?: GiftCardOrder4FraudTypeEnum;
    /**
     * Location ID in Source.
     */
    'sourceLocationId'?: string;
}

export const GiftCardOrder4PaymentStatusEnum = {
    UnknownPaymentStatus: 'UNKNOWN_PAYMENT_STATUS',
    NotPaid: 'NOT_PAID',
    PartiallyPaid: 'PARTIALLY_PAID',
    Paid: 'PAID',
    Refunded: 'REFUNDED',
    PartiallyRefunded: 'PARTIALLY_REFUNDED',
    Canceled: 'CANCELED'
} as const;

export type GiftCardOrder4PaymentStatusEnum = typeof GiftCardOrder4PaymentStatusEnum[keyof typeof GiftCardOrder4PaymentStatusEnum];
export const GiftCardOrder4FulfillmentStatusEnum = {
    UnknownFulfillmentStatus: 'UNKNOWN_FULFILLMENT_STATUS',
    Pending: 'PENDING',
    Fulfilled: 'FULFILLED',
    InProgress: 'IN_PROGRESS',
    NotFulfilled: 'NOT_FULFILLED',
    Delayed: 'DELAYED'
} as const;

export type GiftCardOrder4FulfillmentStatusEnum = typeof GiftCardOrder4FulfillmentStatusEnum[keyof typeof GiftCardOrder4FulfillmentStatusEnum];
export const GiftCardOrder4StatusEnum = {
    UnknownOrderStatus: 'UNKNOWN_ORDER_STATUS',
    Valid: 'VALID',
    Rejected: 'REJECTED',
    Suspicious: 'SUSPICIOUS'
} as const;

export type GiftCardOrder4StatusEnum = typeof GiftCardOrder4StatusEnum[keyof typeof GiftCardOrder4StatusEnum];
export const GiftCardOrder4FraudTypeEnum = {
    UnknownFraudType: 'UNKNOWN_FRAUD_TYPE',
    None: 'NONE',
    ShopifyIndication: 'SHOPIFY_INDICATION',
    RiseBoughtWithGiftCard: 'RISE_BOUGHT_WITH_GIFT_CARD',
    RiseBoughtWithDiscount: 'RISE_BOUGHT_WITH_DISCOUNT'
} as const;

export type GiftCardOrder4FraudTypeEnum = typeof GiftCardOrder4FraudTypeEnum[keyof typeof GiftCardOrder4FraudTypeEnum];

/**
 * Order to be updated, may be partial.
 */
export interface GiftCardOrder5 {
    /**
     * Order ID.
     */
    'id': string;
    /**
     * Revision number, which increments by 1 each time the Order is updated. To prevent conflicting changes, the current revision must be passed when updating the Order.  Ignored when creating a Order.
     */
    'revision': string;
    /**
     * Date and time the Order was created.
     */
    'createdDate'?: string;
    /**
     * Date and time the Order was last updated.
     */
    'updatedDate'?: string;
    /**
     * Source sales channel, i.e. Shopify.
     */
    'sourceChannelId'?: string;
    /**
     * Tenant ID in source sales channel, i.e. shop ID.
     */
    'sourceTenantId'?: string;
    /**
     * Order ID in source sales channel.
     */
    'sourceOrderId'?: string;
    /**
     * The order number in source sales channel.
     */
    'sourceOrderNumber'?: string;
    /**
     * The total amount of the order that contains the Gift Card.
     */
    'totalAmount'?: string;
    /**
     * The order\'s currency.
     */
    'currency'?: string;
    /**
     * Note to be added to the order.
     */
    'note'?: string;
    /**
     * The payment status of the order.
     */
    'paymentStatus'?: GiftCardOrder5PaymentStatusEnum;
    /**
     * Fulfillment status of the order in Rise.
     */
    'fulfillmentStatus'?: GiftCardOrder5FulfillmentStatusEnum;
    /**
     * Status of the order in Rise.
     */
    'status'?: GiftCardOrder5StatusEnum;
    'buyerInfo'?: BuyerInfo1;
    /**
     * Date and time to fulfill the order by creating Gift Cards. Default is now.
     */
    'scheduleFulfillAt'?: string;
    /**
     * Date and time the order was fulfilled in Rise by creating Gift Cards.
     */
    'riseFulfilledAt'?: string;
    /**
     * Date and time the order was marked fulfilled in the Source sales channel.
     */
    'sourceFulfilledAt'?: string;
    /**
     * The line items in the order that are Gift Cards.
     */
    'lineItems'?: Array<GiftCardLineItem1>;
    /**
     * The fraud message.
     */
    'fraudMessage'?: string;
    /**
     * The fraud logic type.
     */
    'fraudType'?: GiftCardOrder5FraudTypeEnum;
    /**
     * Location ID in Source.
     */
    'sourceLocationId'?: string;
}

export const GiftCardOrder5PaymentStatusEnum = {
    UnknownPaymentStatus: 'UNKNOWN_PAYMENT_STATUS',
    NotPaid: 'NOT_PAID',
    PartiallyPaid: 'PARTIALLY_PAID',
    Paid: 'PAID',
    Refunded: 'REFUNDED',
    PartiallyRefunded: 'PARTIALLY_REFUNDED',
    Canceled: 'CANCELED'
} as const;

export type GiftCardOrder5PaymentStatusEnum = typeof GiftCardOrder5PaymentStatusEnum[keyof typeof GiftCardOrder5PaymentStatusEnum];
export const GiftCardOrder5FulfillmentStatusEnum = {
    UnknownFulfillmentStatus: 'UNKNOWN_FULFILLMENT_STATUS',
    Pending: 'PENDING',
    Fulfilled: 'FULFILLED',
    InProgress: 'IN_PROGRESS',
    NotFulfilled: 'NOT_FULFILLED',
    Delayed: 'DELAYED'
} as const;

export type GiftCardOrder5FulfillmentStatusEnum = typeof GiftCardOrder5FulfillmentStatusEnum[keyof typeof GiftCardOrder5FulfillmentStatusEnum];
export const GiftCardOrder5StatusEnum = {
    UnknownOrderStatus: 'UNKNOWN_ORDER_STATUS',
    Valid: 'VALID',
    Rejected: 'REJECTED',
    Suspicious: 'SUSPICIOUS'
} as const;

export type GiftCardOrder5StatusEnum = typeof GiftCardOrder5StatusEnum[keyof typeof GiftCardOrder5StatusEnum];
export const GiftCardOrder5FraudTypeEnum = {
    UnknownFraudType: 'UNKNOWN_FRAUD_TYPE',
    None: 'NONE',
    ShopifyIndication: 'SHOPIFY_INDICATION',
    RiseBoughtWithGiftCard: 'RISE_BOUGHT_WITH_GIFT_CARD',
    RiseBoughtWithDiscount: 'RISE_BOUGHT_WITH_DISCOUNT'
} as const;

export type GiftCardOrder5FraudTypeEnum = typeof GiftCardOrder5FraudTypeEnum[keyof typeof GiftCardOrder5FraudTypeEnum];

/**
 * 
 */
export interface GiftCardOrderGiftCardOrderServiceV1RiseOrdersFulfillPostFulfillOrderRequestBody {
    'query': OrderQuery1;
}
/**
 * 
 */
export interface GiftCardOrderGiftCardOrderServiceV1RiseOrdersOrderIdPatchUpdateOrderRequestBody {
    'order': GiftCardOrder5;
}
/**
 * 
 */
export interface GiftCardOrderGiftCardOrderServiceV1RiseOrdersPostCreateOrderRequestBody {
    'order': GiftCardOrder4;
}
/**
 * 
 */
export interface GiftCardOrderGiftCardOrderServiceV1RiseOrdersQueryPostQueryOrdersRequestBody {
    'query'?: PagingMethod;
}
/**
 * 
 */
export interface GiftCardOrderGiftCardOrderServiceV1RiseOrdersStatusPostUpdateOrderStatusRequestBody {
    'query': OrderQuery2;
    /**
     * The new payment status of the order.
     */
    'paymentStatus': GiftCardOrderGiftCardOrderServiceV1RiseOrdersStatusPostUpdateOrderStatusRequestBodyPaymentStatusEnum;
    /**
     * Skip auto fulfillment of the gift card. Default is false.
     */
    'skipAutoFulfillment'?: boolean;
}

export const GiftCardOrderGiftCardOrderServiceV1RiseOrdersStatusPostUpdateOrderStatusRequestBodyPaymentStatusEnum = {
    UnknownPaymentStatus: 'UNKNOWN_PAYMENT_STATUS',
    NotPaid: 'NOT_PAID',
    PartiallyPaid: 'PARTIALLY_PAID',
    Paid: 'PAID',
    Refunded: 'REFUNDED',
    PartiallyRefunded: 'PARTIALLY_REFUNDED',
    Canceled: 'CANCELED'
} as const;

export type GiftCardOrderGiftCardOrderServiceV1RiseOrdersStatusPostUpdateOrderStatusRequestBodyPaymentStatusEnum = typeof GiftCardOrderGiftCardOrderServiceV1RiseOrdersStatusPostUpdateOrderStatusRequestBodyPaymentStatusEnum[keyof typeof GiftCardOrderGiftCardOrderServiceV1RiseOrdersStatusPostUpdateOrderStatusRequestBodyPaymentStatusEnum];

/**
 * @type GiftCardSourceInfo1
 * Information about the source of the gift card.
 */
export type GiftCardSourceInfo1 = BulkOptions | CampaignOptions | ManualOptions | MigrationOptions | OrderOptions | StoreCreditOptions | WorkflowOptions;

/**
 * @type GiftCardSourceInfo2
 * Information about the source of the gift card.
 */
export type GiftCardSourceInfo2 = BulkOptions | CampaignOptions | ManualOptions | MigrationOptions | OrderOptions | StoreCreditOptions | WorkflowOptions;

/**
 * 
 */
export interface GiftCardTransactionInsufficientFunds {
    /**
     * the transaction that failed due to insufficient funds
     */
    'transaction'?: object;
    /**
     * the current balance of the gift card
     */
    'currentBalance'?: string;
}
/**
 * 
 */

export const GiftCardType = {
    Order: 'ORDER',
    Campaign: 'CAMPAIGN',
    Migration: 'MIGRATION',
    StoreCredit: 'STORE_CREDIT',
    Manual: 'MANUAL',
    Workflow: 'WORKFLOW',
    Bulk: 'BULK'
} as const;

export type GiftCardType = typeof GiftCardType[keyof typeof GiftCardType];


/**
 * 
 */
export interface GiftingDetails {
    /**
     * Optional date for when to send the email. Leave it empty for immediate dispatch.
     */
    'sendDate'?: string;
    /**
     * Optional custom text to add to the email.
     */
    'greeting'?: string;
    /**
     * Optional image to add to the email.
     */
    'imageUrl'?: string;
    /**
     * The name of the sender.
     */
    'senderName'?: string;
    /**
     * The email of the sender.
     */
    'senderEmail'?: string;
}
/**
 * Optional gifting details to add to the email.
 */
export interface GiftingDetails1 {
    /**
     * Optional date for when to send the email. Leave it empty for immediate dispatch.
     */
    'sendDate'?: string;
    /**
     * Optional custom text to add to the email.
     */
    'greeting'?: string;
    /**
     * Optional image to add to the email.
     */
    'imageUrl'?: string;
    /**
     * The name of the sender.
     */
    'senderName'?: string;
    /**
     * The email of the sender.
     */
    'senderEmail'?: string;
}
/**
 * Optional Gifting Information for the Gift Card.
 */
export interface GiftingInfo {
    /**
     * First Name of the recipient.
     */
    'recipientFirstName'?: string;
    /**
     * Last Name of the recipient.
     */
    'recipientLastName'?: string;
    /**
     * Email address of the recipient.
     */
    'recipientEmail'?: string;
    /**
     * Date and time the Gift Card is scheduled to be sent. Default is now.
     */
    'sendAt'?: string;
    /**
     * Message to be added to the gift card email.
     */
    'message'?: string;
    /**
     * Media to be added to the gift card email.
     */
    'mediaUrl'?: string;
}
/**
 * The line Item\'s Gifting Information.
 */
export interface GiftingInfo1 {
    /**
     * First Name of the recipient.
     */
    'recipientFirstName'?: string;
    /**
     * Last Name of the recipient.
     */
    'recipientLastName'?: string;
    /**
     * Email address of the recipient.
     */
    'recipientEmail'?: string;
    /**
     * Date and time the Gift Card is scheduled to be sent. Default is now.
     */
    'sendAt'?: string;
    /**
     * Message to be added to the gift card email.
     */
    'message'?: string;
    /**
     * Media to be added to the gift card email.
     */
    'mediaUrl'?: string;
}
export interface GroupByValueResults {
    'groupedByValue'?: GroupByValueResultsGroupedByValue;
}
/**
 * Group by value aggregation results.
 */
export interface GroupByValueResultsGroupedByValue {
    /**
     * List of value aggregations.
     */
    'results'?: Array<NestedValueAggregationResult1>;
}
export interface Helper {
    /**
     * 
     */
    'ifFilter'?: object;
    /**
     * 
     */
    'switchFilter'?: object;
    /**
     * 
     */
    'delay'?: object;
    /**
     * 
     */
    'rateLimiting'?: object;
    /**
     * 
     */
    'conditionFilter'?: object;
    /**
     * 
     */
    'output'?: object;
    /**
     * 
     */
    'setVariables'?: object;
}
export interface INSUFFICIENTFUNDS {
    /**
     * Error message
     */
    'message': string;
    'details': INSUFFICIENTFUNDSDetails;
}
export interface INSUFFICIENTFUNDSDetails {
    'applicationError': INSUFFICIENTFUNDSDetailsApplicationError;
}
export interface INSUFFICIENTFUNDSDetailsApplicationError {
    /**
     * Error code: INSUFFICIENT_FUNDS
     */
    'code': INSUFFICIENTFUNDSDetailsApplicationErrorCodeEnum;
    /**
     * Error description
     */
    'description': string;
    'data'?: object;
}

export const INSUFFICIENTFUNDSDetailsApplicationErrorCodeEnum = {
    InsufficientFunds: 'INSUFFICIENT_FUNDS'
} as const;

export type INSUFFICIENTFUNDSDetailsApplicationErrorCodeEnum = typeof INSUFFICIENTFUNDSDetailsApplicationErrorCodeEnum[keyof typeof INSUFFICIENTFUNDSDetailsApplicationErrorCodeEnum];

export interface INVALIDCODE {
    /**
     * Error message
     */
    'message': string;
    'details': INVALIDCODEDetails;
}
export interface INVALIDCODEDetails {
    'applicationError': INVALIDCODEDetailsApplicationError;
}
export interface INVALIDCODEDetailsApplicationError {
    /**
     * Error code: INVALID_CODE
     */
    'code': INVALIDCODEDetailsApplicationErrorCodeEnum;
    /**
     * Error description
     */
    'description': string;
    'data'?: object;
}

export const INVALIDCODEDetailsApplicationErrorCodeEnum = {
    InvalidCode: 'INVALID_CODE'
} as const;

export type INVALIDCODEDetailsApplicationErrorCodeEnum = typeof INVALIDCODEDetailsApplicationErrorCodeEnum[keyof typeof INVALIDCODEDetailsApplicationErrorCodeEnum];

export interface INVALIDEXPIRATIONDATE {
    /**
     * Error message
     */
    'message': string;
    'details': INVALIDEXPIRATIONDATEDetails;
}
export interface INVALIDEXPIRATIONDATEDetails {
    'applicationError': INVALIDEXPIRATIONDATEDetailsApplicationError;
}
export interface INVALIDEXPIRATIONDATEDetailsApplicationError {
    /**
     * Error code: INVALID_EXPIRATION_DATE
     */
    'code': INVALIDEXPIRATIONDATEDetailsApplicationErrorCodeEnum;
    /**
     * Error description
     */
    'description': string;
    'data'?: object;
}

export const INVALIDEXPIRATIONDATEDetailsApplicationErrorCodeEnum = {
    InvalidExpirationDate: 'INVALID_EXPIRATION_DATE'
} as const;

export type INVALIDEXPIRATIONDATEDetailsApplicationErrorCodeEnum = typeof INVALIDEXPIRATIONDATEDetailsApplicationErrorCodeEnum[keyof typeof INVALIDEXPIRATIONDATEDetailsApplicationErrorCodeEnum];

export interface INVALIDGIFTCARDBALANCE {
    /**
     * Error message
     */
    'message': string;
    'details': INVALIDGIFTCARDBALANCEDetails;
}
export interface INVALIDGIFTCARDBALANCEDetails {
    'applicationError': INVALIDGIFTCARDBALANCEDetailsApplicationError;
}
export interface INVALIDGIFTCARDBALANCEDetailsApplicationError {
    /**
     * Error code: INVALID_GIFT_CARD_BALANCE
     */
    'code': INVALIDGIFTCARDBALANCEDetailsApplicationErrorCodeEnum;
    /**
     * Error description
     */
    'description': string;
    'data'?: object;
}

export const INVALIDGIFTCARDBALANCEDetailsApplicationErrorCodeEnum = {
    InvalidGiftCardBalance: 'INVALID_GIFT_CARD_BALANCE'
} as const;

export type INVALIDGIFTCARDBALANCEDetailsApplicationErrorCodeEnum = typeof INVALIDGIFTCARDBALANCEDetailsApplicationErrorCodeEnum[keyof typeof INVALIDGIFTCARDBALANCEDetailsApplicationErrorCodeEnum];

/**
 * Order ID.
 */
export interface Id {
    /**
     * Order ID.
     */
    'id'?: string;
}
/**
 * 
 */
export interface Idempotency {
    /**
     * A unique identifier for the event. If you send the same idempotency key in multiple report event requests, for the same trigger key and app id, consecutive requests will be ignored after the first one. Note that the idempotency key is kept for a week before it expires.
     */
    'key'?: string;
    /**
     * Optional. The time to live (TTL) in milliseconds before the key will expire. Default is a week.
     */
    'ttlInMilliseconds'?: string;
}
/**
 * Idempotency information for the event.
 */
export interface Idempotency1 {
    /**
     * A unique identifier for the event. If you send the same idempotency key in multiple report event requests, for the same trigger key and app id, consecutive requests will be ignored after the first one. Note that the idempotency key is kept for a week before it expires.
     */
    'key'?: string;
    /**
     * Optional. The time to live (TTL) in milliseconds before the key will expire. Default is a week.
     */
    'ttlInMilliseconds'?: string;
}
/**
 * 
 */
export interface IdempotencyKeyDetails {
    /**
     * Gift Card Id
     */
    'giftCardId'?: string;
    /**
     * Idempotency Key
     */
    'idempotencyKey'?: string;
}
export interface Identifier {
    /**
     * a preinstalled automation identifier
     */
    'preinstalledIdentifier'?: object;
    /**
     * a automation of any type identifier that will be available in future
     */
    'automationIdentifier'?: object;
}
/**
 * 
 */

export const IdentifierType = {
    Preinstalled: 'PREINSTALLED'
} as const;

export type IdentifierType = typeof IdentifierType[keyof typeof IdentifierType];


/**
 * 
 */
export interface Identity {
    /**
     * User ID
     */
    'userId'?: string;
    /**
     * App ID
     */
    'appId'?: string;
}
/**
 * 
 */
export interface IfFilter {
    /**
     * If filter\'s condition.
     */
    'condition'?: string;
    /**
     * If\'s true post actions.
     */
    'truePostActions'?: Array<object>;
    /**
     * If\'s false post actions.
     */
    'falsePostActions'?: Array<object>;
    /**
     * If\'s true post actions ids.
     */
    'truePostActionsIds'?: Array<string>;
    /**
     * If\'s false post actions ids.
     */
    'falsePostActionsIds'?: Array<string>;
}
/**
 * 
 */
export interface IncludeMissingValuesOptions {
    /**
     * Specify a custom name for the bucket containing the missing values. Defaults are `\"N/A\"` for strings, `0` for integers, and `false` for booleans.
     */
    'addToBucket'?: string;
}
/**
 * @type IncreaseBalance428Response
 */
export type IncreaseBalance428Response = EXISTINGIDEMPOTENCYKEY | INVALIDGIFTCARDBALANCE;

/**
 * 
 */
export interface IncreaseBalanceResponse {
    /**
     * The created Transaction.
     */
    'transaction'?: object;
    /**
     * GiftCard balance after transaction.
     */
    'balance'?: string;
    /**
     * Transaction Currency.
     */
    'currency'?: string;
}
/**
 * 
 */
export interface IncreaseBalanceResponse1 {
    'transaction'?: Transaction2;
    /**
     * GiftCard balance after transaction.
     */
    'balance'?: string;
    /**
     * Transaction Currency.
     */
    'currency'?: string;
}
export interface Info {
    /**
     * App defined action info
     */
    'appDefinedInfo'?: object;
}
export interface InitialOptions {
    'initialOptions'?: InitialOptionsInitialOptions;
}
/**
 * Information about the first transaction that initializes a gift card.
 */
export interface InitialOptionsInitialOptions {
    /**
     * Type of the gift card being initialized.
     */
    'giftCardType'?: InitialOptionsInitialOptionsGiftCardTypeEnum;
}

export const InitialOptionsInitialOptionsGiftCardTypeEnum = {
    Order: 'ORDER',
    Campaign: 'CAMPAIGN',
    Migration: 'MIGRATION',
    StoreCredit: 'STORE_CREDIT',
    Manual: 'MANUAL',
    Workflow: 'WORKFLOW',
    Bulk: 'BULK'
} as const;

export type InitialOptionsInitialOptionsGiftCardTypeEnum = typeof InitialOptionsInitialOptionsGiftCardTypeEnum[keyof typeof InitialOptionsInitialOptionsGiftCardTypeEnum];

/**
 * 
 */
export interface InitiatedStatusInfo {
    /**
     * Activation target
     */
    'target'?: string;
    /**
     * Event payload
     */
    'payload'?: object;
    /**
     * External entity ID
     */
    'externalEntityId'?: string;
    /**
     * Unique identifier for the request that initiated the automation
     */
    'requestId'?: string;
}
/**
 * 
 */

export const InitiatorType = {
    App: 'APP',
    User: 'USER'
} as const;

export type InitiatorType = typeof InitiatorType[keyof typeof InitiatorType];


/**
 * 
 */
export interface InsufficientFundsDetails {
    /**
     * Gift Card Id
     */
    'giftCardId'?: string;
    /**
     * Gift Card Balance
     */
    'balance'?: string;
    /**
     * Transaction amount
     */
    'amount'?: string;
}
/**
 * 
 */
export interface Int32Value {
    /**
     * 
     */
    'value'?: number;
}
/**
 * 
 */

export const Interval = {
    Year: 'YEAR',
    Month: 'MONTH',
    Week: 'WEEK',
    Day: 'DAY',
    Hour: 'HOUR',
    Minute: 'MINUTE',
    Second: 'SECOND'
} as const;

export type Interval = typeof Interval[keyof typeof Interval];


/**
 * 
 */
export interface InvalidCodeDetails {
    /**
     * Gift Card Code
     */
    'code'?: string;
}
/**
 * 
 */
export interface InvalidExpirationDateDetails {
    /**
     * Expiration Date
     */
    'expirationDate'?: string;
}
/**
 * 
 */
export interface InvalidGiftCardBalanceDetails {
    /**
     * Gift Card Id
     */
    'giftCardId'?: string;
    /**
     * Current Gift Card balance
     */
    'currentBalance'?: string;
    /**
     * Max balance allowed
     */
    'maxBalance'?: string;
    /**
     * Attempted invalid balance
     */
    'invalidBalance'?: string;
}
/**
 * 
 */
export interface ItemMetadata {
    /**
     * Item ID. Should always be available, unless it\'s impossible (for example, when failing to create an item).
     */
    'id'?: string;
    /**
     * Index of the item within the request array. Allows for correlation between request and response items.
     */
    'originalIndex'?: number;
    /**
     * Whether the requested action was successful for this item. When `false`, the `error` field is populated.
     */
    'success'?: boolean;
    /**
     * Details about the error in case of failure.
     */
    'error'?: object;
}
export interface Kind {
    'value'?: KindValue;
}
export interface KindValue {
    'includeOptions'?: KindValueIncludeOptions;
}
/**
 * Options for including missing values in results.
 */
export interface KindValueIncludeOptions {
    /**
     * Specify a custom name for the bucket containing the missing values. Defaults are `\"N/A\"` for strings, `0` for integers, and `false` for booleans.
     */
    'addToBucket'?: string;
}
export interface ListValue {
    'listValue'?: ListValueListValue;
}
/**
 * 
 */
export interface ListValueListValue {
    /**
     * 
     */
    'values'?: Array<object>;
}
export interface ManualOptions {
    'manualOptions'?: ManualOptionsManualOptions;
}
/**
 * Information about a transaction issued manually from the Rise dashboard.
 */
export interface ManualOptionsManualOptions {
    /**
     * Internal note about the Transaction/Gift Card.
     */
    'note'?: string;
}
/**
 * 
 */
export interface MessageEnvelope {
    /**
     * App instance ID.
     */
    'instanceId'?: string;
    /**
     * Event type.
     */
    'eventType'?: string;
    /**
     * The identification type and identity data.
     */
    'identity'?: object;
    /**
     * Stringify payload.
     */
    'data'?: string;
}
/**
 * 
 */
export interface MigrateWalletRequest {
    /**
     * Customer reference
     */
    'customerReference'?: object;
    /**
     * gift card id
     */
    'giftCard'?: object;
    /**
     * tenant id
     */
    'tenantId'?: string;
    /**
     * channel id
     */
    'channelId'?: string;
}
/**
 * 
 */
export interface MigrateWalletResponse {
    /**
     * wallet
     */
    'wallet'?: object;
    /**
     * giftCard
     */
    'giftCard'?: object;
}
export interface MigrationOptions {
    'migrationOptions'?: MigrationOptionsMigrationOptions;
}
/**
 * Information about a transaction whose source is a migration from Rise V1 or another platform.
 */
export interface MigrationOptionsMigrationOptions {
    /**
     * ID of the gift card or transaction in Rise V1.
     */
    'previousId'?: string;
    /**
     * Indicates whether the gift card or transaction is a liability.
     */
    'liability'?: boolean;
    /**
     * Note about the gift card or transaction being migrated.
     */
    'note'?: string;
}
/**
 * 
 */

export const MissingValues = {
    Exclude: 'EXCLUDE',
    Include: 'INCLUDE'
} as const;

export type MissingValues = typeof MissingValues[keyof typeof MissingValues];


/**
 * 
 */

export const Mode = {
    Or: 'OR',
    And: 'AND'
} as const;

export type Mode = typeof Mode[keyof typeof Mode];


/**
 * Extended field data. Each key corresponds to the namespace of the app that created the extended fields. The value of each key is structured according to the schema defined when the extended fields were configured.  You can only access fields for which you have the appropriate permissions.  Learn more about [extended fields](https://dev.wix.com/docs/rest/articles/getting-started/extended-fields).
 */
export interface Namespaces {
    'key'?: string;
    'value'?: object;
}
/**
 * Nested aggregation expressed through a list of aggregation where each next aggregation is nested within previous one.
 */
export interface NestedAggregation {
    /**
     * Flattened list of aggregations, where each aggregation is nested within previous one.
     */
    'nestedAggregations'?: Array<object>;
}
/**
 * @type NestedAggregationResults1
 * Nested aggregations.
 */
export type NestedAggregationResults1 = NestedAggregationResults1OneOf | NestedAggregationResults1OneOf1 | NestedAggregationResults1OneOf2 | NestedAggregationResults1OneOf3 | NestedAggregationResults1OneOf4 | NestedAggregationResults1OneOf5;

export interface NestedAggregationResults1OneOf {
    'values'?: ValueResultsValues;
}
export interface NestedAggregationResults1OneOf1 {
    'ranges'?: RangeResultsRanges;
}
export interface NestedAggregationResults1OneOf2 {
    'scalar'?: NestedAggregationResults1OneOf2Scalar;
}
/**
 * Scalar aggregation results.
 */
export interface NestedAggregationResults1OneOf2Scalar {
    /**
     * Value of the scalar aggregation.
     */
    'value'?: number;
}
export interface NestedAggregationResults1OneOf3 {
    /**
     * Circular reference to #/components/schemas/wix.common.AggregationData.AggregationResults.GroupByValueResults (simplified)
     */
    'groupedByValue'?: object;
}
export interface NestedAggregationResults1OneOf4 {
    'dateHistogram'?: NestedAggregationResults1OneOf4DateHistogram;
}
/**
 * Date histogram aggregation results.
 */
export interface NestedAggregationResults1OneOf4DateHistogram {
    /**
     * List of date histogram aggregations.
     */
    'results'?: Array<DateHistogramResult>;
}
export interface NestedAggregationResults1OneOf5 {
    'nested'?: NestedAggregationResults1OneOf5Nested;
}
/**
 * Nested aggregation results.
 */
export interface NestedAggregationResults1OneOf5Nested {
    /**
     * List of nested aggregations.
     */
    'results'?: Array<Results1>;
}
/**
 * 
 */

export const NestedAggregationType = {
    Value: 'VALUE',
    Range: 'RANGE',
    Scalar: 'SCALAR',
    DateHistogram: 'DATE_HISTOGRAM'
} as const;

export type NestedAggregationType = typeof NestedAggregationType[keyof typeof NestedAggregationType];


/**
 * @type NestedResultValue1
 * 
 */
export type NestedResultValue1 = NestedAggregationResults1OneOf | NestedAggregationResults1OneOf1 | NestedAggregationResults1OneOf2 | NestedAggregationResults1OneOf3 | NestedAggregationResults1OneOf4 | NestedResultValue1OneOf;

export interface NestedResultValue1OneOf {
    /**
     * Circular reference to #/components/schemas/wix.common.AggregationData.AggregationResults.NestedResults (simplified)
     */
    'nested'?: object;
}
export interface NestedResults {
    'nested'?: NestedAggregationResults1OneOf5Nested;
}
/**
 * 
 */
export interface NestedValueAggregationResult {
    /**
     * Value of the field.
     */
    'value'?: string;
    /**
     * Nested aggregations.
     */
    'nestedResults'?: object;
}
/**
 * 
 */
export interface NestedValueAggregationResult1 {
    /**
     * Value of the field.
     */
    'value'?: string;
    'nestedResults'?: NestedAggregationResults1;
}
/**
 * Settings for the notifications related to the WalletAction.
 */
export interface Notifications {
    /**
     * Settings for email notifications related to the WalletAction. This field is used to specify whether to skip email dispatch or override the template ID for email notifications.
     */
    'emailParams'?: object;
}
/**
 * Settings of the notifications related to the WalletAction. This field is used to specify whether to skip email dispatch or override the template ID for email notifications.
 */
export interface Notifications1 {
    'emailParams'?: EmailParams1;
}
/**
 * 
 */
export interface NullValue {
    /**
     * 
     */
    'nullValue'?: NullValueNullValueEnum;
}

export const NullValueNullValueEnum = {
    NullValue: 'NULL_VALUE'
} as const;

export type NullValueNullValueEnum = typeof NullValueNullValueEnum[keyof typeof NullValueNullValueEnum];

/**
 * 
 */
export interface NumberValue {
    /**
     * 
     */
    'numberValue'?: number;
}
/**
 * The endpoint accepts raw HTTP requests. You must pass the request\\\'s body parameters formatted as bytes in the raw HTTP request\\\'s `body` field, following this template: `{\"grantType\": \"client_credentials\", \"client_id\": \"<appId>\", \"client_secret\": \"<appSecretKey>\", \"instance_id\": \"<instanceId>\"}`. The access token is valid for 4 hours.
 */
export interface OAuthOauth2TokenPostSomeOperationRequestBody {
    /**
     * Request type. You must pass `\"client_credentials\"` to request a new access token when using basic OAuth.
     */
    'grant_type'?: string;
    /**
     * Your app ID
     */
    'client_id'?: string;
    /**
     * Your app\'s secret key ID
     */
    'client_secret'?: string;
    /**
     * The instance ID of your app for which you want to create the access token. Instance id represents a unique installation of your app on a specific Rise account. 
     */
    'instance_id'?: string;
}
export interface Of {
    /**
     * 
     */
    'runtime'?: object;
    /**
     * 
     */
    'scheduler'?: object;
    /**
     * 
     */
    'asyncAction'?: object;
}
/**
 * 
 */

export const OperationType = {
    Add: 'ADD',
    Subtract: 'SUBTRACT'
} as const;

export type OperationType = typeof OperationType[keyof typeof OperationType];


/**
 * 
 */

export const Operator = {
    Or: 'OR',
    And: 'AND'
} as const;

export type Operator = typeof Operator[keyof typeof Operator];


export interface Options {
    /**
     * Options for including missing values in results.
     */
    'includeOptions'?: object;
}
export interface OrderOptions {
    'orderOptions'?: OrderOptionsOrderOptions;
}
/**
 * Detailed information about a Gift Card issued from an order.
 */
export interface OrderOptionsOrderOptions {
    /**
     * ID of the gift card order.
     */
    'orderId'?: string;
    /**
     * Indicates whether the gift card order is a liability.
     */
    'liability'?: boolean;
    /**
     * Order number of the gift card order.
     */
    'orderNumber'?: string;
}
/**
 * @type OrderQuery1
 * Order ID or Source Identifiers of the Order to fulfill.
 */
export type OrderQuery1 = Id | OrderSourceInfo;

/**
 * @type OrderQuery2
 * Order ID or Source Identifiers of the Order whose status is to be updated.
 */
export type OrderQuery2 = Id | OrderSourceInfo;

export interface OrderSourceInfo {
    'sourceInfo'?: OrderSourceInfoSourceInfo;
}
/**
 * Source Identifiers.
 */
export interface OrderSourceInfoSourceInfo {
    /**
     * Source channel, i.e. Shopify.
     */
    'sourceChannelId'?: string;
    /**
     * Tenant ID in Source, i.e. shop ID.
     */
    'sourceTenantId'?: string;
    /**
     * Order ID in Source.
     */
    'sourceOrderId'?: string;
}
/**
 * 
 */

export const OrderStatus = {
    UnknownOrderStatus: 'UNKNOWN_ORDER_STATUS',
    Valid: 'VALID',
    Rejected: 'REJECTED',
    Suspicious: 'SUSPICIOUS'
} as const;

export type OrderStatus = typeof OrderStatus[keyof typeof OrderStatus];


/**
 * 
 */

export const Origin = {
    User: 'USER',
    Application: 'APPLICATION',
    Preinstalled: 'PREINSTALLED',
    Recipe: 'RECIPE'
} as const;

export type Origin = typeof Origin[keyof typeof Origin];


export interface OriginInfo {
    /**
     * Application info
     */
    'applicationInfo'?: object;
    /**
     * Preinstalled info
     */
    'preinstalledInfo'?: object;
}
/**
 * 
 */
export interface Output {
    /**
     * The jsonata to use to produce the output
     */
    'outputMapping'?: string;
}
/**
 * 
 */
export interface OutputAction {
    /**
     * Output action output mapping.
     */
    'outputMapping'?: object;
}
export interface Paging {
    'paging'?: PagingPaging;
}
/**
 * 
 */
export interface PagingMetadataV2 {
    /**
     * Number of items returned in the response.
     */
    'count'?: number;
    /**
     * Offset that was requested.
     */
    'offset'?: number;
    /**
     * Total number of items that match the query. Returned if offset paging is used and the `tooManyToCount` flag is not set.
     */
    'total'?: number;
    /**
     * Flag that indicates the server failed to calculate the `total` field.
     */
    'tooManyToCount'?: boolean;
    /**
     * Cursors to navigate through the result pages using `next` and `prev`. Returned if cursor paging is used.
     */
    'cursors'?: object;
}
/**
 * 
 */
export interface PagingMetadataV21 {
    /**
     * Number of items returned in the response.
     */
    'count'?: number;
    /**
     * Offset that was requested.
     */
    'offset'?: number;
    /**
     * Total number of items that match the query. Returned if offset paging is used and the `tooManyToCount` flag is not set.
     */
    'total'?: number;
    /**
     * Flag that indicates the server failed to calculate the `total` field.
     */
    'tooManyToCount'?: boolean;
    'cursors'?: Cursors2;
}
/**
 * 
 */
export interface PagingMetadataV22 {
    /**
     * Number of items returned in the response.
     */
    'count'?: number;
    /**
     * Offset that was requested.
     */
    'offset'?: number;
    /**
     * Total number of items that match the query. Returned if offset paging is used and the `tooManyToCount` flag is not set.
     */
    'total'?: number;
    /**
     * Flag that indicates the server failed to calculate the `total` field.
     */
    'tooManyToCount'?: boolean;
    'cursors'?: Cursors3;
}
/**
 * Response paging metadata.
 */
export interface PagingMetadataV23 {
    /**
     * Number of items returned in the response.
     */
    'count'?: number;
    /**
     * Offset that was requested.
     */
    'offset'?: number;
    /**
     * Total number of items that match the query. Returned if offset paging is used and the `tooManyToCount` flag is not set.
     */
    'total'?: number;
    /**
     * Flag that indicates the server failed to calculate the `total` field.
     */
    'tooManyToCount'?: boolean;
    'cursors'?: Cursors2;
}
/**
 * Paging metadata.
 */
export interface PagingMetadataV24 {
    /**
     * Number of items returned in the response.
     */
    'count'?: number;
    /**
     * Offset that was requested.
     */
    'offset'?: number;
    /**
     * Total number of items that match the query. Returned if offset paging is used and the `tooManyToCount` flag is not set.
     */
    'total'?: number;
    /**
     * Flag that indicates the server failed to calculate the `total` field.
     */
    'tooManyToCount'?: boolean;
    'cursors'?: Cursors3;
}
export interface PagingMethod {
    'cursorPaging'?: PagingMethodCursorPaging;
}
/**
 * Cursor token pointing to a page of results. Not used in the first request. Following requests use the cursor token and not `filter` or `sort`.
 */
export interface PagingMethodCursorPaging {
    /**
     * Number of items to load.
     */
    'limit'?: number;
    /**
     * Pointer to the next or previous page in the list of results.  You can get the relevant cursor token from the `pagingMetadata` object in the previous call\'s response. Not relevant for the first request.
     */
    'cursor'?: string;
}
/**
 * Paging options to limit and skip the number of items.
 */
export interface PagingPaging {
    /**
     * Number of items to load.
     */
    'limit'?: number;
    /**
     * Number of items to skip in the current sort order.
     */
    'offset'?: number;
}
/**
 * Path definition
 */
export interface Path {
    /**
     * Unique ID for this path
     */
    'id'?: string;
    /**
     * Path name for display purposes
     */
    'name'?: string;
    /**
     * ID of the action to execute when this path is taken
     */
    'postActionId'?: string;
}
export interface PaymentMethodRefundOptions {
    'paymentMethodRefundOptions'?: PaymentMethodRefundOptionsPaymentMethodRefundOptions;
}
/**
 * Information about a transaction whose source is a refunding a payment method.
 */
export interface PaymentMethodRefundOptionsPaymentMethodRefundOptions {
    /**
     * ID of the order associated with the refund.
     */
    'orderId'?: string;
    /**
     * Indicates whether the payment method refund is a liability.
     */
    'liability'?: boolean;
    /**
     * Order number associated with the refund.
     */
    'orderNumber'?: string;
    'activeFundingTransaction'?: PaymentMethodRefundWalletActionDetails1;
}
/**
 * 
 */
export interface PaymentMethodRefundWalletActionDetails {
    /**
     * 
     */
    'walletActionId'?: string;
    /**
     * 
     */
    'fundingTransactionId'?: string;
}
/**
 * Optional details for the refund that is based of a specific store credit.
 */
export interface PaymentMethodRefundWalletActionDetails1 {
    /**
     * 
     */
    'walletActionId'?: string;
    /**
     * 
     */
    'fundingTransactionId'?: string;
}
/**
 * 
 */

export const PaymentStatus = {
    UnknownPaymentStatus: 'UNKNOWN_PAYMENT_STATUS',
    NotPaid: 'NOT_PAID',
    PartiallyPaid: 'PARTIALLY_PAID',
    Paid: 'PAID',
    Refunded: 'REFUNDED',
    PartiallyRefunded: 'PARTIALLY_REFUNDED',
    Canceled: 'CANCELED'
} as const;

export type PaymentStatus = typeof PaymentStatus[keyof typeof PaymentStatus];


/**
 * 
 */
export interface PreinstalledIdentifier {
    /**
     * identifier for the application of the preinstalled
     */
    'appId'?: string;
    /**
     * application component id
     */
    'componentId'?: string;
}
/**
 * 
 */
export interface PreinstalledOrigin {
    /**
     * ID of the app that defines the preinstalled automation.
     */
    'appId'?: string;
    /**
     * Application component ID.
     */
    'componentId'?: string;
    /**
     * Application component version.
     */
    'componentVersion'?: number;
    /**
     * Whether the automation is an override automation. If the user modifies the preinstalled automation installed on their site, a site-specific automation is created that overrides the original one. If the user makes no modifications this boolean is set to `false` and the original preinstalled automation is used.  Default: `false`
     */
    'override'?: boolean;
}
/**
 * 
 */
export interface QueryByContact {
    /**
     * Contact filter object.
     */
    'filter'?: object;
    /**
     * Sort object.
     */
    'sort'?: Array<object>;
    /**
     * Limit for the number of wallets to return.
     */
    'limit'?: number;
}
/**
 * Contact query object.
 */
export interface QueryByContact1 {
    'filter'?: Filter4;
    /**
     * Sort object.
     */
    'sort'?: Array<Sorting2>;
    /**
     * Limit for the number of wallets to return.
     */
    'limit'?: number;
}
/**
 * 
 */
export interface QueryGiftCardsResponse {
    /**
     * The retrieved GiftCards.
     */
    'giftCards'?: Array<object>;
    /**
     * Response paging metadata.
     */
    'pagingMetadata'?: object;
}
/**
 * 
 */
export interface QueryGiftCardsResponse1 {
    /**
     * The retrieved GiftCards.
     */
    'giftCards'?: Array<GiftCard5>;
    'pagingMetadata'?: PagingMetadataV23;
}
/**
 * 
 */
export interface QueryOrdersRequest {
    /**
     * API Query Language expression.
     */
    'query'?: object;
}
/**
 * 
 */
export interface QueryOrdersResponse {
    /**
     * List of the retrieved Orders.
     */
    'orders'?: Array<object>;
    /**
     * Paging metadata
     */
    'pagingMetadata'?: object;
}
/**
 * 
 */
export interface QueryOrdersResponse1 {
    /**
     * List of the retrieved Orders.
     */
    'orders'?: Array<GiftCardOrder3>;
    'pagingMetadata'?: CursorPagingMetadata3;
}
/**
 * 
 */
export interface QueryRecipientsRequest {
    /**
     * API Query Language expression.
     */
    'query'?: object;
}
/**
 * 
 */
export interface QueryRecipientsResponse {
    /**
     * List of Recipients.
     */
    'recipients'?: Array<object>;
    /**
     * Paging metadata
     */
    'pagingMetadata'?: object;
}
/**
 * 
 */
export interface QueryRecipientsResponse1 {
    /**
     * List of Recipients.
     */
    'recipients'?: Array<Recipient3>;
    'pagingMetadata'?: CursorPagingMetadata1;
}
/**
 * 
 */
export interface QueryTransactionsRequest {
    /**
     * WQL expression.
     */
    'query'?: object;
}
/**
 * 
 */
export interface QueryTransactionsResponse {
    /**
     * The retrieved Transactions.
     */
    'transactions'?: Array<object>;
    /**
     * 
     */
    'pagingMetadata'?: object;
}
/**
 * 
 */
export interface QueryTransactionsResponse1 {
    /**
     * The retrieved Transactions.
     */
    'transactions'?: Array<Transaction1>;
    'pagingMetadata'?: PagingMetadataV21;
}
/**
 * 
 */
export interface QueryUnredeemedWalletActionsResponse {
    /**
     * The retrieved unredeemed WalletActions with their balances.
     */
    'walletActions'?: Array<WalletActionWithBalance1>;
    'pagingMetadata'?: PagingMetadataV22;
}
/**
 * @type QueryV21
 * WQL expression.
 */
export type QueryV21 = CursorPaging | Paging;

/**
 * @type QueryV22
 * API Query Language expression.
 */
export type QueryV22 = CursorPaging | Paging;

/**
 * 
 */
export interface QueryWalletActionBalancesResponse {
    /**
     * The retrieved WalletActions with their balances.
     */
    'walletActions'?: Array<object>;
    /**
     * 
     */
    'pagingMetadata'?: object;
}
/**
 * 
 */
export interface QueryWalletActionBalancesResponse1 {
    /**
     * The retrieved WalletActions with their balances.
     */
    'walletActions'?: Array<WalletActionWithBalance1>;
    'pagingMetadata'?: PagingMetadataV22;
}
/**
 * 
 */
export interface QueryWalletActionRequest {
    /**
     * API Query Language expression.
     */
    'query'?: object;
}
/**
 * 
 */
export interface QueryWalletActionResponse {
    /**
     * The retrieved WalletActions.
     */
    'walletActions'?: Array<object>;
    /**
     * 
     */
    'pagingMetadata'?: object;
}
/**
 * 
 */
export interface QueryWalletActionResponse1 {
    /**
     * The retrieved WalletActions.
     */
    'walletActions'?: Array<WalletAction4>;
    'pagingMetadata'?: PagingMetadataV22;
}
/**
 * 
 */
export interface QueryWalletsByContactRequest {
    /**
     * Contact query object.
     */
    'query'?: object;
}
/**
 * 
 */
export interface QueryWalletsByContactResponse {
    /**
     * List of retrieved wallets with gift card information.
     */
    'wallets'?: Array<object>;
}
/**
 * 
 */
export interface QueryWalletsByContactResponse1 {
    /**
     * List of retrieved wallets with gift card information.
     */
    'wallets'?: Array<Wallet5>;
}
/**
 * 
 */
export interface QueryWalletsRequest {
    /**
     * API Query Language expression.
     */
    'query'?: object;
}
/**
 * 
 */
export interface QueryWalletsResponse {
    /**
     * List of retrieved wallets with gift card information.
     */
    'wallets'?: Array<object>;
    /**
     * Paging metadata.
     */
    'pagingMetadata'?: object;
}
/**
 * 
 */
export interface QueryWalletsResponse1 {
    /**
     * List of retrieved wallets with gift card information.
     */
    'wallets'?: Array<Wallet5>;
    'pagingMetadata'?: PagingMetadataV24;
}
export interface REQUIREDPROPERTY {
    /**
     * Error message
     */
    'message': string;
    'details': REQUIREDPROPERTYDetails;
}
export interface REQUIREDPROPERTYDetails {
    'applicationError': REQUIREDPROPERTYDetailsApplicationError;
}
export interface REQUIREDPROPERTYDetailsApplicationError {
    /**
     * Error code: REQUIRED_PROPERTY
     */
    'code': REQUIREDPROPERTYDetailsApplicationErrorCodeEnum;
    /**
     * Error description
     */
    'description': string;
    /**
     * Error specific data
     */
    'data'?: object;
}

export const REQUIREDPROPERTYDetailsApplicationErrorCodeEnum = {
    RequiredProperty: 'REQUIRED_PROPERTY'
} as const;

export type REQUIREDPROPERTYDetailsApplicationErrorCodeEnum = typeof REQUIREDPROPERTYDetailsApplicationErrorCodeEnum[keyof typeof REQUIREDPROPERTYDetailsApplicationErrorCodeEnum];

/**
 * 
 */
export interface RangeAggregation {
    /**
     * List of range buckets. During aggregation each entity is placed in the first bucket its value falls into, based on the provided range bounds.
     */
    'buckets'?: Array<object>;
}
/**
 * 
 */
export interface RangeAggregationResult {
    /**
     * Inclusive lower bound of the range.
     */
    'from'?: number;
    /**
     * Exclusive upper bound of the range
     */
    'to'?: number;
    /**
     * Total number of entities in this range.
     */
    'count'?: number;
}
/**
 * 
 */
export interface RangeAggregationResult1 {
    /**
     * Inclusive lower bound of the range.
     */
    'from'?: number;
    /**
     * Exclusive upper bound of the range.
     */
    'to'?: number;
    /**
     * Total number of entities in this range.
     */
    'count'?: number;
}
/**
 * 
 */
export interface RangeBucket {
    /**
     * Inclusive lower bound of the range. Required if `to` is not provided.
     */
    'from'?: number;
    /**
     * Exclusive upper bound of the range. Required if `from` is not provided.
     */
    'to'?: number;
}
/**
 * 
 */
export interface RangeResult {
    /**
     * Inclusive lower bound of the range.
     */
    'from'?: number;
    /**
     * Exclusive upper bound of the range.
     */
    'to'?: number;
    /**
     * Number of entities in this range.
     */
    'count'?: number;
}
export interface RangeResults {
    'ranges'?: RangeResultsRanges;
}
/**
 * Range aggregation results.
 */
export interface RangeResultsRanges {
    /**
     * List of ranges returned in the same order as requested.
     */
    'results'?: Array<RangeAggregationResult1>;
}
/**
 * 
 */
export interface RateLimit {
    /**
     * Value expressing the maximum number of times the trigger can be activated.
     */
    'maxActivationsExpression'?: string;
    /**
     * Duration of the rate limiting window in the selected time unit. If no value is set, the rate limit is permanent.
     */
    'durationExpression'?: string;
    /**
     * Time unit for the rate limit duration.
     */
    'durationTimeUnit'?: string;
    /**
     * Unique identifier of each activation, by which rate limiter will count activations.
     */
    'uniqueIdentifierExpression'?: string;
}
/**
 * 
 */
export interface RateLimitAction {
    /**
     * The maximum number of activations allowed for the action.
     */
    'maxActivationsExpression'?: string;
    /**
     * Duration of the rate limiting window, expressed in selected time unit. If no value is set, then there is no time limit on the rate limiter.
     */
    'rateLimitDurationExpression'?: string;
    /**
     * Time unit for the rate limit duration.
     */
    'rateLimitDurationTimeUnit'?: string;
    /**
     * Unique identifier of each activation by which rate limiter counts activations.
     */
    'uniqueIdentifierExpression'?: string;
    /**
     * List of IDs of actions to run in parallel once the action completes.
     */
    'postActionIds'?: Array<string>;
}
/**
 * 
 */
export interface RateLimitActionInfo {
    /**
     * Indicates if the rate limiter passed (not reached the quota)
     */
    'passed'?: boolean;
}
/**
 * 
 */
export interface RateLimiting {
    /**
     * The maximum number of activations allowed in the given time frame
     */
    'maxNumOfActivations'?: number;
    /**
     * Optional, used if provided: A jsonata expression that evaluates to the maximum number of activations allowed in the given time frame
     */
    'maxNumOfActivationsExpression'?: string;
    /**
     * If given - the time frame in minutes, otherwise, for life
     */
    'timeFrameInMinutes'?: number;
    /**
     * Optional, used if provided - A jsonata expression that evaluates to the time frame in minutes, otherwise, for life
     */
    'timeFrameInMinutesExpression'?: string;
    /**
     * The jsonata to use to extract the entity/resource key from the enriched event payload
     */
    'keyJsonata'?: string;
    /**
     * The actions to perform if this rate limiting action succeeded - meaning we are still in the allowed number of activations in the given time frame
     */
    'postActions'?: Array<object>;
    /**
     * The ids of actions to perform if this rate limiting action succeeded - meaning we are still in the allowed number of activations in the given time frame
     */
    'postActionsIds'?: Array<string>;
}
/**
 * The Recipient entity contains the information about the recipient of a gift card, such as name, email, gifting details, and the created gift card.
 */
export interface Recipient {
    /**
     * Recipient ID.
     */
    'id'?: string;
    /**
     * Revision number, which increments by 1 each time the Recipient is updated. To prevent conflicting changes, the current revision must be passed when updating the Recipient.  Ignored when creating a Recipient.
     */
    'revision'?: string;
    /**
     * Date and time the Recipient was created.
     */
    'createdDate'?: string;
    /**
     * Date and time the Recipient was last updated.
     */
    'updatedDate'?: string;
    /**
     * The name of the recipient.
     */
    'name'?: string;
    /**
     * The email of the recipient.
     */
    'email'?: string;
    /**
     * The ID of the gift card that was sent to the recipient.
     */
    'giftCardId'?: string;
    /**
     * Optional gifting details to add to the email.
     */
    'giftingDetails'?: object;
}
/**
 * The created Recipient.
 */
export interface Recipient1 {
    /**
     * Recipient ID.
     */
    'id'?: string;
    /**
     * Revision number, which increments by 1 each time the Recipient is updated. To prevent conflicting changes, the current revision must be passed when updating the Recipient.  Ignored when creating a Recipient.
     */
    'revision'?: string;
    /**
     * Date and time the Recipient was created.
     */
    'createdDate'?: string;
    /**
     * Date and time the Recipient was last updated.
     */
    'updatedDate'?: string;
    /**
     * The name of the recipient.
     */
    'name'?: string;
    /**
     * The email of the recipient.
     */
    'email'?: string;
    /**
     * The ID of the gift card that was sent to the recipient.
     */
    'giftCardId'?: string;
    'giftingDetails'?: GiftingDetails1;
}
/**
 * The requested Recipient.
 */
export interface Recipient2 {
    /**
     * Recipient ID.
     */
    'id'?: string;
    /**
     * Revision number, which increments by 1 each time the Recipient is updated. To prevent conflicting changes, the current revision must be passed when updating the Recipient.  Ignored when creating a Recipient.
     */
    'revision'?: string;
    /**
     * Date and time the Recipient was created.
     */
    'createdDate'?: string;
    /**
     * Date and time the Recipient was last updated.
     */
    'updatedDate'?: string;
    /**
     * The name of the recipient.
     */
    'name'?: string;
    /**
     * The email of the recipient.
     */
    'email'?: string;
    /**
     * The ID of the gift card that was sent to the recipient.
     */
    'giftCardId'?: string;
    'giftingDetails'?: GiftingDetails1;
}
/**
 * The Recipient entity contains the information about the recipient of a gift card, such as name, email, gifting details, and the created gift card.
 */
export interface Recipient3 {
    /**
     * Recipient ID.
     */
    'id'?: string;
    /**
     * Revision number, which increments by 1 each time the Recipient is updated. To prevent conflicting changes, the current revision must be passed when updating the Recipient.  Ignored when creating a Recipient.
     */
    'revision'?: string;
    /**
     * Date and time the Recipient was created.
     */
    'createdDate'?: string;
    /**
     * Date and time the Recipient was last updated.
     */
    'updatedDate'?: string;
    /**
     * The name of the recipient.
     */
    'name'?: string;
    /**
     * The email of the recipient.
     */
    'email'?: string;
    /**
     * The ID of the gift card that was sent to the recipient.
     */
    'giftCardId'?: string;
    'giftingDetails'?: GiftingDetails1;
}
/**
 * Recipient to be created.
 */
export interface Recipient4 {
    /**
     * Recipient ID.
     */
    'id'?: string;
    /**
     * Revision number, which increments by 1 each time the Recipient is updated. To prevent conflicting changes, the current revision must be passed when updating the Recipient.  Ignored when creating a Recipient.
     */
    'revision'?: string;
    /**
     * Date and time the Recipient was created.
     */
    'createdDate'?: string;
    /**
     * Date and time the Recipient was last updated.
     */
    'updatedDate'?: string;
    /**
     * The name of the recipient.
     */
    'name': string;
    /**
     * The email of the recipient.
     */
    'email': string;
    /**
     * The ID of the gift card that was sent to the recipient.
     */
    'giftCardId': string;
    'giftingDetails'?: GiftingDetails1;
}
/**
 * 
 */
export interface RecipientGiftCardRecipientServiceV1RiseRecipientsPostCreateRecipientRequestBody {
    'recipient': Recipient4;
    'sideEffects'?: SideEffects2;
}
/**
 * 
 */
export interface RecipientGiftCardRecipientServiceV1RiseRecipientsQueryPostQueryRecipientsRequestBody {
    'query'?: PagingMethod;
}
export interface RedeemOptions {
    'redeemOptions'?: RedeemOptionsRedeemOptions;
}
/**
 * Information about a transaction whose source is a gift card redemption.
 */
export interface RedeemOptionsRedeemOptions {
    /**
     * ID of the order associated with the redemption.
     */
    'orderId'?: string;
    /**
     * Indicates whether the redemption is a liability.
     */
    'liability'?: boolean;
    /**
     * Total price of the order.
     */
    'totalPrice'?: string;
    /**
     * Order number associated with the redemption.
     */
    'orderNumber'?: string;
}
/**
 * 
 */
export interface RefreshPayloadRequest {
    /**
     * Application definition ID.
     */
    'appDefId'?: string;
    /**
     * Trigger key.
     */
    'triggerKey'?: string;
    /**
     * Payload to refresh.
     */
    'payload'?: object;
    /**
     * External entity ID.
     */
    'externalEntityId'?: string;
}
/**
 * 
 */
export interface RefreshPayloadResponse {
    /**
     * Updated payload.
     */
    'payload'?: object;
    /**
     * If the automation activation should be canceled (default is false)
     */
    'cancelActivation'?: boolean;
}
/**
 * Once a user has completed the installation process and given your app permission to access their data, use the authorization code we sent you, together with your secret key, to request an access token and a refresh token. (The access token is only valid for 5 minutes.) You can find your secret key in the Wix Developers Center.
 */
export interface RefreshTokenResponse {
    /**
     * Your app instance’s refresh token that never expires. Identical to the one that you’ve sent in the request.
     */
    'refresh_token'?: string;
    /**
     * Created access token that you can use to make Wix API calls. It expires after 5 minutes.
     */
    'access_token'?: string;
}
/**
 * 
 */
export interface RefundTransactionContext {
    /**
     * 
     */
    'sourceTenantId'?: string;
    /**
     * 
     */
    'sourceChannelId'?: string;
    /**
     * 
     */
    'sourceLocationId'?: string;
    /**
     * 
     */
    'sourceOrderId'?: string;
    /**
     * 
     */
    'sourceOrderNumber'?: string;
}
/**
 * 
 */
export interface RefundTransactionRequest {
    /**
     * 
     */
    'transactionId'?: string;
    /**
     * Optional custom amount to refund. If not provided, the full amount of the transaction will be refunded.
     */
    'amount'?: string;
    /**
     * 
     */
    'context'?: object;
}
/**
 * 
 */
export interface RefundableAmount {
    /**
     * 
     */
    'walletActionId'?: string;
    /**
     * 
     */
    'amount'?: string;
    /**
     * 
     */
    'fundingTransactionId'?: string;
}
/**
 * 
 */
export interface RefundableAmount1 {
    /**
     * 
     */
    'walletActionId'?: string;
    /**
     * 
     */
    'amount'?: string;
    /**
     * 
     */
    'fundingTransactionId'?: string;
}
export interface RelativeExpiresAt {
    'relative'?: RelativeExpiresAtRelative;
}
/**
 * Relative Expiration period
 */
export interface RelativeExpiresAtRelative {
    /**
     * Number of time units until expiration
     */
    'value'?: number;
    /**
     * Units of time for expiration
     */
    'period'?: RelativeExpiresAtRelativePeriodEnum;
}

export const RelativeExpiresAtRelativePeriodEnum = {
    Unknown: 'UNKNOWN',
    Days: 'DAYS',
    Weeks: 'WEEKS',
    Months: 'MONTHS',
    Years: 'YEARS'
} as const;

export type RelativeExpiresAtRelativePeriodEnum = typeof RelativeExpiresAtRelativePeriodEnum[keyof typeof RelativeExpiresAtRelativePeriodEnum];

/**
 * 
 */
export interface ReportDomainEventRequest {
    /**
     * trigger app id
     */
    'triggerAppId'?: string;
    /**
     * report event request
     */
    'reportEventRequest'?: object;
}
/**
 * 
 */
export interface ReportEventRequest {
    /**
     * Trigger key as defined in your app\'s trigger configuration. For example, `order_returned` or `order_paid`..
     */
    'triggerKey'?: string;
    /**
     * Event payload, formatted as key:value pairs. Must comply with the payload schema if you provided one when configuring your trigger.  Key names can include only alphanumeric characters or underscores (`A-Z`, `a-z`, `0-9`, `_`). They cannot start with an underscore.  Values can be strings, numbers, integers, booleans, or arrays. If a value is an array, the array items must be objects, and nested object properties must be strings, numbers, integers, or booleans only.
     */
    'payload'?: object;
    /**
     * ID of the related resource in GUID format. For example, `fc81a355-3429-50fc-a4c7-def486e828f3`.  Required if your app needs to [cancel the event](https://dev.wix.com/docs/rest/business-management/automations/triggered-events/cancel-event) if the automation becomes no longer relevant.  Typically, this ID is defined in your system, but you can also use any resource GUID, such as contact ID, member ID, or invoice ID. See [Choose the right `externalEntityId`](https://dev.wix.com/docs/rest/business-management/automations/triggered-events/reporting-and-canceling-events#about-canceling-events) for more information.
     */
    'externalEntityId'?: string;
    /**
     * Idempotency information for the event.
     */
    'idempotency'?: object;
}
/**
 * 
 */
export interface ReportEventResponse {
    /**
     * The activation IDs of triggered ReportEvents.
     */
    'activationIds'?: Array<string>;
}
/**
 * 
 */
export interface ReportEventResponse1 {
    /**
     * The activation IDs of triggered ReportEvents.
     */
    'activationIds'?: Array<string>;
}
/**
 * 
 */

export const RequestedFields = {
    ContactDetails: 'CONTACT_DETAILS'
} as const;

export type RequestedFields = typeof RequestedFields[keyof typeof RequestedFields];


/**
 * 
 */
export interface RestoreInfo {
    /**
     * 
     */
    'deletedDate'?: string;
}
export interface Result {
    /**
     * Value aggregation results.
     */
    'values'?: object;
    /**
     * Range aggregation results.
     */
    'ranges'?: object;
    /**
     * Scalar aggregation results.
     */
    'scalar'?: object;
    /**
     * Group by value aggregation results.
     */
    'groupedByValue'?: object;
    /**
     * Date histogram aggregation results.
     */
    'dateHistogram'?: object;
    /**
     * Nested aggregation results.
     */
    'nested'?: object;
}
/**
 * List of nested aggregations.
 */
export interface Results {
    'key'?: string;
    'value'?: object;
}
/**
 * 
 */
export interface Results1 {
    'results'?: Results1;
}
export interface RewardOptions {
    /**
     * @deprecated
     */
    'rewardOptions'?: RewardOptionsRewardOptions;
}
/**
 * Reward Options. (**Deprecated**: Use `wallet_action_start_options` instead.)
 */
export interface RewardOptionsRewardOptions {
    /**
     * 
     */
    'walletActionId'?: string;
    /**
     * 
     */
    'liability'?: boolean;
}
/**
 * 
 */
export interface RunAutomationRequest {
    /**
     * App of the automation trigger
     */
    'appId'?: string;
    /**
     * Trigger key of the action
     */
    'triggerKey'?: string;
    /**
     * Payload of the triggered event
     */
    'triggerPayload'?: object;
    /**
     * Specific automation id to run
     */
    'automationId'?: string;
    /**
     * Schema of the trigger
     */
    'triggerSchema'?: object;
    /**
     * Skip retry mechanism. If set to true, we will not retry the automations actions in case of a retryable error.
     */
    'skipRetry'?: boolean;
}
/**
 * 
 */
export interface RunAutomationResponse {
    /**
     * Automation activation output payload
     */
    'output'?: object;
}
export interface SCHEMAVALIDATIONFAILED {
    /**
     * Error message
     */
    'message': string;
    'details': SCHEMAVALIDATIONFAILEDDetails;
}
export interface SCHEMAVALIDATIONFAILEDDetails {
    'applicationError': SCHEMAVALIDATIONFAILEDDetailsApplicationError;
}
export interface SCHEMAVALIDATIONFAILEDDetailsApplicationError {
    /**
     * Error code: SCHEMA_VALIDATION_FAILED
     */
    'code': SCHEMAVALIDATIONFAILEDDetailsApplicationErrorCodeEnum;
    /**
     * Error description
     */
    'description': string;
    /**
     * Error specific data
     */
    'data'?: object;
}

export const SCHEMAVALIDATIONFAILEDDetailsApplicationErrorCodeEnum = {
    SchemaValidationFailed: 'SCHEMA_VALIDATION_FAILED'
} as const;

export type SCHEMAVALIDATIONFAILEDDetailsApplicationErrorCodeEnum = typeof SCHEMAVALIDATIONFAILEDDetailsApplicationErrorCodeEnum[keyof typeof SCHEMAVALIDATIONFAILEDDetailsApplicationErrorCodeEnum];

export interface STARTDATEINTHEPAST {
    /**
     * Error message
     */
    'message': string;
    'details': STARTDATEINTHEPASTDetails;
}
export interface STARTDATEINTHEPASTDetails {
    'applicationError': STARTDATEINTHEPASTDetailsApplicationError;
}
export interface STARTDATEINTHEPASTDetailsApplicationError {
    /**
     * Error code: START_DATE_IN_THE_PAST
     */
    'code': STARTDATEINTHEPASTDetailsApplicationErrorCodeEnum;
    /**
     * Error description
     */
    'description': string;
    'data'?: object;
}

export const STARTDATEINTHEPASTDetailsApplicationErrorCodeEnum = {
    StartDateInThePast: 'START_DATE_IN_THE_PAST'
} as const;

export type STARTDATEINTHEPASTDetailsApplicationErrorCodeEnum = typeof STARTDATEINTHEPASTDetailsApplicationErrorCodeEnum[keyof typeof STARTDATEINTHEPASTDetailsApplicationErrorCodeEnum];

export interface STARTLATERTHANEXPIRATION {
    /**
     * Error message
     */
    'message': string;
    'details': STARTLATERTHANEXPIRATIONDetails;
}
export interface STARTLATERTHANEXPIRATIONDetails {
    'applicationError': STARTLATERTHANEXPIRATIONDetailsApplicationError;
}
export interface STARTLATERTHANEXPIRATIONDetailsApplicationError {
    /**
     * Error code: START_LATER_THAN_EXPIRATION
     */
    'code': STARTLATERTHANEXPIRATIONDetailsApplicationErrorCodeEnum;
    /**
     * Error description
     */
    'description': string;
    'data'?: object;
}

export const STARTLATERTHANEXPIRATIONDetailsApplicationErrorCodeEnum = {
    StartLaterThanExpiration: 'START_LATER_THAN_EXPIRATION'
} as const;

export type STARTLATERTHANEXPIRATIONDetailsApplicationErrorCodeEnum = typeof STARTLATERTHANEXPIRATIONDetailsApplicationErrorCodeEnum[keyof typeof STARTLATERTHANEXPIRATIONDetailsApplicationErrorCodeEnum];

/**
 * 
 */
export interface ScalarAggregation {
    /**
     * Operator type for the scalar aggregation.
     */
    'type'?: string;
}
export interface ScalarResult {
    'scalar'?: NestedAggregationResults1OneOf2Scalar;
}
/**
 * 
 */

export const ScalarType = {
    CountDistinct: 'COUNT_DISTINCT',
    Min: 'MIN',
    Max: 'MAX'
} as const;

export type ScalarType = typeof ScalarType[keyof typeof ScalarType];


/**
 * 
 */
export interface Schedule {
    /**
     * 
     */
    'id'?: string;
    /**
     * doesn\'t have to be unique. example: triggerName+entityId
     */
    'identifier'?: string;
    /**
     * 
     */
    'configurationCorrelationId'?: string;
    /**
     * 
     */
    'activationId'?: string;
    /**
     * 
     */
    'scheduledAction'?: object;
    /**
     * Raw domain event, not enriched
     */
    'eventPayload'?: string;
    /**
     * 
     */
    'scheduleStatus'?: string;
    /**
     * 
     */
    'scheduleDate'?: string;
    /**
     * 
     */
    'createdDate'?: string;
    /**
     * 
     */
    'updatedDate'?: string;
    /**
     * 
     */
    'overrideable'?: boolean;
    /**
     * 
     */
    'triggerInfo'?: object;
    /**
     * 
     */
    'automation'?: object;
}
/**
 * 
 */
export interface ScheduleActivationRequested {
    /**
     * Activation identifier
     */
    'id'?: string;
    /**
     * Optional - external entity id that this activation is related to
     */
    'externalEntityId'?: string;
    /**
     * Activation payload
     */
    'payload'?: object;
    /**
     * Activation Automation
     */
    'automation'?: object;
    /**
     * Activation schedule date
     */
    'scheduleDate'?: string;
}
/**
 * 
 */
export interface ScheduleRequest {
    /**
     * 
     */
    'schedule'?: object;
}
/**
 * 
 */
export interface ScheduleResponse {
    /**
     * 
     */
    'id'?: string;
}
/**
 * 
 */

export const ScheduleStatus = {
    UnknownScheduleStatus: 'UNKNOWN_SCHEDULE_STATUS',
    Pending: 'PENDING',
    Cancelled: 'CANCELLED',
    Done: 'DONE'
} as const;

export type ScheduleStatus = typeof ScheduleStatus[keyof typeof ScheduleStatus];


/**
 * 
 */
export interface ScheduledAction {
    /**
     * Action\'s id.
     */
    'id'?: string;
    /**
     * decide how long we should wait
     */
    'delay'?: object;
}
/**
 * 
 */
export interface ScheduledStatusInfo {
    /**
     * Schedule identifier
     */
    'scheduleId'?: string;
    /**
     * Indicates when the activation should start
     */
    'date'?: string;
}
/**
 * 
 */
export interface Scheduler {
    /**
     * 
     */
    'scheduleId'?: string;
}
/**
 * 
 */
export interface SearchDetails {
    /**
     * Search mode. Defines the search logic for combining multiple terms in the `expression`.
     */
    'mode'?: string;
    /**
     * Search term or expression.
     */
    'expression'?: string;
    /**
     * Fields to search in. If the array is empty, all searchable fields are searched. Use dot notation to specify a JSON path. For example, `order.address.streetName`.
     */
    'fields'?: Array<string>;
    /**
     * Whether to enable the search function to use an algorithm to automatically find results that are close to the search expression, such as typos and declensions.
     */
    'fuzzy'?: boolean;
}
/**
 * 
 */
export interface SearchGiftCardsRequest {
    /**
     * 
     */
    'search'?: object;
}
/**
 * 
 */
export interface SearchGiftCardsResponse {
    /**
     * Gift Cards which satisfy the provided query.
     */
    'giftCards'?: Array<object>;
    /**
     * Paging metadata. Contains cursor which can be used in next query.
     */
    'pagingMetadata'?: object;
    /**
     * Aggregation data.
     */
    'aggregationData'?: object;
}
/**
 * 
 */
export interface SearchGiftCardsResponse1 {
    /**
     * Gift Cards which satisfy the provided query.
     */
    'giftCards'?: Array<GiftCard5>;
    'pagingMetadata'?: CursorPagingMetadata2;
    'aggregationData'?: AggregationData1;
}
/**
 * 
 */
export interface Service {
    /**
     * Action\'s service mapping.
     */
    'serviceMapping'?: object;
    /**
     * Action\'s input mapping. Jsonata description of the input this service gets.
     */
    'inputMapping'?: string;
    /**
     * Action\'s output mapping. Jsonata description of the output this service returns.
     */
    'outputMapping'?: string;
    /**
     * Action\'s post actions.
     */
    'postActions'?: Array<object>;
    /**
     * Action\'s post actions ids.
     */
    'postActionsIds'?: Array<string>;
    /**
     * The namespace of the action
     */
    'namespace'?: string;
}
/**
 * 
 */
export interface ServiceMapping {
    /**
     * Sevice name.
     */
    'name'?: string;
    /**
     * Method name.
     */
    'method'?: string;
}
/**
 * 
 */
export interface SetVariables {
    /**
     * Action\'s output mapping. Jsonata expressions to set variables for example: { \"var1\": \"$average([10,20])\", \"var2\": \"$number($lookup($, $decodeUrlComponent(\\\"var1\\\"))) >= $number(8)\"\" }
     */
    'outputMapping'?: string;
    /**
     * Action\'s post actions.
     */
    'postActions'?: Array<object>;
    /**
     * Action\'s post actions ids.
     */
    'postActionsIds'?: Array<string>;
    /**
     * The namespace of the action
     */
    'namespace'?: string;
    /**
     * Json Schema for the output mapping
     */
    'outputSchema'?: object;
}
/**
 * 
 */
export interface SetVariablesAction {
    /**
     * output mapping for example: {\"someField\": \"{{10}}\", \"someOtherField\": \"{{multiply( var(\'account.points.balance\') ;2 )}}\" }
     */
    'outputMapping'?: object;
    /**
     * output json schema representation could be string instead of Struct (and introduce some compression to minimize the size of it)
     */
    'outputSchema'?: object;
    /**
     * List of IDs of actions to run in parallel after variable initialization.
     */
    'postActionIds'?: Array<string>;
}
/**
 * Side effects for the gift card creation flow.
 */
export interface SideEffects {
    /**
     * Whether to skip sending notifications such as emails.
     */
    'skipNotifications'?: boolean;
}
/**
 * Side effect for the gift card creation flow.
 */
export interface SideEffects1 {
    /**
     * Whether to skip sending notifications such as emails.
     */
    'skipNotifications'?: boolean;
}
/**
 * Optional information about some side effects regarding the creation of the Recipient.
 */
export interface SideEffects2 {
    /**
     * Whether to skip sending notifications for this recipient.
     */
    'skipNotifications'?: boolean;
}
/**
 * 
 */
export interface SimpleDelay {
    /**
     * 
     */
    'value'?: number;
    /**
     * 
     */
    'units'?: string;
    /**
     * Optional, used if provided: Jsonata expression that evaluates to a number of milliseconds to wait
     */
    'delayExpression'?: string;
}
/**
 * 
 */

export const SkipReason = {
    ScheduleDateExpired: 'SCHEDULE_DATE_EXPIRED',
    TriggerFiltersNotPassed: 'TRIGGER_FILTERS_NOT_PASSED',
    RateLimitExceeded: 'RATE_LIMIT_EXCEEDED',
    EventAlreadyProcessed: 'EVENT_ALREADY_PROCESSED'
} as const;

export type SkipReason = typeof SkipReason[keyof typeof SkipReason];


/**
 * 
 */
export interface SkippedStatusInfo {
    /**
     * The reason why the automation activation was skipped
     */
    'reason'?: string;
    /**
     * Event payload
     */
    'payload'?: object;
    /**
     * External entity ID
     */
    'externalEntityId'?: string;
    /**
     * Unique identifier for the request that initiated the automation
     */
    'requestId'?: string;
}
/**
 * 
 */

export const SortDirection = {
    Desc: 'DESC',
    Asc: 'ASC'
} as const;

export type SortDirection = typeof SortDirection[keyof typeof SortDirection];


/**
 * 
 */

export const SortOrder = {
    Asc: 'ASC',
    Desc: 'DESC'
} as const;

export type SortOrder = typeof SortOrder[keyof typeof SortOrder];


/**
 * 
 */

export const SortType = {
    Count: 'COUNT',
    Value: 'VALUE'
} as const;

export type SortType = typeof SortType[keyof typeof SortType];


/**
 * 
 */
export interface Sorting {
    /**
     * Name of the field to sort by.
     */
    'fieldName'?: string;
    /**
     * Sort order.
     */
    'order'?: string;
}
/**
 * 
 */
export interface Sorting1 {
    /**
     * Name of the field to sort by.
     */
    'fieldName'?: string;
    /**
     * Sort order.
     */
    'order'?: Sorting1OrderEnum;
}

export const Sorting1OrderEnum = {
    Asc: 'ASC',
    Desc: 'DESC'
} as const;

export type Sorting1OrderEnum = typeof Sorting1OrderEnum[keyof typeof Sorting1OrderEnum];

/**
 * 
 */
export interface Sorting2 {
    /**
     * Name of the field to sort by.
     */
    'fieldName'?: string;
    /**
     * Sort order.
     */
    'order'?: Sorting2OrderEnum;
}

export const Sorting2OrderEnum = {
    Asc: 'ASC',
    Desc: 'DESC'
} as const;

export type Sorting2OrderEnum = typeof Sorting2OrderEnum[keyof typeof Sorting2OrderEnum];

/**
 * 
 */
export interface Source {
    /**
     * Source channel, i.e. Shopify.
     */
    'sourceChannelId'?: string;
    /**
     * Tenant ID in Source, i.e. shop ID.
     */
    'sourceTenantId'?: string;
    /**
     * Customer ID in Source.
     */
    'sourceCustomerId'?: string;
}
/**
 * 
 */
export interface SpiAction {
    /**
     * The App Def Id of the action provider
     */
    'appDefId'?: string;
    /**
     * Identifier for this action - human readable action key - unique per app def id
     */
    'actionKey'?: string;
    /**
     * The configuration of the user for this action, can include params that are taken from the trigger event payload
     */
    'userActionConfig'?: string;
    /**
     * The post action to execute after this action
     */
    'postActions'?: Array<object>;
    /**
     * The output configuration of the user for this action, can include params that are taken from the trigger event payload
     */
    'userOutputActionConfig'?: string;
    /**
     * optional skip condition expression for current action decides whether to skip the action before executing it\'s post actions
     */
    'skipConditionExpression'?: string;
    /**
     * Action\'s post actions ids.
     */
    'postActionsIds'?: Array<string>;
    /**
     * The namespace of the action
     */
    'namespace'?: string;
}
/**
 * 
 */
export interface SplitAction {
    /**
     * List of paths to split execution into
     */
    'paths'?: Array<object>;
}
/**
 * 
 */

export const Status = {
    Started: 'STARTED',
    InvokedAsync: 'INVOKED_ASYNC',
    Ended: 'ENDED',
    Skipped: 'SKIPPED',
    Failed: 'FAILED'
} as const;

export type Status = typeof Status[keyof typeof Status];


export interface StatusInfo {
    /**
     * Action output data as defined in your action [output schema](https://dev.wix.com/docs/rest/business-management/automations/actions/about-actions#the-output-schema).
     */
    'successInfo'?: object;
    /**
     * Information about the action\'s failure to complete.
     */
    'failureInfo'?: object;
}
/**
 * 
 */
export interface StoreCreditContext {
    /**
     * The issuer type of the store credit (e.g., workflow, bulk, manual)
     */
    'issuer'?: string;
    /**
     * Indicates a specific instance of the issuer (relevant for workflow/bulk)
     */
    'issuerId'?: string;
    /**
     * An internal note associated with the store credit
     */
    'note'?: string;
    /**
     * The Channel ID of the sales channel that is associated with the store credit (e.g. Shopify channel id)
     */
    'sourceChannelId'?: string;
    /**
     * The Tenant ID of the sales channel that is associated with the store credit (e.g. Shopify shop id)
     */
    'sourceTenantId'?: string;
}
/**
 * Detailed information about the context of a store credit, such as the issuer type and sales channel.
 */
export interface StoreCreditContext1 {
    /**
     * The issuer type of the store credit (e.g., workflow, bulk, manual)
     */
    'issuer'?: StoreCreditContext1IssuerEnum;
    /**
     * Indicates a specific instance of the issuer (relevant for workflow/bulk)
     */
    'issuerId'?: string;
    /**
     * An internal note associated with the store credit
     */
    'note'?: string;
    /**
     * The Channel ID of the sales channel that is associated with the store credit (e.g. Shopify channel id)
     */
    'sourceChannelId'?: string;
    /**
     * The Tenant ID of the sales channel that is associated with the store credit (e.g. Shopify shop id)
     */
    'sourceTenantId'?: string;
}

export const StoreCreditContext1IssuerEnum = {
    Workflow: 'WORKFLOW',
    Bulk: 'BULK',
    Manual: 'MANUAL',
    Other: 'OTHER',
    Refund: 'REFUND',
    ReferralReferredCustomer: 'REFERRAL_REFERRED_CUSTOMER',
    ReferralReferrer: 'REFERRAL_REFERRER'
} as const;

export type StoreCreditContext1IssuerEnum = typeof StoreCreditContext1IssuerEnum[keyof typeof StoreCreditContext1IssuerEnum];

/**
 * Detailed information about the context of a store credit, such as the issuer type and sales channel.
 */
export interface StoreCreditContext2 {
    /**
     * The issuer type of the store credit (e.g., workflow, bulk, manual)
     */
    'issuer'?: StoreCreditContext2IssuerEnum;
    /**
     * Indicates a specific instance of the issuer (relevant for workflow/bulk)
     */
    'issuerId'?: string;
    /**
     * An internal note associated with the store credit
     */
    'note'?: string;
    /**
     * The Channel ID of the sales channel that is associated with the store credit (e.g. Shopify channel id)
     */
    'sourceChannelId'?: string;
    /**
     * The Tenant ID of the sales channel that is associated with the store credit (e.g. Shopify shop id)
     */
    'sourceTenantId'?: string;
}

export const StoreCreditContext2IssuerEnum = {
    Workflow: 'WORKFLOW',
    Bulk: 'BULK',
    Manual: 'MANUAL',
    Other: 'OTHER',
    Refund: 'REFUND',
    ReferralReferredCustomer: 'REFERRAL_REFERRED_CUSTOMER',
    ReferralReferrer: 'REFERRAL_REFERRER'
} as const;

export type StoreCreditContext2IssuerEnum = typeof StoreCreditContext2IssuerEnum[keyof typeof StoreCreditContext2IssuerEnum];

/**
 * 
 */

export const StoreCreditIssuerType = {
    Workflow: 'WORKFLOW',
    Bulk: 'BULK',
    Manual: 'MANUAL',
    Other: 'OTHER',
    Refund: 'REFUND',
    ReferralReferredCustomer: 'REFERRAL_REFERRED_CUSTOMER',
    ReferralReferrer: 'REFERRAL_REFERRER'
} as const;

export type StoreCreditIssuerType = typeof StoreCreditIssuerType[keyof typeof StoreCreditIssuerType];


export interface StoreCreditOptions {
    'storeCreditOptions'?: StoreCreditOptionsStoreCreditOptions;
}
/**
 * Detailed information about a Gift Card that belongs to a Store Credit Wallet.
 */
export interface StoreCreditOptionsStoreCreditOptions {
    /**
     * ID of the store credit wallet.
     */
    'walletId'?: string;
}
export interface StoreCreditRefundOptions {
    /**
     * @deprecated
     */
    'storeCreditRefundOptions'?: StoreCreditRefundOptionsStoreCreditRefundOptions;
}
/**
 * Information about a transaction whose source is a store credit refund. (**Deprecated**: Use `wallet_action_start_options` instead.)
 */
export interface StoreCreditRefundOptionsStoreCreditRefundOptions {
    /**
     * ID of the wallet action (store credit) given as a refund.
     */
    'walletActionId'?: string;
    /**
     * Indicates whether the store credit refund is a liability.
     */
    'liability'?: boolean;
}
/**
 * 
 */
export interface StringValue {
    /**
     * 
     */
    'stringValue'?: string;
}
/**
 * 
 */
export interface Struct {
    'fields'?: Fields;
}
export interface StructValue {
    /**
     * Circular reference to #/components/schemas/google.protobuf.Struct (simplified)
     */
    'structValue'?: object;
}
/**
 * 
 */

export const SubjectType = {
    App: 'APP',
    User: 'USER',
    Member: 'MEMBER',
    Visitor: 'VISITOR',
    Unknown: 'UNKNOWN'
} as const;

export type SubjectType = typeof SubjectType[keyof typeof SubjectType];


/**
 * 
 */
export interface SuccessInfo {
    /**
     * Result object that correlates to the output schema.
     */
    'result'?: object;
}
/**
 * 
 */
export interface SwitchFilter {
    /**
     * Switch\'s filter cases.
     */
    'cases'?: Array<object>;
}
/**
 * 
 */
export interface TagList {
    /**
     * List of tag IDs.
     */
    'tagIds'?: Array<string>;
}
/**
 * Common object for tags. Should be use as in this example: message Foo { option (.wix.api.decomposite_of) = \"wix.commons.v2.tags.Foo\"; string id = 1; ... Tags tags = 5 }  example of taggable entity { id: \"123\" tags: { public_tags: { tag_ids:[\"11\",\"22\"] }, private_tags: { tag_ids: [\"33\", \"44\"] } } }
 */
export interface Tags {
    /**
     * Tags that require an additional permission in order to access them, typically restricted from site members and visitors.
     */
    'privateTags'?: object;
    /**
     * Tags that are exposed to anyone with access to the entity, including site members and visitors.
     */
    'publicTags'?: object;
}
/**
 * 
 */
export interface TagsModified {
    /**
     * 
     */
    'walletAction'?: object;
    /**
     * Tags that were assigned to the Diff.
     */
    'assignedTags'?: object;
    /**
     * Tags that were unassigned to the Diff.
     */
    'unassignedTags'?: object;
}
/**
 * 
 */

export const Target = {
    Schedule: 'SCHEDULE',
    Immediate: 'IMMEDIATE'
} as const;

export type Target = typeof Target[keyof typeof Target];


/**
 * 
 */

export const TimePeriod = {
    Unknown: 'UNKNOWN',
    Days: 'DAYS',
    Weeks: 'WEEKS',
    Months: 'MONTHS',
    Years: 'YEARS'
} as const;

export type TimePeriod = typeof TimePeriod[keyof typeof TimePeriod];


/**
 * 
 */

export const TimeUnit = {
    Minutes: 'MINUTES',
    Hours: 'HOURS',
    Days: 'DAYS',
    Weeks: 'WEEKS',
    Months: 'MONTHS'
} as const;

export type TimeUnit = typeof TimeUnit[keyof typeof TimeUnit];


/**
 * 
 */
export interface Timestamp {
    /**
     * 
     */
    'seconds'?: string;
    /**
     * 
     */
    'nanos'?: number;
}
/**
 * 
 */
export interface TokenInfoResponse {
    /**
     * Whether the token is active.
     */
    'active'?: boolean;
    /**
     * Type of subject to which the token is issued.
     */
    'subject_type'?: string;
    /**
     * ID of the subject to which the token is issued.
     */
    'subject_id'?: string;
    /**
     * Token expiration timestamp.
     */
    'exp'?: number;
    /**
     * Token issue timestamp.
     */
    'iat'?: number;
    /**
     * ID of the app that [created](https://dev.wix.com/docs/rest/app-management/oauth-2/create-access-token) the token, as defined in the [Wix Dev Center](https://dev.wix.com).
     */
    'client_id'?: number;
    /**
     * ID of the account that [created](https://dev.wix.com/docs/rest/app-management/oauth-2/create-access-token) the token, as defined in the [Wix Dev Center](https://dev.wix.com/apps/my-apps).
     */
    'account_id'?: number;
    /**
     * ID of the site to which the token is issued.
     */
    'site_id'?: number;
    /**
     * The [instance ID](https://dev.wix.com/docs/rest/app-management/app-instance/introduction) of the app that the access token was created for. Subscribe to the [Instance App Installed](https://dev.wix.com/docs/rest/app-management/app-instance/app-instance-installed) webhook to receive a notification including the new app instance ID whenever a version of your app is installed on a Wix site.
     */
    'instance_id'?: number;
}
/**
 * @type Transaction1
 * Transaction is the secondary entity of GiftCardService that indicate an action that modifies the balance of a gift card.
 */
export type Transaction1 = BulkOptions | CampaignOptions | InitialOptions | ManualOptions | MigrationOptions | PaymentMethodRefundOptions | RedeemOptions | RewardOptions | StoreCreditRefundOptions | VoidOptions | WalletActionEndOptions | WalletActionStartOptions;

/**
 * @type Transaction2
 * The created Transaction.
 */
export type Transaction2 = BulkOptions | CampaignOptions | InitialOptions | ManualOptions | MigrationOptions | PaymentMethodRefundOptions | RedeemOptions | RewardOptions | StoreCreditRefundOptions | VoidOptions | WalletActionEndOptions | WalletActionStartOptions;

/**
 * @type Transaction3
 * The Transaction to be created.
 */
export type Transaction3 = BulkOptions | CampaignOptions | InitialOptions | ManualOptions | MigrationOptions | PaymentMethodRefundOptions | RedeemOptions | RewardOptions | StoreCreditRefundOptions | VoidOptions | WalletActionEndOptions | WalletActionStartOptions;

/**
 * 
 */
export interface TransactionAdded {
    /**
     * 
     */
    'transaction'?: object;
}
/**
 * 
 */
export interface TransactionDetails {
    /**
     * The last transaction that modified the gift card balance.
     */
    'lastTransaction'?: object;
    /**
     * The last transaction that decreased the gift card balance, such as redemption or refund.
     */
    'lastDecreasingTransaction'?: object;
    /**
     * ID of the last transaction that increased the gift card balance.
     */
    'lastIncreasingTransaction'?: object;
}
/**
 * Transaction details related to the gift card.
 */
export interface TransactionDetails1 {
    'lastTransaction'?: TransactionWrapper1;
    'lastDecreasingTransaction'?: TransactionWrapper2;
    'lastIncreasingTransaction'?: TransactionWrapper3;
}
export interface TransactionOptions {
    /**
     * Information about a transaction whose source is a gift card redemption.
     */
    'redeemOptions'?: object;
    /**
     * Information about a transaction that comes to void a previous transaction.
     */
    'voidOptions'?: object;
    /**
     * Reward Options.
     */
    'rewardOptions'?: object;
    /**
     * Information about a transaction whose source is the end of a wallet action (store credit).
     */
    'walletActionEndOptions'?: object;
    /**
     * Bulk Options.
     */
    'campaignOptions'?: object;
    /**
     * Information about a transaction whose source is a store credit refund.
     */
    'storeCreditRefundOptions'?: object;
    /**
     * Information about a transaction whose source is a migration from Rise V1 or another platform.
     */
    'migrationOptions'?: object;
    /**
     * Information about a transaction whose source is a refunding a payment method.
     */
    'paymentMethodRefundOptions'?: object;
    /**
     * Information about the first transaction that initializes a gift card.
     */
    'initialOptions'?: object;
    /**
     * Information about a transaction whose source is a wallet action (store credit) to a customer.
     */
    'walletActionStartOptions'?: object;
    /**
     * Bulk Options.
     */
    'bulkOptions'?: object;
    /**
     * Information about a transaction issued manually from the Rise dashboard.
     */
    'manualOptions'?: object;
}
/**
 * 
 */
export interface TransactionSourceInfo {
    /**
     * Details of the API client creating this Transaction.
     */
    'initiator'?: object;
    /**
     * The Tenant ID that is associated with the action.
     */
    'sourceTenantId'?: string;
    /**
     * The Channel ID that is associated with the action.
     */
    'sourceChannelId'?: string;
    /**
     * The location ID that is associated with the action (supports POS cases).
     */
    'sourceLocationId'?: string;
}
/**
 * Information about the source of the transaction.
 */
export interface TransactionSourceInfo1 {
    'initiator'?: ActionInitiator1;
    /**
     * The Tenant ID that is associated with the action.
     */
    'sourceTenantId'?: string;
    /**
     * The Channel ID that is associated with the action.
     */
    'sourceChannelId'?: string;
    /**
     * The location ID that is associated with the action (supports POS cases).
     */
    'sourceLocationId'?: string;
}
/**
 * 
 */
export interface TransactionTransactionQueryServiceV1RiseGiftCardsTransactionsQueryPostQueryTransactionsRequestBody {
    'query': QueryV21;
}
/**
 * 
 */

export const TransactionType = {
    Redeem: 'REDEEM',
    Void: 'VOID',
    Reward: 'REWARD',
    WalletActionEnd: 'WALLET_ACTION_END',
    Manual: 'MANUAL',
    Campaign: 'CAMPAIGN',
    StoreCreditRefund: 'STORE_CREDIT_REFUND',
    Migration: 'MIGRATION',
    Initial: 'INITIAL',
    PaymentMethodRefund: 'PAYMENT_METHOD_REFUND',
    WalletActionStart: 'WALLET_ACTION_START',
    Bulk: 'BULK'
} as const;

export type TransactionType = typeof TransactionType[keyof typeof TransactionType];


/**
 * 
 */
export interface TransactionWrapper {
    /**
     * Transaction ID.
     */
    'id'?: string;
    /**
     * Date and time the Transaction was created.
     */
    'createdDate'?: string;
}
/**
 * The last transaction that modified the gift card balance.
 */
export interface TransactionWrapper1 {
    /**
     * Transaction ID.
     */
    'id'?: string;
    /**
     * Date and time the Transaction was created.
     */
    'createdDate'?: string;
}
/**
 * The last transaction that decreased the gift card balance, such as redemption or refund.
 */
export interface TransactionWrapper2 {
    /**
     * Transaction ID.
     */
    'id'?: string;
    /**
     * Date and time the Transaction was created.
     */
    'createdDate'?: string;
}
/**
 * ID of the last transaction that increased the gift card balance.
 */
export interface TransactionWrapper3 {
    /**
     * Transaction ID.
     */
    'id'?: string;
    /**
     * Date and time the Transaction was created.
     */
    'createdDate'?: string;
}
/**
 * 
 */
export interface Trigger {
    /**
     * ID of the app that defines the trigger.
     */
    'appId'?: string;
    /**
     * Trigger key.
     */
    'triggerKey'?: string;
    /**
     * List of filters on schema fields. In order for the automation to run, all filter expressions must evaluate to `true` for a given payload.
     */
    'filters'?: Array<object>;
    /**
     * Defines the time offset between the trigger date and when the automation runs.
     */
    'scheduledEventOffset'?: object;
    /**
     * Limits the number of times an automation can be triggered.
     */
    'rateLimit'?: object;
    /**
     * An optional configuration, per automation, of a schema that is optionally offered by the trigger provider to affect the behavior of the trigger. For example, a trigger provider may offer a schema that allows the user to configure the trigger to happen at a certain time of day, He would define a schema with a field called \"startDate\" and using this parameter the user can define his preferred startDate, per automation.
     */
    'automationConfigMapping'?: object;
    /**
     * Optional schema of the trigger. It will be used instead the trigger schema in case it\'s provided.
     */
    'overrideSchema'?: object;
}
/**
 * 
 */
export interface TriggerInfo {
    /**
     * Trigger app ID
     */
    'appId'?: string;
    /**
     * Trigger key
     */
    'triggerKey'?: string;
}
/**
 * 
 */

export const Type = {
    AppDefined: 'APP_DEFINED',
    Condition: 'CONDITION',
    Delay: 'DELAY',
    RateLimit: 'RATE_LIMIT',
    Split: 'SPLIT'
} as const;

export type Type = typeof Type[keyof typeof Type];


export interface TypeInfo {
    /**
     * APP DEFINED action additional info
     */
    'appDefinedActionInfo'?: object;
    /**
     * Condition action additional info
     */
    'conditionActionInfo'?: object;
    /**
     * Rate limit action additional info
     */
    'rateLimitActionInfo'?: object;
    /**
     * Delay action additional info
     */
    'delayActionInfo'?: object;
    /**
     * Set Variables action additional info
     */
    'setVariablesActionInfo'?: object;
}
/**
 * 
 */

export const Units = {
    Unknown: 'UNKNOWN',
    Minutes: 'MINUTES',
    Hours: 'HOURS',
    Days: 'DAYS'
} as const;

export type Units = typeof Units[keyof typeof Units];


/**
 * 
 */
export interface UpdateGiftCardRequest {
    /**
     * The ID of the GiftCard to update.
     */
    'giftCardId'?: string;
    /**
     * The GiftCard to update.
     */
    'giftCard'?: object;
}
/**
 * 
 */
export interface UpdateGiftCardResponse {
    'giftCard'?: GiftCard3;
}
/**
 * 
 */
export interface UpdateLastActivityForRemindersRequest {
    /**
     * Gift Card ID
     */
    'giftCardId'?: string;
}
/**
 * 
 */
export interface UpdateOrderResponse {
    'order'?: GiftCardOrder2;
}
/**
 * 
 */
export interface UpdateOrderStatusRequest {
    /**
     * Order ID or Source Identifiers of the Order whose status is to be updated.
     */
    'query'?: object;
    /**
     * The new payment status of the order.
     */
    'paymentStatus'?: string;
    /**
     * Skip auto fulfillment of the gift card. Default is false.
     */
    'skipAutoFulfillment'?: boolean;
}
/**
 * 
 */
export interface UpdatePendingSchedulesPayloadRequest {
    /**
     * 
     */
    'identifier'?: string;
    /**
     * 
     */
    'eventPayload'?: string;
}
/**
 * @type UpdateWalletAction400Response
 */
export type UpdateWalletAction400Response = EXPIRATIONDATEINTHEPAST | STARTDATEINTHEPAST | STARTLATERTHANEXPIRATION;

/**
 * @type UpdateWalletAction428Response
 */
export type UpdateWalletAction428Response = WALLETACTIONALREADYACTIVE | WALLETACTIONALREADYEXPIRED;

/**
 * 
 */
export interface UpdateWalletActionResponse {
    'walletAction'?: WalletAction2;
}
/**
 * @type Value1
 * 
 */
export type Value1 = BoolValue | ListValue | NullValue | NumberValue | StringValue | StructValue;

/**
 * 
 */
export interface ValueAggregationResult {
    /**
     * Value of the field.
     */
    'value'?: string;
    /**
     * Number of entities with this value.
     */
    'count'?: number;
}
/**
 * 
 */
export interface ValueAggregationResult1 {
    /**
     * Value of the field.
     */
    'value'?: string;
    /**
     * Number of entities with this value.
     */
    'count'?: number;
}
/**
 * 
 */
export interface ValueResult {
    /**
     * Value of the field.
     */
    'value'?: string;
    /**
     * Number of entities with this value.
     */
    'count'?: number;
}
export interface ValueResults {
    'values'?: ValueResultsValues;
}
/**
 * Value aggregation results.
 */
export interface ValueResultsValues {
    /**
     * List of value aggregations.
     */
    'results'?: Array<ValueAggregationResult1>;
}
export interface VoidOptions {
    'voidOptions'?: VoidOptionsVoidOptions;
}
/**
 * Information about a transaction that comes to void a previous transaction.
 */
export interface VoidOptionsVoidOptions {
    /**
     * ID of the transaction being voided.
     */
    'transactionId'?: string;
}
/**
 * 
 */
export interface VoidTransactionRequest {
    /**
     * 
     */
    'transactionId'?: string;
    /**
     * 
     */
    'sourceTenantId'?: string;
    /**
     * 
     */
    'sourceChannelId'?: string;
}
export interface WALLETACTIONALREADYACTIVE {
    /**
     * Error message
     */
    'message': string;
    'details': WALLETACTIONALREADYACTIVEDetails;
}
export interface WALLETACTIONALREADYACTIVEDetails {
    'applicationError': WALLETACTIONALREADYACTIVEDetailsApplicationError;
}
export interface WALLETACTIONALREADYACTIVEDetailsApplicationError {
    /**
     * Error code: WALLET_ACTION_ALREADY_ACTIVE
     */
    'code': WALLETACTIONALREADYACTIVEDetailsApplicationErrorCodeEnum;
    /**
     * Error description
     */
    'description': string;
    'data'?: object;
}

export const WALLETACTIONALREADYACTIVEDetailsApplicationErrorCodeEnum = {
    WalletActionAlreadyActive: 'WALLET_ACTION_ALREADY_ACTIVE'
} as const;

export type WALLETACTIONALREADYACTIVEDetailsApplicationErrorCodeEnum = typeof WALLETACTIONALREADYACTIVEDetailsApplicationErrorCodeEnum[keyof typeof WALLETACTIONALREADYACTIVEDetailsApplicationErrorCodeEnum];

export interface WALLETACTIONALREADYEXPIRED {
    /**
     * Error message
     */
    'message': string;
    'details': WALLETACTIONALREADYEXPIREDDetails;
}
export interface WALLETACTIONALREADYEXPIREDDetails {
    'applicationError': WALLETACTIONALREADYEXPIREDDetailsApplicationError;
}
export interface WALLETACTIONALREADYEXPIREDDetailsApplicationError {
    /**
     * Error code: WALLET_ACTION_ALREADY_EXPIRED
     */
    'code': WALLETACTIONALREADYEXPIREDDetailsApplicationErrorCodeEnum;
    /**
     * Error description
     */
    'description': string;
    'data'?: object;
}

export const WALLETACTIONALREADYEXPIREDDetailsApplicationErrorCodeEnum = {
    WalletActionAlreadyExpired: 'WALLET_ACTION_ALREADY_EXPIRED'
} as const;

export type WALLETACTIONALREADYEXPIREDDetailsApplicationErrorCodeEnum = typeof WALLETACTIONALREADYEXPIREDDetailsApplicationErrorCodeEnum[keyof typeof WALLETACTIONALREADYEXPIREDDetailsApplicationErrorCodeEnum];

export interface WALLETACTIONEXCEEDSMAXIMUMBALANCE {
    /**
     * Error message
     */
    'message': string;
    'details': WALLETACTIONEXCEEDSMAXIMUMBALANCEDetails;
}
export interface WALLETACTIONEXCEEDSMAXIMUMBALANCEDetails {
    'applicationError': WALLETACTIONEXCEEDSMAXIMUMBALANCEDetailsApplicationError;
}
export interface WALLETACTIONEXCEEDSMAXIMUMBALANCEDetailsApplicationError {
    /**
     * Error code: WALLET_ACTION_EXCEEDS_MAXIMUM_BALANCE
     */
    'code': WALLETACTIONEXCEEDSMAXIMUMBALANCEDetailsApplicationErrorCodeEnum;
    /**
     * Error description
     */
    'description': string;
    'data'?: object;
}

export const WALLETACTIONEXCEEDSMAXIMUMBALANCEDetailsApplicationErrorCodeEnum = {
    WalletActionExceedsMaximumBalance: 'WALLET_ACTION_EXCEEDS_MAXIMUM_BALANCE'
} as const;

export type WALLETACTIONEXCEEDSMAXIMUMBALANCEDetailsApplicationErrorCodeEnum = typeof WALLETACTIONEXCEEDSMAXIMUMBALANCEDetailsApplicationErrorCodeEnum[keyof typeof WALLETACTIONEXCEEDSMAXIMUMBALANCEDetailsApplicationErrorCodeEnum];

export interface WALLETACTIONNOTACTIVE {
    /**
     * Error message
     */
    'message': string;
    'details': WALLETACTIONNOTACTIVEDetails;
}
export interface WALLETACTIONNOTACTIVEDetails {
    'applicationError': WALLETACTIONNOTACTIVEDetailsApplicationError;
}
export interface WALLETACTIONNOTACTIVEDetailsApplicationError {
    /**
     * Error code: WALLET_ACTION_NOT_ACTIVE
     */
    'code': WALLETACTIONNOTACTIVEDetailsApplicationErrorCodeEnum;
    /**
     * Error description
     */
    'description': string;
    'data'?: object;
}

export const WALLETACTIONNOTACTIVEDetailsApplicationErrorCodeEnum = {
    WalletActionNotActive: 'WALLET_ACTION_NOT_ACTIVE'
} as const;

export type WALLETACTIONNOTACTIVEDetailsApplicationErrorCodeEnum = typeof WALLETACTIONNOTACTIVEDetailsApplicationErrorCodeEnum[keyof typeof WALLETACTIONNOTACTIVEDetailsApplicationErrorCodeEnum];

/**
 * A wallet represents a customer who has Store Credits. It contains information about the Gift Card associated with this wallet. It also contains a list of references to the customer in specific source channels (see CustomerReference object definition below).
 */
export interface Wallet {
    /**
     * Wallet ID.
     */
    'id'?: string;
    /**
     * Represents the current state of an item. Each time the item is modified, its `revision` changes. for an update operation to succeed, you MUST pass the latest revision.
     */
    'revision'?: string;
    /**
     * ID of the Gift Card associated with this Wallet.
     */
    'giftCardId'?: string;
    /**
     * List of references to the customer in specific source channels. See definition below.
     */
    'customerReferences'?: Array<object>;
    /**
     * The time this Wallet was created.
     */
    'createdDate'?: string;
    /**
     * The time this Wallet was last updated.
     */
    'updatedDate'?: string;
    /**
     * Information about the Gift Card associated with this Wallet.
     */
    'giftCardInfo'?: object;
    /**
     * 
     */
    'primaryContactDetails'?: object;
}
/**
 * The wallet to which the wallet action was added.
 */
export interface Wallet1 {
    /**
     * Wallet ID.
     */
    'id'?: string;
    /**
     * Represents the current state of an item. Each time the item is modified, its `revision` changes. for an update operation to succeed, you MUST pass the latest revision.
     */
    'revision'?: string;
    /**
     * ID of the Gift Card associated with this Wallet.
     */
    'giftCardId'?: string;
    /**
     * List of references to the customer in specific source channels. See definition below.
     */
    'customerReferences'?: Array<CustomerReference1>;
    /**
     * The time this Wallet was created.
     */
    'createdDate'?: string;
    /**
     * The time this Wallet was last updated.
     */
    'updatedDate'?: string;
    'giftCardInfo'?: GiftCardInfo1;
    'primaryContactDetails'?: ContactDetails1;
}
/**
 * The retrieved Wallet.
 */
export interface Wallet2 {
    /**
     * Wallet ID.
     */
    'id'?: string;
    /**
     * Represents the current state of an item. Each time the item is modified, its `revision` changes. for an update operation to succeed, you MUST pass the latest revision.
     */
    'revision'?: string;
    /**
     * ID of the Gift Card associated with this Wallet.
     */
    'giftCardId'?: string;
    /**
     * List of references to the customer in specific source channels. See definition below.
     */
    'customerReferences'?: Array<CustomerReference1>;
    /**
     * The time this Wallet was created.
     */
    'createdDate'?: string;
    /**
     * The time this Wallet was last updated.
     */
    'updatedDate'?: string;
    'giftCardInfo'?: GiftCardInfo1;
    'primaryContactDetails'?: ContactDetails1;
}
/**
 * Created wallet.
 */
export interface Wallet3 {
    /**
     * Wallet ID.
     */
    'id'?: string;
    /**
     * Represents the current state of an item. Each time the item is modified, its `revision` changes. for an update operation to succeed, you MUST pass the latest revision.
     */
    'revision'?: string;
    /**
     * ID of the Gift Card associated with this Wallet.
     */
    'giftCardId'?: string;
    /**
     * List of references to the customer in specific source channels. See definition below.
     */
    'customerReferences'?: Array<CustomerReference1>;
    /**
     * The time this Wallet was created.
     */
    'createdDate'?: string;
    /**
     * The time this Wallet was last updated.
     */
    'updatedDate'?: string;
    'giftCardInfo'?: GiftCardInfo1;
    'primaryContactDetails'?: ContactDetails1;
}
/**
 * The retrieved or created wallet.
 */
export interface Wallet4 {
    /**
     * Wallet ID.
     */
    'id'?: string;
    /**
     * Represents the current state of an item. Each time the item is modified, its `revision` changes. for an update operation to succeed, you MUST pass the latest revision.
     */
    'revision'?: string;
    /**
     * ID of the Gift Card associated with this Wallet.
     */
    'giftCardId'?: string;
    /**
     * List of references to the customer in specific source channels. See definition below.
     */
    'customerReferences'?: Array<CustomerReference1>;
    /**
     * The time this Wallet was created.
     */
    'createdDate'?: string;
    /**
     * The time this Wallet was last updated.
     */
    'updatedDate'?: string;
    'giftCardInfo'?: GiftCardInfo1;
    'primaryContactDetails'?: ContactDetails1;
}
/**
 * A wallet represents a customer who has Store Credits. It contains information about the Gift Card associated with this wallet. It also contains a list of references to the customer in specific source channels (see CustomerReference object definition below).
 */
export interface Wallet5 {
    /**
     * Wallet ID.
     */
    'id'?: string;
    /**
     * Represents the current state of an item. Each time the item is modified, its `revision` changes. for an update operation to succeed, you MUST pass the latest revision.
     */
    'revision'?: string;
    /**
     * ID of the Gift Card associated with this Wallet.
     */
    'giftCardId'?: string;
    /**
     * List of references to the customer in specific source channels. See definition below.
     */
    'customerReferences'?: Array<CustomerReference1>;
    /**
     * The time this Wallet was created.
     */
    'createdDate'?: string;
    /**
     * The time this Wallet was last updated.
     */
    'updatedDate'?: string;
    'giftCardInfo'?: GiftCardInfo1;
    'primaryContactDetails'?: ContactDetails1;
}
/**
 * WalletAction is the main entity of WalletActionService. It represents a Store Credit that adds to the balance of a customer\'s wallet. It contains information about the amount and expiration date (if applicable) of the Store Credit, the context of its source (e.g. refund, workflow, etc.), and its status.
 */
export interface WalletAction {
    /**
     * WalletAction ID.
     */
    'id'?: string;
    /**
     * Represents the current state of an item. Each time the item is modified, its `revision` changes. For an update operation to succeed, you MUST pass the latest revision.
     */
    'revision'?: string;
    /**
     * Represents the time this WalletAction was created.
     */
    'createdDate'?: string;
    /**
     * Represents the time this WalletAction was last updated.
     */
    'updatedDate'?: string;
    /**
     * Represents the time at which the WalletAction\'s amount will be added to the account. Defaults to immediately.
     */
    'startDate'?: string;
    /**
     * Represents the time at which the unused balance of the WalletAction will be deducted from the account. Defaults to never.
     */
    'expirationDate'?: string;
    /**
     * Represents the time at which the WalletAction was manually disabled, if applicable.
     */
    'disableDate'?: string;
    /**
     * The amount to be added to the Wallet.
     */
    'amount'?: string;
    /**
     * Free text comment regarding the WalletAction context
     */
    'note'?: string;
    /**
     * Indicates the kind of the specific WalletAction
     */
    'type'?: string;
    /**
     * Details about the WalletAction\'s execution, such as transaction ID and execution date. Set when the WalletAction is executed (e.g., when the amount is added to the account).
     */
    'walletActionStarted'?: object;
    /**
     * Details about the execution of the ending of the wallet action (due to expiration, disabling, etc), such as transaction ID and execution date. Set when the WalletAction is ended (i.e. when the amount is deducted from the account).
     */
    'walletActionEnded'?: object;
    /**
     * The current status of the WalletAction. Set to PENDING when the WalletAction is created and updated to ACTIVE when the amount is added to the wallet.
     */
    'status'?: string;
    /**
     * Information about the initiator of the WalletAction, such as the app or user that initiated the action. Set when the WalletAction is created.
     */
    'source'?: object;
    /**
     * Settings of the notifications related to the WalletAction. This field is used to specify whether to skip email dispatch or override the template ID for email notifications.
     */
    'notifications'?: object;
    /**
     * Indicates whether the WalletAction is a liability. The default is false.
     */
    'liability'?: boolean;
    /**
     * Detailed information about the context of a store credit, such as the issuer type and sales channel.
     */
    'storeCreditContext'?: object;
    /**
     * Information about the external event that triggered the WalletAction, such as type of event and a short description or identifier of the event.
     */
    'externalEvent'?: object;
    /**
     * ID of the wallet to which the WalletAction belongs.
     */
    'walletId'?: string;
    /**
     * Unique key to identify the WalletAction, used to prevent duplicate WalletActions from being created in case of retries or network issues. The key should be unique for each WalletAction and should not be reused.
     */
    'idempotencyKey'?: string;
}
/**
 * The created WalletAction.
 */
export interface WalletAction1 {
    /**
     * WalletAction ID.
     */
    'id'?: string;
    /**
     * Represents the current state of an item. Each time the item is modified, its `revision` changes. For an update operation to succeed, you MUST pass the latest revision.
     */
    'revision'?: string;
    /**
     * Represents the time this WalletAction was created.
     */
    'createdDate'?: string;
    /**
     * Represents the time this WalletAction was last updated.
     */
    'updatedDate'?: string;
    /**
     * Represents the time at which the WalletAction\'s amount will be added to the account. Defaults to immediately.
     */
    'startDate'?: string;
    /**
     * Represents the time at which the unused balance of the WalletAction will be deducted from the account. Defaults to never.
     */
    'expirationDate'?: string;
    /**
     * Represents the time at which the WalletAction was manually disabled, if applicable.
     */
    'disableDate'?: string;
    /**
     * The amount to be added to the Wallet.
     */
    'amount'?: string;
    /**
     * Free text comment regarding the WalletAction context (**Deprecated**: Use `note` instead.)
     * @deprecated
     */
    'note'?: string;
    /**
     * Indicates the kind of the specific WalletAction (**Deprecated**)
     * @deprecated
     */
    'type'?: WalletAction1TypeEnum;
    'walletActionStarted'?: WalletActionExecutionDetails1;
    'walletActionEnded'?: WalletActionExecutionDetails2;
    /**
     * The current status of the WalletAction. Set to PENDING when the WalletAction is created and updated to ACTIVE when the amount is added to the wallet.
     */
    'status'?: WalletAction1StatusEnum;
    'source'?: ActionInitiator2;
    'notifications'?: Notifications1;
    /**
     * Indicates whether the WalletAction is a liability. The default is false.
     */
    'liability'?: boolean;
    'storeCreditContext'?: StoreCreditContext1;
    'externalEvent'?: ExternalEvent2;
    /**
     * ID of the wallet to which the WalletAction belongs.
     */
    'walletId'?: string;
    /**
     * Unique key to identify the WalletAction, used to prevent duplicate WalletActions from being created in case of retries or network issues. The key should be unique for each WalletAction and should not be reused.
     */
    'idempotencyKey'?: string;
}

export const WalletAction1TypeEnum = {
    Unknown: 'UNKNOWN',
    Reward: 'REWARD',
    Refund: 'REFUND'
} as const;

export type WalletAction1TypeEnum = typeof WalletAction1TypeEnum[keyof typeof WalletAction1TypeEnum];
export const WalletAction1StatusEnum = {
    Pending: 'PENDING',
    Active: 'ACTIVE',
    Disabled: 'DISABLED',
    Expired: 'EXPIRED',
    Failed: 'FAILED'
} as const;

export type WalletAction1StatusEnum = typeof WalletAction1StatusEnum[keyof typeof WalletAction1StatusEnum];

/**
 * The updated WalletAction.
 */
export interface WalletAction2 {
    /**
     * WalletAction ID.
     */
    'id'?: string;
    /**
     * Represents the current state of an item. Each time the item is modified, its `revision` changes. For an update operation to succeed, you MUST pass the latest revision.
     */
    'revision'?: string;
    /**
     * Represents the time this WalletAction was created.
     */
    'createdDate'?: string;
    /**
     * Represents the time this WalletAction was last updated.
     */
    'updatedDate'?: string;
    /**
     * Represents the time at which the WalletAction\'s amount will be added to the account. Defaults to immediately.
     */
    'startDate'?: string;
    /**
     * Represents the time at which the unused balance of the WalletAction will be deducted from the account. Defaults to never.
     */
    'expirationDate'?: string;
    /**
     * Represents the time at which the WalletAction was manually disabled, if applicable.
     */
    'disableDate'?: string;
    /**
     * The amount to be added to the Wallet.
     */
    'amount'?: string;
    /**
     * Free text comment regarding the WalletAction context (**Deprecated**: Use `note` instead.)
     * @deprecated
     */
    'note'?: string;
    /**
     * Indicates the kind of the specific WalletAction (**Deprecated**)
     * @deprecated
     */
    'type'?: WalletAction2TypeEnum;
    'walletActionStarted'?: WalletActionExecutionDetails1;
    'walletActionEnded'?: WalletActionExecutionDetails2;
    /**
     * The current status of the WalletAction. Set to PENDING when the WalletAction is created and updated to ACTIVE when the amount is added to the wallet.
     */
    'status'?: WalletAction2StatusEnum;
    'source'?: ActionInitiator2;
    'notifications'?: Notifications1;
    /**
     * Indicates whether the WalletAction is a liability. The default is false.
     */
    'liability'?: boolean;
    'storeCreditContext'?: StoreCreditContext1;
    'externalEvent'?: ExternalEvent2;
    /**
     * ID of the wallet to which the WalletAction belongs.
     */
    'walletId'?: string;
    /**
     * Unique key to identify the WalletAction, used to prevent duplicate WalletActions from being created in case of retries or network issues. The key should be unique for each WalletAction and should not be reused.
     */
    'idempotencyKey'?: string;
}

export const WalletAction2TypeEnum = {
    Unknown: 'UNKNOWN',
    Reward: 'REWARD',
    Refund: 'REFUND'
} as const;

export type WalletAction2TypeEnum = typeof WalletAction2TypeEnum[keyof typeof WalletAction2TypeEnum];
export const WalletAction2StatusEnum = {
    Pending: 'PENDING',
    Active: 'ACTIVE',
    Disabled: 'DISABLED',
    Expired: 'EXPIRED',
    Failed: 'FAILED'
} as const;

export type WalletAction2StatusEnum = typeof WalletAction2StatusEnum[keyof typeof WalletAction2StatusEnum];

/**
 * The disabled WalletAction.
 */
export interface WalletAction3 {
    /**
     * WalletAction ID.
     */
    'id'?: string;
    /**
     * Represents the current state of an item. Each time the item is modified, its `revision` changes. For an update operation to succeed, you MUST pass the latest revision.
     */
    'revision'?: string;
    /**
     * Represents the time this WalletAction was created.
     */
    'createdDate'?: string;
    /**
     * Represents the time this WalletAction was last updated.
     */
    'updatedDate'?: string;
    /**
     * Represents the time at which the WalletAction\'s amount will be added to the account. Defaults to immediately.
     */
    'startDate'?: string;
    /**
     * Represents the time at which the unused balance of the WalletAction will be deducted from the account. Defaults to never.
     */
    'expirationDate'?: string;
    /**
     * Represents the time at which the WalletAction was manually disabled, if applicable.
     */
    'disableDate'?: string;
    /**
     * The amount to be added to the Wallet.
     */
    'amount'?: string;
    /**
     * Free text comment regarding the WalletAction context (**Deprecated**: Use `note` instead.)
     * @deprecated
     */
    'note'?: string;
    /**
     * Indicates the kind of the specific WalletAction (**Deprecated**)
     * @deprecated
     */
    'type'?: WalletAction3TypeEnum;
    'walletActionStarted'?: WalletActionExecutionDetails1;
    'walletActionEnded'?: WalletActionExecutionDetails2;
    /**
     * The current status of the WalletAction. Set to PENDING when the WalletAction is created and updated to ACTIVE when the amount is added to the wallet.
     */
    'status'?: WalletAction3StatusEnum;
    'source'?: ActionInitiator2;
    'notifications'?: Notifications1;
    /**
     * Indicates whether the WalletAction is a liability. The default is false.
     */
    'liability'?: boolean;
    'storeCreditContext'?: StoreCreditContext1;
    'externalEvent'?: ExternalEvent2;
    /**
     * ID of the wallet to which the WalletAction belongs.
     */
    'walletId'?: string;
    /**
     * Unique key to identify the WalletAction, used to prevent duplicate WalletActions from being created in case of retries or network issues. The key should be unique for each WalletAction and should not be reused.
     */
    'idempotencyKey'?: string;
}

export const WalletAction3TypeEnum = {
    Unknown: 'UNKNOWN',
    Reward: 'REWARD',
    Refund: 'REFUND'
} as const;

export type WalletAction3TypeEnum = typeof WalletAction3TypeEnum[keyof typeof WalletAction3TypeEnum];
export const WalletAction3StatusEnum = {
    Pending: 'PENDING',
    Active: 'ACTIVE',
    Disabled: 'DISABLED',
    Expired: 'EXPIRED',
    Failed: 'FAILED'
} as const;

export type WalletAction3StatusEnum = typeof WalletAction3StatusEnum[keyof typeof WalletAction3StatusEnum];

/**
 * WalletAction is the main entity of WalletActionService. It represents a Store Credit that adds to the balance of a customer\'s wallet. It contains information about the amount and expiration date (if applicable) of the Store Credit, the context of its source (e.g. refund, workflow, etc.), and its status.
 */
export interface WalletAction4 {
    /**
     * WalletAction ID.
     */
    'id'?: string;
    /**
     * Represents the current state of an item. Each time the item is modified, its `revision` changes. For an update operation to succeed, you MUST pass the latest revision.
     */
    'revision'?: string;
    /**
     * Represents the time this WalletAction was created.
     */
    'createdDate'?: string;
    /**
     * Represents the time this WalletAction was last updated.
     */
    'updatedDate'?: string;
    /**
     * Represents the time at which the WalletAction\'s amount will be added to the account. Defaults to immediately.
     */
    'startDate'?: string;
    /**
     * Represents the time at which the unused balance of the WalletAction will be deducted from the account. Defaults to never.
     */
    'expirationDate'?: string;
    /**
     * Represents the time at which the WalletAction was manually disabled, if applicable.
     */
    'disableDate'?: string;
    /**
     * The amount to be added to the Wallet.
     */
    'amount'?: string;
    /**
     * Free text comment regarding the WalletAction context (**Deprecated**: Use `note` instead.)
     * @deprecated
     */
    'note'?: string;
    /**
     * Indicates the kind of the specific WalletAction (**Deprecated**)
     * @deprecated
     */
    'type'?: WalletAction4TypeEnum;
    'walletActionStarted'?: WalletActionExecutionDetails1;
    'walletActionEnded'?: WalletActionExecutionDetails2;
    /**
     * The current status of the WalletAction. Set to PENDING when the WalletAction is created and updated to ACTIVE when the amount is added to the wallet.
     */
    'status'?: WalletAction4StatusEnum;
    'source'?: ActionInitiator2;
    'notifications'?: Notifications1;
    /**
     * Indicates whether the WalletAction is a liability. The default is false.
     */
    'liability'?: boolean;
    'storeCreditContext'?: StoreCreditContext1;
    'externalEvent'?: ExternalEvent2;
    /**
     * ID of the wallet to which the WalletAction belongs.
     */
    'walletId'?: string;
    /**
     * Unique key to identify the WalletAction, used to prevent duplicate WalletActions from being created in case of retries or network issues. The key should be unique for each WalletAction and should not be reused.
     */
    'idempotencyKey'?: string;
}

export const WalletAction4TypeEnum = {
    Unknown: 'UNKNOWN',
    Reward: 'REWARD',
    Refund: 'REFUND'
} as const;

export type WalletAction4TypeEnum = typeof WalletAction4TypeEnum[keyof typeof WalletAction4TypeEnum];
export const WalletAction4StatusEnum = {
    Pending: 'PENDING',
    Active: 'ACTIVE',
    Disabled: 'DISABLED',
    Expired: 'EXPIRED',
    Failed: 'FAILED'
} as const;

export type WalletAction4StatusEnum = typeof WalletAction4StatusEnum[keyof typeof WalletAction4StatusEnum];

/**
 * WalletAction.
 */
export interface WalletAction5 {
    /**
     * WalletAction ID.
     */
    'id'?: string;
    /**
     * Represents the current state of an item. Each time the item is modified, its `revision` changes. For an update operation to succeed, you MUST pass the latest revision.
     */
    'revision'?: string;
    /**
     * Represents the time this WalletAction was created.
     */
    'createdDate'?: string;
    /**
     * Represents the time this WalletAction was last updated.
     */
    'updatedDate'?: string;
    /**
     * Represents the time at which the WalletAction\'s amount will be added to the account. Defaults to immediately.
     */
    'startDate'?: string;
    /**
     * Represents the time at which the unused balance of the WalletAction will be deducted from the account. Defaults to never.
     */
    'expirationDate'?: string;
    /**
     * Represents the time at which the WalletAction was manually disabled, if applicable.
     */
    'disableDate'?: string;
    /**
     * The amount to be added to the Wallet.
     */
    'amount'?: string;
    /**
     * Free text comment regarding the WalletAction context (**Deprecated**: Use `note` instead.)
     * @deprecated
     */
    'note'?: string;
    /**
     * Indicates the kind of the specific WalletAction (**Deprecated**)
     * @deprecated
     */
    'type'?: WalletAction5TypeEnum;
    'walletActionStarted'?: WalletActionExecutionDetails1;
    'walletActionEnded'?: WalletActionExecutionDetails2;
    /**
     * The current status of the WalletAction. Set to PENDING when the WalletAction is created and updated to ACTIVE when the amount is added to the wallet.
     */
    'status'?: WalletAction5StatusEnum;
    'source'?: ActionInitiator2;
    'notifications'?: Notifications1;
    /**
     * Indicates whether the WalletAction is a liability. The default is false.
     */
    'liability'?: boolean;
    'storeCreditContext'?: StoreCreditContext1;
    'externalEvent'?: ExternalEvent2;
    /**
     * ID of the wallet to which the WalletAction belongs.
     */
    'walletId'?: string;
    /**
     * Unique key to identify the WalletAction, used to prevent duplicate WalletActions from being created in case of retries or network issues. The key should be unique for each WalletAction and should not be reused.
     */
    'idempotencyKey'?: string;
}

export const WalletAction5TypeEnum = {
    Unknown: 'UNKNOWN',
    Reward: 'REWARD',
    Refund: 'REFUND'
} as const;

export type WalletAction5TypeEnum = typeof WalletAction5TypeEnum[keyof typeof WalletAction5TypeEnum];
export const WalletAction5StatusEnum = {
    Pending: 'PENDING',
    Active: 'ACTIVE',
    Disabled: 'DISABLED',
    Expired: 'EXPIRED',
    Failed: 'FAILED'
} as const;

export type WalletAction5StatusEnum = typeof WalletAction5StatusEnum[keyof typeof WalletAction5StatusEnum];

/**
 * WalletAction to be created.
 */
export interface WalletAction6 {
    /**
     * WalletAction ID.
     */
    'id'?: string;
    /**
     * Represents the current state of an item. Each time the item is modified, its `revision` changes. For an update operation to succeed, you MUST pass the latest revision.
     */
    'revision'?: string;
    /**
     * Represents the time this WalletAction was created.
     */
    'createdDate'?: string;
    /**
     * Represents the time this WalletAction was last updated.
     */
    'updatedDate'?: string;
    /**
     * Represents the time at which the WalletAction\'s amount will be added to the account. Defaults to immediately.
     */
    'startDate'?: string;
    /**
     * Represents the time at which the unused balance of the WalletAction will be deducted from the account. Defaults to never.
     */
    'expirationDate'?: string;
    /**
     * Represents the time at which the WalletAction was manually disabled, if applicable.
     */
    'disableDate'?: string;
    /**
     * The amount to be added to the Wallet.
     */
    'amount': string;
    /**
     * Free text comment regarding the WalletAction context (**Deprecated**: Use `note` instead.)
     * @deprecated
     */
    'note'?: string;
    /**
     * Indicates the kind of the specific WalletAction (**Deprecated**)
     * @deprecated
     */
    'type'?: WalletAction6TypeEnum;
    'walletActionStarted'?: WalletActionExecutionDetails1;
    'walletActionEnded'?: WalletActionExecutionDetails2;
    /**
     * The current status of the WalletAction. Set to PENDING when the WalletAction is created and updated to ACTIVE when the amount is added to the wallet.
     */
    'status'?: WalletAction6StatusEnum;
    'source'?: ActionInitiator2;
    'notifications'?: Notifications1;
    /**
     * Indicates whether the WalletAction is a liability. The default is false.
     */
    'liability'?: boolean;
    'storeCreditContext': StoreCreditContext1;
    'externalEvent'?: ExternalEvent2;
    /**
     * ID of the wallet to which the WalletAction belongs.
     */
    'walletId': string;
    /**
     * Unique key to identify the WalletAction, used to prevent duplicate WalletActions from being created in case of retries or network issues. The key should be unique for each WalletAction and should not be reused.
     */
    'idempotencyKey'?: string;
}

export const WalletAction6TypeEnum = {
    Unknown: 'UNKNOWN',
    Reward: 'REWARD',
    Refund: 'REFUND'
} as const;

export type WalletAction6TypeEnum = typeof WalletAction6TypeEnum[keyof typeof WalletAction6TypeEnum];
export const WalletAction6StatusEnum = {
    Pending: 'PENDING',
    Active: 'ACTIVE',
    Disabled: 'DISABLED',
    Expired: 'EXPIRED',
    Failed: 'FAILED'
} as const;

export type WalletAction6StatusEnum = typeof WalletAction6StatusEnum[keyof typeof WalletAction6StatusEnum];

/**
 * WalletAction to be created.
 */
export interface WalletAction7 {
    /**
     * WalletAction ID.
     */
    'id'?: string;
    /**
     * Represents the current state of an item. Each time the item is modified, its `revision` changes. For an update operation to succeed, you MUST pass the latest revision.
     */
    'revision'?: string;
    /**
     * Represents the time this WalletAction was created.
     */
    'createdDate'?: string;
    /**
     * Represents the time this WalletAction was last updated.
     */
    'updatedDate'?: string;
    /**
     * Represents the time at which the WalletAction\'s amount will be added to the account. Defaults to immediately.
     */
    'startDate'?: string;
    /**
     * Represents the time at which the unused balance of the WalletAction will be deducted from the account. Defaults to never.
     */
    'expirationDate'?: string;
    /**
     * Represents the time at which the WalletAction was manually disabled, if applicable.
     */
    'disableDate'?: string;
    /**
     * The amount to be added to the Wallet.
     */
    'amount': string;
    /**
     * Free text comment regarding the WalletAction context (**Deprecated**: Use `note` instead.)
     * @deprecated
     */
    'note'?: string;
    /**
     * Indicates the kind of the specific WalletAction (**Deprecated**)
     * @deprecated
     */
    'type'?: WalletAction7TypeEnum;
    'walletActionStarted'?: WalletActionExecutionDetails1;
    'walletActionEnded'?: WalletActionExecutionDetails2;
    /**
     * The current status of the WalletAction. Set to PENDING when the WalletAction is created and updated to ACTIVE when the amount is added to the wallet.
     */
    'status'?: WalletAction7StatusEnum;
    'source'?: ActionInitiator2;
    'notifications'?: Notifications1;
    /**
     * Indicates whether the WalletAction is a liability. The default is false.
     */
    'liability'?: boolean;
    'storeCreditContext': StoreCreditContext1;
    'externalEvent'?: ExternalEvent2;
    /**
     * ID of the wallet to which the WalletAction belongs.
     */
    'walletId'?: string;
    /**
     * Unique key to identify the WalletAction, used to prevent duplicate WalletActions from being created in case of retries or network issues. The key should be unique for each WalletAction and should not be reused.
     */
    'idempotencyKey'?: string;
}

export const WalletAction7TypeEnum = {
    Unknown: 'UNKNOWN',
    Reward: 'REWARD',
    Refund: 'REFUND'
} as const;

export type WalletAction7TypeEnum = typeof WalletAction7TypeEnum[keyof typeof WalletAction7TypeEnum];
export const WalletAction7StatusEnum = {
    Pending: 'PENDING',
    Active: 'ACTIVE',
    Disabled: 'DISABLED',
    Expired: 'EXPIRED',
    Failed: 'FAILED'
} as const;

export type WalletAction7StatusEnum = typeof WalletAction7StatusEnum[keyof typeof WalletAction7StatusEnum];

/**
 * WalletAction to be updated, may be partial.
 */
export interface WalletAction8 {
    /**
     * WalletAction ID.
     */
    'id': string;
    /**
     * Represents the current state of an item. Each time the item is modified, its `revision` changes. For an update operation to succeed, you MUST pass the latest revision.
     */
    'revision': string;
    /**
     * Represents the time this WalletAction was created.
     */
    'createdDate'?: string;
    /**
     * Represents the time this WalletAction was last updated.
     */
    'updatedDate'?: string;
    /**
     * Represents the time at which the WalletAction\'s amount will be added to the account. Defaults to immediately.
     */
    'startDate'?: string;
    /**
     * Represents the time at which the unused balance of the WalletAction will be deducted from the account. Defaults to never.
     */
    'expirationDate'?: string;
    /**
     * Represents the time at which the WalletAction was manually disabled, if applicable.
     */
    'disableDate'?: string;
    /**
     * The amount to be added to the Wallet.
     */
    'amount'?: string;
    /**
     * Free text comment regarding the WalletAction context (**Deprecated**: Use `note` instead.)
     * @deprecated
     */
    'note'?: string;
    /**
     * Indicates the kind of the specific WalletAction (**Deprecated**)
     * @deprecated
     */
    'type'?: WalletAction8TypeEnum;
    'walletActionStarted'?: WalletActionExecutionDetails1;
    'walletActionEnded'?: WalletActionExecutionDetails2;
    /**
     * The current status of the WalletAction. Set to PENDING when the WalletAction is created and updated to ACTIVE when the amount is added to the wallet.
     */
    'status'?: WalletAction8StatusEnum;
    'source'?: ActionInitiator2;
    'notifications'?: Notifications1;
    /**
     * Indicates whether the WalletAction is a liability. The default is false.
     */
    'liability'?: boolean;
    'storeCreditContext'?: StoreCreditContext1;
    'externalEvent'?: ExternalEvent2;
    /**
     * ID of the wallet to which the WalletAction belongs.
     */
    'walletId'?: string;
    /**
     * Unique key to identify the WalletAction, used to prevent duplicate WalletActions from being created in case of retries or network issues. The key should be unique for each WalletAction and should not be reused.
     */
    'idempotencyKey'?: string;
}

export const WalletAction8TypeEnum = {
    Unknown: 'UNKNOWN',
    Reward: 'REWARD',
    Refund: 'REFUND'
} as const;

export type WalletAction8TypeEnum = typeof WalletAction8TypeEnum[keyof typeof WalletAction8TypeEnum];
export const WalletAction8StatusEnum = {
    Pending: 'PENDING',
    Active: 'ACTIVE',
    Disabled: 'DISABLED',
    Expired: 'EXPIRED',
    Failed: 'FAILED'
} as const;

export type WalletAction8StatusEnum = typeof WalletAction8StatusEnum[keyof typeof WalletAction8StatusEnum];

/**
 * 
 */
export interface WalletActionCreationDisabledAtDateSetDetails {
    /**
     * Represents the time when the walletAction was disabled.
     */
    'disableDate'?: string;
}
/**
 * 
 */
export interface WalletActionCreationExpirationDateInThePastDetails {
    /**
     * The date on which the walletAction was requested to expire, which is in the past.
     */
    'expirationDate'?: string;
    /**
     * The current date, which is after the requested expiration date.
     */
    'currentDate'?: string;
}
/**
 * 
 */
export interface WalletActionCreationStartLaterThanExpirationDetails {
    /**
     * The date on which the walletAction was requested to become active, which is after the expiration date.
     */
    'startDate'?: string;
    /**
     * The date when the walletAction was requested to expire, which is before the requested start date.
     */
    'expirationDate'?: string;
}
/**
 * 
 */
export interface WalletActionDisabled {
    /**
     * 
     */
    'walletAction'?: object;
}
export interface WalletActionEndOptions {
    'walletActionEndOptions'?: WalletActionEndOptionsWalletActionEndOptions;
}
/**
 * Information about a transaction whose source is the end of a wallet action (store credit).
 */
export interface WalletActionEndOptionsWalletActionEndOptions {
    /**
     * ID of the wallet action being ended.
     */
    'walletActionId'?: string;
    /**
     * ID of the transaction being reversed.
     */
    'transactionId'?: string;
    /**
     * Indicates whether the wallet action end is a liability.
     */
    'liability'?: boolean;
    /**
     * Reason the wallet action is ending.
     */
    'reason'?: WalletActionEndOptionsWalletActionEndOptionsReasonEnum;
}

export const WalletActionEndOptionsWalletActionEndOptionsReasonEnum = {
    Cancel: 'CANCEL',
    Expiration: 'EXPIRATION'
} as const;

export type WalletActionEndOptionsWalletActionEndOptionsReasonEnum = typeof WalletActionEndOptionsWalletActionEndOptionsReasonEnum[keyof typeof WalletActionEndOptionsWalletActionEndOptionsReasonEnum];

/**
 * 
 */

export const WalletActionEndReason = {
    Cancel: 'CANCEL',
    Expiration: 'EXPIRATION'
} as const;

export type WalletActionEndReason = typeof WalletActionEndReason[keyof typeof WalletActionEndReason];


/**
 * 
 */
export interface WalletActionExceedsMaximumBalanceDetails {
    /**
     * WalletAction ID.
     */
    'walletActionId'?: string;
}
/**
 * 
 */
export interface WalletActionExecutionDetails {
    /**
     * ID of the Gift Card Transaction created by the WalletAction.
     */
    'transactionId'?: string;
    /**
     * Represents the time at which the WalletAction was executed.
     */
    'executionDate'?: string;
}
/**
 * Details about the WalletAction\'s execution, such as transaction ID and execution date. Set when the WalletAction is executed (e.g., when the amount is added to the account).
 */
export interface WalletActionExecutionDetails1 {
    /**
     * ID of the Gift Card Transaction created by the WalletAction.
     */
    'transactionId'?: string;
    /**
     * Represents the time at which the WalletAction was executed.
     */
    'executionDate'?: string;
}
/**
 * Details about the execution of the ending of the wallet action (due to expiration, disabling, etc), such as transaction ID and execution date. Set when the WalletAction is ended (i.e. when the amount is deducted from the account).
 */
export interface WalletActionExecutionDetails2 {
    /**
     * ID of the Gift Card Transaction created by the WalletAction.
     */
    'transactionId'?: string;
    /**
     * Represents the time at which the WalletAction was executed.
     */
    'executionDate'?: string;
}
/**
 * 
 */
export interface WalletActionIdempotencyKeyDetails {
    /**
     * Wallet Id
     */
    'walletId'?: string;
    /**
     * Idempotency Key
     */
    'idempotencyKey'?: string;
}
export interface WalletActionStartOptions {
    'walletActionStartOptions'?: WalletActionStartOptionsWalletActionStartOptions;
}
/**
 * Information about a transaction whose source is a wallet action (store credit) to a customer.
 */
export interface WalletActionStartOptionsWalletActionStartOptions {
    /**
     * ID of the wallet action.
     */
    'walletActionId'?: string;
    /**
     * Indicates whether the wallet action is a liability.
     */
    'liability'?: boolean;
    'context'?: StoreCreditContext2;
}
/**
 * 
 */

export const WalletActionStatus = {
    Pending: 'PENDING',
    Active: 'ACTIVE',
    Disabled: 'DISABLED',
    Expired: 'EXPIRED',
    Failed: 'FAILED'
} as const;

export type WalletActionStatus = typeof WalletActionStatus[keyof typeof WalletActionStatus];


/**
 * 
 */

export const WalletActionType = {
    Unknown: 'UNKNOWN',
    Reward: 'REWARD',
    Refund: 'REFUND'
} as const;

export type WalletActionType = typeof WalletActionType[keyof typeof WalletActionType];


/**
 * 
 */
export interface WalletActionUpdateExpirationDateInThePastDetails {
    /**
     * WalletAction ID.
     */
    'walletActionId'?: string;
    /**
     * The requested expiration date of the walletAction, which is in the past.
     */
    'newExpirationDate'?: string;
    /**
     * The current date.
     */
    'currentDate'?: string;
}
/**
 * 
 */
export interface WalletActionUpdateStartDateInThePastDetails {
    /**
     * WalletAction ID.
     */
    'walletActionId'?: string;
    /**
     * The requested start date of the walletAction, which is in the past.
     */
    'newStartDate'?: string;
    /**
     * The current date.
     */
    'currentDate'?: string;
}
/**
 * 
 */
export interface WalletActionUpdateStartLaterThanExpirationDetails {
    /**
     * WalletAction ID.
     */
    'walletActionId'?: string;
    /**
     * The requested start date of the walletAction, which is after the expiration date.
     */
    'startDate'?: string;
    /**
     * The date of the requested wallet action expiration, which is before the requested start date.
     */
    'expirationDate'?: string;
}
/**
 * 
 */
export interface WalletActionWalletActionServiceV1RiseWalletActionsByCustomerReferencePostCreateWalletActionByCustomerReferenceRequestBody {
    'customerReference': CustomerReference3;
    'walletAction': WalletAction7;
    /**
     * The currency for the new wallet, if no wallet already exists.
     */
    'newWalletCurrency'?: string;
}
/**
 * 
 */
export interface WalletActionWalletActionServiceV1RiseWalletActionsPostCreateWalletActionRequestBody {
    'walletAction': WalletAction6;
}
/**
 * 
 */
export interface WalletActionWalletActionServiceV1RiseWalletActionsQueryPostQueryWalletActionsRequestBody {
    'query': QueryV22;
}
/**
 * 
 */
export interface WalletActionWalletActionServiceV1RiseWalletActionsWalletActionIdDisablePostDisableWalletActionRequestBody {
    /**
     * The revision of the WalletAction.
     */
    'revision': string;
}
/**
 * 
 */
export interface WalletActionWalletActionServiceV1RiseWalletActionsWalletActionIdPatchUpdateWalletActionRequestBody {
    'walletAction': WalletAction8;
}
/**
 * WalletActionWithBalance an entity of WalletActionService that align a balance with WalletAction.
 */
export interface WalletActionWithBalance {
    /**
     * WalletAction.
     */
    'walletAction'?: object;
    /**
     * Remaining balance of the WalletAction.
     */
    'balance'?: string;
}
/**
 * WalletActionWithBalance an entity of WalletActionService that align a balance with WalletAction.
 */
export interface WalletActionWithBalance1 {
    'walletAction'?: WalletAction5;
    /**
     * Remaining balance of the WalletAction.
     */
    'balance'?: string;
}
/**
 * 
 */
export interface WalletWalletServiceV1RiseWalletsCountPostCountWalletsRequestBody {
    'filter'?: Filter3;
}
/**
 * 
 */
export interface WalletWalletServiceV1RiseWalletsIssuePostGetOrCreateWalletRequestBody {
    'customerReference': CustomerReference5;
    /**
     * Currency of the wallet.
     */
    'currency'?: string;
}
/**
 * 
 */
export interface WalletWalletServiceV1RiseWalletsPostCreateWalletRequestBody {
    'customerReference': CustomerReference4;
    /**
     * Initial amount of store credit.
     */
    'initialValue'?: string;
    /**
     * Currency of the wallet.
     */
    'currency'?: string;
}
/**
 * 
 */
export interface WalletWalletServiceV1RiseWalletsQueryByContactPostQueryWalletsByContactRequestBody {
    'query': QueryByContact1;
}
/**
 * 
 */

export const WebhookIdentityType = {
    Unknown: 'UNKNOWN',
    AnonymousVisitor: 'ANONYMOUS_VISITOR',
    Member: 'MEMBER',
    WixUser: 'WIX_USER',
    App: 'APP'
} as const;

export type WebhookIdentityType = typeof WebhookIdentityType[keyof typeof WebhookIdentityType];


export interface WorkflowOptions {
    'workflowOptions'?: WorkflowOptionsWorkflowOptions;
}
/**
 * Detailed information about a Gift Card issued from a workflow.
 */
export interface WorkflowOptionsWorkflowOptions {
    /**
     * ID of the workflow that issued the gift card.
     */
    'workflowId'?: string;
}
/**
 * 
 */
export interface WorkflowsEsbConfigResolverWorkflowsV1EventsReportPostReportEventRequestBody {
    /**
     * Trigger key as defined in your app\'s trigger configuration. For example, `order_returned` or `order_paid`.
     */
    'triggerKey': string;
    /**
     * Event payload, formatted as key:value pairs. Must comply with the payload schema if you provided one when configuring your trigger.  Key names can include only alphanumeric characters or underscores (`A-Z`, `a-z`, `0-9`, `_`). They cannot start with an underscore.  Values can be strings, numbers, integers, booleans, or arrays. If a value is an array, the array items must be objects, and nested object properties must be strings, numbers, integers, or booleans only.
     */
    'payload'?: object;
    /**
     * ID of the related resource in GUID format
     */
    'externalEntityId'?: string;
    'idempotency'?: Idempotency1;
}

/**
 * GiftCardApi - axios parameter creator
 */
export const GiftCardApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * TODO: change to Rise domain when it\'s ready Count GiftCards that match the given [API Query Language](https://platform.rise.ai/docs/#tag/About-API-Query-Language) filter.
         * @param {GiftCardGiftCardServiceV1RiseGiftCardsCountPostCountGiftCardsRequestBody} giftCardGiftCardServiceV1RiseGiftCardsCountPostCountGiftCardsRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        countGiftCards: async (giftCardGiftCardServiceV1RiseGiftCardsCountPostCountGiftCardsRequestBody: GiftCardGiftCardServiceV1RiseGiftCardsCountPostCountGiftCardsRequestBody, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'giftCardGiftCardServiceV1RiseGiftCardsCountPostCountGiftCardsRequestBody' is not null or undefined
            assertParamExists('countGiftCards', 'giftCardGiftCardServiceV1RiseGiftCardsCountPostCountGiftCardsRequestBody', giftCardGiftCardServiceV1RiseGiftCardsCountPostCountGiftCardsRequestBody)
            const localVarPath = `/v1/rise/gift-cards/count`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(giftCardGiftCardServiceV1RiseGiftCardsCountPostCountGiftCardsRequestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Creates a new GiftCard.
         * @param {GiftCardGiftCardServiceV1RiseGiftCardsPostCreateGiftCardRequestBody} giftCardGiftCardServiceV1RiseGiftCardsPostCreateGiftCardRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createGiftCard: async (giftCardGiftCardServiceV1RiseGiftCardsPostCreateGiftCardRequestBody: GiftCardGiftCardServiceV1RiseGiftCardsPostCreateGiftCardRequestBody, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'giftCardGiftCardServiceV1RiseGiftCardsPostCreateGiftCardRequestBody' is not null or undefined
            assertParamExists('createGiftCard', 'giftCardGiftCardServiceV1RiseGiftCardsPostCreateGiftCardRequestBody', giftCardGiftCardServiceV1RiseGiftCardsPostCreateGiftCardRequestBody)
            const localVarPath = `/v1/rise/gift-cards`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(giftCardGiftCardServiceV1RiseGiftCardsPostCreateGiftCardRequestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Subtracts from the GiftCard balance and creates a balance Transaction.
         * @param {string} transactionGiftCardId Unique ID of the gift card associated with this transaction.
         * @param {GiftCardGiftCardServiceV1RiseGiftCardsTransactionGiftCardIdIncreasePostIncreaseBalanceRequestBody} giftCardGiftCardServiceV1RiseGiftCardsTransactionGiftCardIdIncreasePostIncreaseBalanceRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        decreaseBalance: async (transactionGiftCardId: string, giftCardGiftCardServiceV1RiseGiftCardsTransactionGiftCardIdIncreasePostIncreaseBalanceRequestBody: GiftCardGiftCardServiceV1RiseGiftCardsTransactionGiftCardIdIncreasePostIncreaseBalanceRequestBody, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'transactionGiftCardId' is not null or undefined
            assertParamExists('decreaseBalance', 'transactionGiftCardId', transactionGiftCardId)
            // verify required parameter 'giftCardGiftCardServiceV1RiseGiftCardsTransactionGiftCardIdIncreasePostIncreaseBalanceRequestBody' is not null or undefined
            assertParamExists('decreaseBalance', 'giftCardGiftCardServiceV1RiseGiftCardsTransactionGiftCardIdIncreasePostIncreaseBalanceRequestBody', giftCardGiftCardServiceV1RiseGiftCardsTransactionGiftCardIdIncreasePostIncreaseBalanceRequestBody)
            const localVarPath = `/v1/rise/gift-cards/{transactionGiftCardId}/decrease`
                .replace(`{${"transactionGiftCardId"}}`, encodeURIComponent(String(transactionGiftCardId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(giftCardGiftCardServiceV1RiseGiftCardsTransactionGiftCardIdIncreasePostIncreaseBalanceRequestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Disable a GiftCard. It cannot be re-enabled.
         * @param {string} giftCardId The ID of the GiftCard to disable.
         * @param {object} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        disableGiftCard: async (giftCardId: string, body: object, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'giftCardId' is not null or undefined
            assertParamExists('disableGiftCard', 'giftCardId', giftCardId)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('disableGiftCard', 'body', body)
            const localVarPath = `/v1/rise/gift-cards/{giftCardId}/disable`
                .replace(`{${"giftCardId"}}`, encodeURIComponent(String(giftCardId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a GiftCard by ID.
         * @param {string} giftCardId The ID of the GiftCard to retrieve.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGiftCard: async (giftCardId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'giftCardId' is not null or undefined
            assertParamExists('getGiftCard', 'giftCardId', giftCardId)
            const localVarPath = `/v1/rise/gift-cards/{giftCardId}`
                .replace(`{${"giftCardId"}}`, encodeURIComponent(String(giftCardId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Adds to the GiftCard balance and creates a balance Transaction.
         * @param {string} transactionGiftCardId Unique ID of the gift card associated with this transaction.
         * @param {GiftCardGiftCardServiceV1RiseGiftCardsTransactionGiftCardIdIncreasePostIncreaseBalanceRequestBody} giftCardGiftCardServiceV1RiseGiftCardsTransactionGiftCardIdIncreasePostIncreaseBalanceRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        increaseBalance: async (transactionGiftCardId: string, giftCardGiftCardServiceV1RiseGiftCardsTransactionGiftCardIdIncreasePostIncreaseBalanceRequestBody: GiftCardGiftCardServiceV1RiseGiftCardsTransactionGiftCardIdIncreasePostIncreaseBalanceRequestBody, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'transactionGiftCardId' is not null or undefined
            assertParamExists('increaseBalance', 'transactionGiftCardId', transactionGiftCardId)
            // verify required parameter 'giftCardGiftCardServiceV1RiseGiftCardsTransactionGiftCardIdIncreasePostIncreaseBalanceRequestBody' is not null or undefined
            assertParamExists('increaseBalance', 'giftCardGiftCardServiceV1RiseGiftCardsTransactionGiftCardIdIncreasePostIncreaseBalanceRequestBody', giftCardGiftCardServiceV1RiseGiftCardsTransactionGiftCardIdIncreasePostIncreaseBalanceRequestBody)
            const localVarPath = `/v1/rise/gift-cards/{transactionGiftCardId}/increase`
                .replace(`{${"transactionGiftCardId"}}`, encodeURIComponent(String(transactionGiftCardId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(giftCardGiftCardServiceV1RiseGiftCardsTransactionGiftCardIdIncreasePostIncreaseBalanceRequestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Query GiftCards using [API Query Language](https://platform.rise.ai/docs/#tag/About-API-Query-Language).
         * @param {GiftCardGiftCardServiceV1RiseGiftCardsQueryPostQueryGiftCardsRequestBody} giftCardGiftCardServiceV1RiseGiftCardsQueryPostQueryGiftCardsRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        queryGiftCards: async (giftCardGiftCardServiceV1RiseGiftCardsQueryPostQueryGiftCardsRequestBody: GiftCardGiftCardServiceV1RiseGiftCardsQueryPostQueryGiftCardsRequestBody, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'giftCardGiftCardServiceV1RiseGiftCardsQueryPostQueryGiftCardsRequestBody' is not null or undefined
            assertParamExists('queryGiftCards', 'giftCardGiftCardServiceV1RiseGiftCardsQueryPostQueryGiftCardsRequestBody', giftCardGiftCardServiceV1RiseGiftCardsQueryPostQueryGiftCardsRequestBody)
            const localVarPath = `/v1/rise/gift-cards/query`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(giftCardGiftCardServiceV1RiseGiftCardsQueryPostQueryGiftCardsRequestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Search for GiftCards by field.
         * @param {GiftCardGiftCardServiceV1RiseGiftCardsSearchPostSearchGiftCardsRequestBody} giftCardGiftCardServiceV1RiseGiftCardsSearchPostSearchGiftCardsRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchGiftCards: async (giftCardGiftCardServiceV1RiseGiftCardsSearchPostSearchGiftCardsRequestBody: GiftCardGiftCardServiceV1RiseGiftCardsSearchPostSearchGiftCardsRequestBody, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'giftCardGiftCardServiceV1RiseGiftCardsSearchPostSearchGiftCardsRequestBody' is not null or undefined
            assertParamExists('searchGiftCards', 'giftCardGiftCardServiceV1RiseGiftCardsSearchPostSearchGiftCardsRequestBody', giftCardGiftCardServiceV1RiseGiftCardsSearchPostSearchGiftCardsRequestBody)
            const localVarPath = `/v1/rise/gift-cards/search`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(giftCardGiftCardServiceV1RiseGiftCardsSearchPostSearchGiftCardsRequestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update a GiftCard, supports partial update. Pass the latest `revision` for a successful update.
         * @param {string} giftCardId The ID of the GiftCard to update.
         * @param {GiftCardGiftCardServiceV1RiseGiftCardsGiftCardIdPatchUpdateGiftCardRequestBody} giftCardGiftCardServiceV1RiseGiftCardsGiftCardIdPatchUpdateGiftCardRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateGiftCard: async (giftCardId: string, giftCardGiftCardServiceV1RiseGiftCardsGiftCardIdPatchUpdateGiftCardRequestBody: GiftCardGiftCardServiceV1RiseGiftCardsGiftCardIdPatchUpdateGiftCardRequestBody, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'giftCardId' is not null or undefined
            assertParamExists('updateGiftCard', 'giftCardId', giftCardId)
            // verify required parameter 'giftCardGiftCardServiceV1RiseGiftCardsGiftCardIdPatchUpdateGiftCardRequestBody' is not null or undefined
            assertParamExists('updateGiftCard', 'giftCardGiftCardServiceV1RiseGiftCardsGiftCardIdPatchUpdateGiftCardRequestBody', giftCardGiftCardServiceV1RiseGiftCardsGiftCardIdPatchUpdateGiftCardRequestBody)
            const localVarPath = `/v1/rise/gift-cards/{giftCardId}`
                .replace(`{${"giftCardId"}}`, encodeURIComponent(String(giftCardId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(giftCardGiftCardServiceV1RiseGiftCardsGiftCardIdPatchUpdateGiftCardRequestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * GiftCardApi - functional programming interface
 */
export const GiftCardApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = GiftCardApiAxiosParamCreator(configuration)
    return {
        /**
         * TODO: change to Rise domain when it\'s ready Count GiftCards that match the given [API Query Language](https://platform.rise.ai/docs/#tag/About-API-Query-Language) filter.
         * @param {GiftCardGiftCardServiceV1RiseGiftCardsCountPostCountGiftCardsRequestBody} giftCardGiftCardServiceV1RiseGiftCardsCountPostCountGiftCardsRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async countGiftCards(giftCardGiftCardServiceV1RiseGiftCardsCountPostCountGiftCardsRequestBody: GiftCardGiftCardServiceV1RiseGiftCardsCountPostCountGiftCardsRequestBody, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CountGiftCardsResponse1>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.countGiftCards(giftCardGiftCardServiceV1RiseGiftCardsCountPostCountGiftCardsRequestBody, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GiftCardApi.countGiftCards']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Creates a new GiftCard.
         * @param {GiftCardGiftCardServiceV1RiseGiftCardsPostCreateGiftCardRequestBody} giftCardGiftCardServiceV1RiseGiftCardsPostCreateGiftCardRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createGiftCard(giftCardGiftCardServiceV1RiseGiftCardsPostCreateGiftCardRequestBody: GiftCardGiftCardServiceV1RiseGiftCardsPostCreateGiftCardRequestBody, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateGiftCardResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createGiftCard(giftCardGiftCardServiceV1RiseGiftCardsPostCreateGiftCardRequestBody, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GiftCardApi.createGiftCard']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Subtracts from the GiftCard balance and creates a balance Transaction.
         * @param {string} transactionGiftCardId Unique ID of the gift card associated with this transaction.
         * @param {GiftCardGiftCardServiceV1RiseGiftCardsTransactionGiftCardIdIncreasePostIncreaseBalanceRequestBody} giftCardGiftCardServiceV1RiseGiftCardsTransactionGiftCardIdIncreasePostIncreaseBalanceRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async decreaseBalance(transactionGiftCardId: string, giftCardGiftCardServiceV1RiseGiftCardsTransactionGiftCardIdIncreasePostIncreaseBalanceRequestBody: GiftCardGiftCardServiceV1RiseGiftCardsTransactionGiftCardIdIncreasePostIncreaseBalanceRequestBody, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DecreaseBalanceResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.decreaseBalance(transactionGiftCardId, giftCardGiftCardServiceV1RiseGiftCardsTransactionGiftCardIdIncreasePostIncreaseBalanceRequestBody, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GiftCardApi.decreaseBalance']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Disable a GiftCard. It cannot be re-enabled.
         * @param {string} giftCardId The ID of the GiftCard to disable.
         * @param {object} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async disableGiftCard(giftCardId: string, body: object, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DisableGiftCardResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.disableGiftCard(giftCardId, body, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GiftCardApi.disableGiftCard']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get a GiftCard by ID.
         * @param {string} giftCardId The ID of the GiftCard to retrieve.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getGiftCard(giftCardId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetGiftCardResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getGiftCard(giftCardId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GiftCardApi.getGiftCard']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Adds to the GiftCard balance and creates a balance Transaction.
         * @param {string} transactionGiftCardId Unique ID of the gift card associated with this transaction.
         * @param {GiftCardGiftCardServiceV1RiseGiftCardsTransactionGiftCardIdIncreasePostIncreaseBalanceRequestBody} giftCardGiftCardServiceV1RiseGiftCardsTransactionGiftCardIdIncreasePostIncreaseBalanceRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async increaseBalance(transactionGiftCardId: string, giftCardGiftCardServiceV1RiseGiftCardsTransactionGiftCardIdIncreasePostIncreaseBalanceRequestBody: GiftCardGiftCardServiceV1RiseGiftCardsTransactionGiftCardIdIncreasePostIncreaseBalanceRequestBody, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<IncreaseBalanceResponse1>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.increaseBalance(transactionGiftCardId, giftCardGiftCardServiceV1RiseGiftCardsTransactionGiftCardIdIncreasePostIncreaseBalanceRequestBody, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GiftCardApi.increaseBalance']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Query GiftCards using [API Query Language](https://platform.rise.ai/docs/#tag/About-API-Query-Language).
         * @param {GiftCardGiftCardServiceV1RiseGiftCardsQueryPostQueryGiftCardsRequestBody} giftCardGiftCardServiceV1RiseGiftCardsQueryPostQueryGiftCardsRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async queryGiftCards(giftCardGiftCardServiceV1RiseGiftCardsQueryPostQueryGiftCardsRequestBody: GiftCardGiftCardServiceV1RiseGiftCardsQueryPostQueryGiftCardsRequestBody, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<QueryGiftCardsResponse1>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.queryGiftCards(giftCardGiftCardServiceV1RiseGiftCardsQueryPostQueryGiftCardsRequestBody, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GiftCardApi.queryGiftCards']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Search for GiftCards by field.
         * @param {GiftCardGiftCardServiceV1RiseGiftCardsSearchPostSearchGiftCardsRequestBody} giftCardGiftCardServiceV1RiseGiftCardsSearchPostSearchGiftCardsRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async searchGiftCards(giftCardGiftCardServiceV1RiseGiftCardsSearchPostSearchGiftCardsRequestBody: GiftCardGiftCardServiceV1RiseGiftCardsSearchPostSearchGiftCardsRequestBody, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SearchGiftCardsResponse1>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.searchGiftCards(giftCardGiftCardServiceV1RiseGiftCardsSearchPostSearchGiftCardsRequestBody, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GiftCardApi.searchGiftCards']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update a GiftCard, supports partial update. Pass the latest `revision` for a successful update.
         * @param {string} giftCardId The ID of the GiftCard to update.
         * @param {GiftCardGiftCardServiceV1RiseGiftCardsGiftCardIdPatchUpdateGiftCardRequestBody} giftCardGiftCardServiceV1RiseGiftCardsGiftCardIdPatchUpdateGiftCardRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateGiftCard(giftCardId: string, giftCardGiftCardServiceV1RiseGiftCardsGiftCardIdPatchUpdateGiftCardRequestBody: GiftCardGiftCardServiceV1RiseGiftCardsGiftCardIdPatchUpdateGiftCardRequestBody, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UpdateGiftCardResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateGiftCard(giftCardId, giftCardGiftCardServiceV1RiseGiftCardsGiftCardIdPatchUpdateGiftCardRequestBody, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GiftCardApi.updateGiftCard']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * GiftCardApi - factory interface
 */
export const GiftCardApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = GiftCardApiFp(configuration)
    return {
        /**
         * TODO: change to Rise domain when it\'s ready Count GiftCards that match the given [API Query Language](https://platform.rise.ai/docs/#tag/About-API-Query-Language) filter.
         * @param {GiftCardGiftCardServiceV1RiseGiftCardsCountPostCountGiftCardsRequestBody} giftCardGiftCardServiceV1RiseGiftCardsCountPostCountGiftCardsRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        countGiftCards(giftCardGiftCardServiceV1RiseGiftCardsCountPostCountGiftCardsRequestBody: GiftCardGiftCardServiceV1RiseGiftCardsCountPostCountGiftCardsRequestBody, options?: RawAxiosRequestConfig): AxiosPromise<CountGiftCardsResponse1> {
            return localVarFp.countGiftCards(giftCardGiftCardServiceV1RiseGiftCardsCountPostCountGiftCardsRequestBody, options).then((request) => request(axios, basePath));
        },
        /**
         * Creates a new GiftCard.
         * @param {GiftCardGiftCardServiceV1RiseGiftCardsPostCreateGiftCardRequestBody} giftCardGiftCardServiceV1RiseGiftCardsPostCreateGiftCardRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createGiftCard(giftCardGiftCardServiceV1RiseGiftCardsPostCreateGiftCardRequestBody: GiftCardGiftCardServiceV1RiseGiftCardsPostCreateGiftCardRequestBody, options?: RawAxiosRequestConfig): AxiosPromise<CreateGiftCardResponse> {
            return localVarFp.createGiftCard(giftCardGiftCardServiceV1RiseGiftCardsPostCreateGiftCardRequestBody, options).then((request) => request(axios, basePath));
        },
        /**
         * Subtracts from the GiftCard balance and creates a balance Transaction.
         * @param {string} transactionGiftCardId Unique ID of the gift card associated with this transaction.
         * @param {GiftCardGiftCardServiceV1RiseGiftCardsTransactionGiftCardIdIncreasePostIncreaseBalanceRequestBody} giftCardGiftCardServiceV1RiseGiftCardsTransactionGiftCardIdIncreasePostIncreaseBalanceRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        decreaseBalance(transactionGiftCardId: string, giftCardGiftCardServiceV1RiseGiftCardsTransactionGiftCardIdIncreasePostIncreaseBalanceRequestBody: GiftCardGiftCardServiceV1RiseGiftCardsTransactionGiftCardIdIncreasePostIncreaseBalanceRequestBody, options?: RawAxiosRequestConfig): AxiosPromise<DecreaseBalanceResponse> {
            return localVarFp.decreaseBalance(transactionGiftCardId, giftCardGiftCardServiceV1RiseGiftCardsTransactionGiftCardIdIncreasePostIncreaseBalanceRequestBody, options).then((request) => request(axios, basePath));
        },
        /**
         * Disable a GiftCard. It cannot be re-enabled.
         * @param {string} giftCardId The ID of the GiftCard to disable.
         * @param {object} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        disableGiftCard(giftCardId: string, body: object, options?: RawAxiosRequestConfig): AxiosPromise<DisableGiftCardResponse> {
            return localVarFp.disableGiftCard(giftCardId, body, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a GiftCard by ID.
         * @param {string} giftCardId The ID of the GiftCard to retrieve.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGiftCard(giftCardId: string, options?: RawAxiosRequestConfig): AxiosPromise<GetGiftCardResponse> {
            return localVarFp.getGiftCard(giftCardId, options).then((request) => request(axios, basePath));
        },
        /**
         * Adds to the GiftCard balance and creates a balance Transaction.
         * @param {string} transactionGiftCardId Unique ID of the gift card associated with this transaction.
         * @param {GiftCardGiftCardServiceV1RiseGiftCardsTransactionGiftCardIdIncreasePostIncreaseBalanceRequestBody} giftCardGiftCardServiceV1RiseGiftCardsTransactionGiftCardIdIncreasePostIncreaseBalanceRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        increaseBalance(transactionGiftCardId: string, giftCardGiftCardServiceV1RiseGiftCardsTransactionGiftCardIdIncreasePostIncreaseBalanceRequestBody: GiftCardGiftCardServiceV1RiseGiftCardsTransactionGiftCardIdIncreasePostIncreaseBalanceRequestBody, options?: RawAxiosRequestConfig): AxiosPromise<IncreaseBalanceResponse1> {
            return localVarFp.increaseBalance(transactionGiftCardId, giftCardGiftCardServiceV1RiseGiftCardsTransactionGiftCardIdIncreasePostIncreaseBalanceRequestBody, options).then((request) => request(axios, basePath));
        },
        /**
         * Query GiftCards using [API Query Language](https://platform.rise.ai/docs/#tag/About-API-Query-Language).
         * @param {GiftCardGiftCardServiceV1RiseGiftCardsQueryPostQueryGiftCardsRequestBody} giftCardGiftCardServiceV1RiseGiftCardsQueryPostQueryGiftCardsRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        queryGiftCards(giftCardGiftCardServiceV1RiseGiftCardsQueryPostQueryGiftCardsRequestBody: GiftCardGiftCardServiceV1RiseGiftCardsQueryPostQueryGiftCardsRequestBody, options?: RawAxiosRequestConfig): AxiosPromise<QueryGiftCardsResponse1> {
            return localVarFp.queryGiftCards(giftCardGiftCardServiceV1RiseGiftCardsQueryPostQueryGiftCardsRequestBody, options).then((request) => request(axios, basePath));
        },
        /**
         * Search for GiftCards by field.
         * @param {GiftCardGiftCardServiceV1RiseGiftCardsSearchPostSearchGiftCardsRequestBody} giftCardGiftCardServiceV1RiseGiftCardsSearchPostSearchGiftCardsRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchGiftCards(giftCardGiftCardServiceV1RiseGiftCardsSearchPostSearchGiftCardsRequestBody: GiftCardGiftCardServiceV1RiseGiftCardsSearchPostSearchGiftCardsRequestBody, options?: RawAxiosRequestConfig): AxiosPromise<SearchGiftCardsResponse1> {
            return localVarFp.searchGiftCards(giftCardGiftCardServiceV1RiseGiftCardsSearchPostSearchGiftCardsRequestBody, options).then((request) => request(axios, basePath));
        },
        /**
         * Update a GiftCard, supports partial update. Pass the latest `revision` for a successful update.
         * @param {string} giftCardId The ID of the GiftCard to update.
         * @param {GiftCardGiftCardServiceV1RiseGiftCardsGiftCardIdPatchUpdateGiftCardRequestBody} giftCardGiftCardServiceV1RiseGiftCardsGiftCardIdPatchUpdateGiftCardRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateGiftCard(giftCardId: string, giftCardGiftCardServiceV1RiseGiftCardsGiftCardIdPatchUpdateGiftCardRequestBody: GiftCardGiftCardServiceV1RiseGiftCardsGiftCardIdPatchUpdateGiftCardRequestBody, options?: RawAxiosRequestConfig): AxiosPromise<UpdateGiftCardResponse> {
            return localVarFp.updateGiftCard(giftCardId, giftCardGiftCardServiceV1RiseGiftCardsGiftCardIdPatchUpdateGiftCardRequestBody, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * GiftCardApi - object-oriented interface
 */
export class GiftCardApi extends BaseAPI {
    /**
     * TODO: change to Rise domain when it\'s ready Count GiftCards that match the given [API Query Language](https://platform.rise.ai/docs/#tag/About-API-Query-Language) filter.
     * @param {GiftCardGiftCardServiceV1RiseGiftCardsCountPostCountGiftCardsRequestBody} giftCardGiftCardServiceV1RiseGiftCardsCountPostCountGiftCardsRequestBody 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public countGiftCards(giftCardGiftCardServiceV1RiseGiftCardsCountPostCountGiftCardsRequestBody: GiftCardGiftCardServiceV1RiseGiftCardsCountPostCountGiftCardsRequestBody, options?: RawAxiosRequestConfig) {
        return GiftCardApiFp(this.configuration).countGiftCards(giftCardGiftCardServiceV1RiseGiftCardsCountPostCountGiftCardsRequestBody, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Creates a new GiftCard.
     * @param {GiftCardGiftCardServiceV1RiseGiftCardsPostCreateGiftCardRequestBody} giftCardGiftCardServiceV1RiseGiftCardsPostCreateGiftCardRequestBody 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public createGiftCard(giftCardGiftCardServiceV1RiseGiftCardsPostCreateGiftCardRequestBody: GiftCardGiftCardServiceV1RiseGiftCardsPostCreateGiftCardRequestBody, options?: RawAxiosRequestConfig) {
        return GiftCardApiFp(this.configuration).createGiftCard(giftCardGiftCardServiceV1RiseGiftCardsPostCreateGiftCardRequestBody, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Subtracts from the GiftCard balance and creates a balance Transaction.
     * @param {string} transactionGiftCardId Unique ID of the gift card associated with this transaction.
     * @param {GiftCardGiftCardServiceV1RiseGiftCardsTransactionGiftCardIdIncreasePostIncreaseBalanceRequestBody} giftCardGiftCardServiceV1RiseGiftCardsTransactionGiftCardIdIncreasePostIncreaseBalanceRequestBody 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public decreaseBalance(transactionGiftCardId: string, giftCardGiftCardServiceV1RiseGiftCardsTransactionGiftCardIdIncreasePostIncreaseBalanceRequestBody: GiftCardGiftCardServiceV1RiseGiftCardsTransactionGiftCardIdIncreasePostIncreaseBalanceRequestBody, options?: RawAxiosRequestConfig) {
        return GiftCardApiFp(this.configuration).decreaseBalance(transactionGiftCardId, giftCardGiftCardServiceV1RiseGiftCardsTransactionGiftCardIdIncreasePostIncreaseBalanceRequestBody, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Disable a GiftCard. It cannot be re-enabled.
     * @param {string} giftCardId The ID of the GiftCard to disable.
     * @param {object} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public disableGiftCard(giftCardId: string, body: object, options?: RawAxiosRequestConfig) {
        return GiftCardApiFp(this.configuration).disableGiftCard(giftCardId, body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a GiftCard by ID.
     * @param {string} giftCardId The ID of the GiftCard to retrieve.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getGiftCard(giftCardId: string, options?: RawAxiosRequestConfig) {
        return GiftCardApiFp(this.configuration).getGiftCard(giftCardId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Adds to the GiftCard balance and creates a balance Transaction.
     * @param {string} transactionGiftCardId Unique ID of the gift card associated with this transaction.
     * @param {GiftCardGiftCardServiceV1RiseGiftCardsTransactionGiftCardIdIncreasePostIncreaseBalanceRequestBody} giftCardGiftCardServiceV1RiseGiftCardsTransactionGiftCardIdIncreasePostIncreaseBalanceRequestBody 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public increaseBalance(transactionGiftCardId: string, giftCardGiftCardServiceV1RiseGiftCardsTransactionGiftCardIdIncreasePostIncreaseBalanceRequestBody: GiftCardGiftCardServiceV1RiseGiftCardsTransactionGiftCardIdIncreasePostIncreaseBalanceRequestBody, options?: RawAxiosRequestConfig) {
        return GiftCardApiFp(this.configuration).increaseBalance(transactionGiftCardId, giftCardGiftCardServiceV1RiseGiftCardsTransactionGiftCardIdIncreasePostIncreaseBalanceRequestBody, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Query GiftCards using [API Query Language](https://platform.rise.ai/docs/#tag/About-API-Query-Language).
     * @param {GiftCardGiftCardServiceV1RiseGiftCardsQueryPostQueryGiftCardsRequestBody} giftCardGiftCardServiceV1RiseGiftCardsQueryPostQueryGiftCardsRequestBody 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public queryGiftCards(giftCardGiftCardServiceV1RiseGiftCardsQueryPostQueryGiftCardsRequestBody: GiftCardGiftCardServiceV1RiseGiftCardsQueryPostQueryGiftCardsRequestBody, options?: RawAxiosRequestConfig) {
        return GiftCardApiFp(this.configuration).queryGiftCards(giftCardGiftCardServiceV1RiseGiftCardsQueryPostQueryGiftCardsRequestBody, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Search for GiftCards by field.
     * @param {GiftCardGiftCardServiceV1RiseGiftCardsSearchPostSearchGiftCardsRequestBody} giftCardGiftCardServiceV1RiseGiftCardsSearchPostSearchGiftCardsRequestBody 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public searchGiftCards(giftCardGiftCardServiceV1RiseGiftCardsSearchPostSearchGiftCardsRequestBody: GiftCardGiftCardServiceV1RiseGiftCardsSearchPostSearchGiftCardsRequestBody, options?: RawAxiosRequestConfig) {
        return GiftCardApiFp(this.configuration).searchGiftCards(giftCardGiftCardServiceV1RiseGiftCardsSearchPostSearchGiftCardsRequestBody, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update a GiftCard, supports partial update. Pass the latest `revision` for a successful update.
     * @param {string} giftCardId The ID of the GiftCard to update.
     * @param {GiftCardGiftCardServiceV1RiseGiftCardsGiftCardIdPatchUpdateGiftCardRequestBody} giftCardGiftCardServiceV1RiseGiftCardsGiftCardIdPatchUpdateGiftCardRequestBody 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public updateGiftCard(giftCardId: string, giftCardGiftCardServiceV1RiseGiftCardsGiftCardIdPatchUpdateGiftCardRequestBody: GiftCardGiftCardServiceV1RiseGiftCardsGiftCardIdPatchUpdateGiftCardRequestBody, options?: RawAxiosRequestConfig) {
        return GiftCardApiFp(this.configuration).updateGiftCard(giftCardId, giftCardGiftCardServiceV1RiseGiftCardsGiftCardIdPatchUpdateGiftCardRequestBody, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * GiftCardOrderApi - axios parameter creator
 */
export const GiftCardOrderApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Creates an Order for a Rise Gift Card.
         * @param {GiftCardOrderGiftCardOrderServiceV1RiseOrdersPostCreateOrderRequestBody} giftCardOrderGiftCardOrderServiceV1RiseOrdersPostCreateOrderRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createOrder: async (giftCardOrderGiftCardOrderServiceV1RiseOrdersPostCreateOrderRequestBody: GiftCardOrderGiftCardOrderServiceV1RiseOrdersPostCreateOrderRequestBody, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'giftCardOrderGiftCardOrderServiceV1RiseOrdersPostCreateOrderRequestBody' is not null or undefined
            assertParamExists('createOrder', 'giftCardOrderGiftCardOrderServiceV1RiseOrdersPostCreateOrderRequestBody', giftCardOrderGiftCardOrderServiceV1RiseOrdersPostCreateOrderRequestBody)
            const localVarPath = `/v1/rise/orders`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(giftCardOrderGiftCardOrderServiceV1RiseOrdersPostCreateOrderRequestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Fulfills an order in an async manner.
         * @param {GiftCardOrderGiftCardOrderServiceV1RiseOrdersFulfillPostFulfillOrderRequestBody} giftCardOrderGiftCardOrderServiceV1RiseOrdersFulfillPostFulfillOrderRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fulfillOrder: async (giftCardOrderGiftCardOrderServiceV1RiseOrdersFulfillPostFulfillOrderRequestBody: GiftCardOrderGiftCardOrderServiceV1RiseOrdersFulfillPostFulfillOrderRequestBody, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'giftCardOrderGiftCardOrderServiceV1RiseOrdersFulfillPostFulfillOrderRequestBody' is not null or undefined
            assertParamExists('fulfillOrder', 'giftCardOrderGiftCardOrderServiceV1RiseOrdersFulfillPostFulfillOrderRequestBody', giftCardOrderGiftCardOrderServiceV1RiseOrdersFulfillPostFulfillOrderRequestBody)
            const localVarPath = `/v1/rise/orders/fulfill`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(giftCardOrderGiftCardOrderServiceV1RiseOrdersFulfillPostFulfillOrderRequestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves a list of Orders, given the provided paging, filtering, and sorting]. Up to 1,000 Orders can be returned per request. To learn how to query Orders, see [API Query Language](https://platform.rise.ai/docs/#tag/About-API-Query-Language).
         * @param {GiftCardOrderGiftCardOrderServiceV1RiseOrdersQueryPostQueryOrdersRequestBody} giftCardOrderGiftCardOrderServiceV1RiseOrdersQueryPostQueryOrdersRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        queryOrders: async (giftCardOrderGiftCardOrderServiceV1RiseOrdersQueryPostQueryOrdersRequestBody: GiftCardOrderGiftCardOrderServiceV1RiseOrdersQueryPostQueryOrdersRequestBody, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'giftCardOrderGiftCardOrderServiceV1RiseOrdersQueryPostQueryOrdersRequestBody' is not null or undefined
            assertParamExists('queryOrders', 'giftCardOrderGiftCardOrderServiceV1RiseOrdersQueryPostQueryOrdersRequestBody', giftCardOrderGiftCardOrderServiceV1RiseOrdersQueryPostQueryOrdersRequestBody)
            const localVarPath = `/v1/rise/orders/query`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(giftCardOrderGiftCardOrderServiceV1RiseOrdersQueryPostQueryOrdersRequestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates a Rise Gift Card Order.
         * @param {string} orderId Order ID.
         * @param {GiftCardOrderGiftCardOrderServiceV1RiseOrdersOrderIdPatchUpdateOrderRequestBody} giftCardOrderGiftCardOrderServiceV1RiseOrdersOrderIdPatchUpdateOrderRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateOrder: async (orderId: string, giftCardOrderGiftCardOrderServiceV1RiseOrdersOrderIdPatchUpdateOrderRequestBody: GiftCardOrderGiftCardOrderServiceV1RiseOrdersOrderIdPatchUpdateOrderRequestBody, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orderId' is not null or undefined
            assertParamExists('updateOrder', 'orderId', orderId)
            // verify required parameter 'giftCardOrderGiftCardOrderServiceV1RiseOrdersOrderIdPatchUpdateOrderRequestBody' is not null or undefined
            assertParamExists('updateOrder', 'giftCardOrderGiftCardOrderServiceV1RiseOrdersOrderIdPatchUpdateOrderRequestBody', giftCardOrderGiftCardOrderServiceV1RiseOrdersOrderIdPatchUpdateOrderRequestBody)
            const localVarPath = `/v1/rise/orders/{orderId}`
                .replace(`{${"orderId"}}`, encodeURIComponent(String(orderId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(giftCardOrderGiftCardOrderServiceV1RiseOrdersOrderIdPatchUpdateOrderRequestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates order payment status and fulfills it accordingly, in an async manner.
         * @param {GiftCardOrderGiftCardOrderServiceV1RiseOrdersStatusPostUpdateOrderStatusRequestBody} giftCardOrderGiftCardOrderServiceV1RiseOrdersStatusPostUpdateOrderStatusRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateOrderStatus: async (giftCardOrderGiftCardOrderServiceV1RiseOrdersStatusPostUpdateOrderStatusRequestBody: GiftCardOrderGiftCardOrderServiceV1RiseOrdersStatusPostUpdateOrderStatusRequestBody, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'giftCardOrderGiftCardOrderServiceV1RiseOrdersStatusPostUpdateOrderStatusRequestBody' is not null or undefined
            assertParamExists('updateOrderStatus', 'giftCardOrderGiftCardOrderServiceV1RiseOrdersStatusPostUpdateOrderStatusRequestBody', giftCardOrderGiftCardOrderServiceV1RiseOrdersStatusPostUpdateOrderStatusRequestBody)
            const localVarPath = `/v1/rise/orders/status`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(giftCardOrderGiftCardOrderServiceV1RiseOrdersStatusPostUpdateOrderStatusRequestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * GiftCardOrderApi - functional programming interface
 */
export const GiftCardOrderApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = GiftCardOrderApiAxiosParamCreator(configuration)
    return {
        /**
         * Creates an Order for a Rise Gift Card.
         * @param {GiftCardOrderGiftCardOrderServiceV1RiseOrdersPostCreateOrderRequestBody} giftCardOrderGiftCardOrderServiceV1RiseOrdersPostCreateOrderRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createOrder(giftCardOrderGiftCardOrderServiceV1RiseOrdersPostCreateOrderRequestBody: GiftCardOrderGiftCardOrderServiceV1RiseOrdersPostCreateOrderRequestBody, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateOrderResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createOrder(giftCardOrderGiftCardOrderServiceV1RiseOrdersPostCreateOrderRequestBody, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GiftCardOrderApi.createOrder']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Fulfills an order in an async manner.
         * @param {GiftCardOrderGiftCardOrderServiceV1RiseOrdersFulfillPostFulfillOrderRequestBody} giftCardOrderGiftCardOrderServiceV1RiseOrdersFulfillPostFulfillOrderRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async fulfillOrder(giftCardOrderGiftCardOrderServiceV1RiseOrdersFulfillPostFulfillOrderRequestBody: GiftCardOrderGiftCardOrderServiceV1RiseOrdersFulfillPostFulfillOrderRequestBody, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.fulfillOrder(giftCardOrderGiftCardOrderServiceV1RiseOrdersFulfillPostFulfillOrderRequestBody, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GiftCardOrderApi.fulfillOrder']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieves a list of Orders, given the provided paging, filtering, and sorting]. Up to 1,000 Orders can be returned per request. To learn how to query Orders, see [API Query Language](https://platform.rise.ai/docs/#tag/About-API-Query-Language).
         * @param {GiftCardOrderGiftCardOrderServiceV1RiseOrdersQueryPostQueryOrdersRequestBody} giftCardOrderGiftCardOrderServiceV1RiseOrdersQueryPostQueryOrdersRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async queryOrders(giftCardOrderGiftCardOrderServiceV1RiseOrdersQueryPostQueryOrdersRequestBody: GiftCardOrderGiftCardOrderServiceV1RiseOrdersQueryPostQueryOrdersRequestBody, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<QueryOrdersResponse1>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.queryOrders(giftCardOrderGiftCardOrderServiceV1RiseOrdersQueryPostQueryOrdersRequestBody, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GiftCardOrderApi.queryOrders']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Updates a Rise Gift Card Order.
         * @param {string} orderId Order ID.
         * @param {GiftCardOrderGiftCardOrderServiceV1RiseOrdersOrderIdPatchUpdateOrderRequestBody} giftCardOrderGiftCardOrderServiceV1RiseOrdersOrderIdPatchUpdateOrderRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateOrder(orderId: string, giftCardOrderGiftCardOrderServiceV1RiseOrdersOrderIdPatchUpdateOrderRequestBody: GiftCardOrderGiftCardOrderServiceV1RiseOrdersOrderIdPatchUpdateOrderRequestBody, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UpdateOrderResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateOrder(orderId, giftCardOrderGiftCardOrderServiceV1RiseOrdersOrderIdPatchUpdateOrderRequestBody, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GiftCardOrderApi.updateOrder']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Updates order payment status and fulfills it accordingly, in an async manner.
         * @param {GiftCardOrderGiftCardOrderServiceV1RiseOrdersStatusPostUpdateOrderStatusRequestBody} giftCardOrderGiftCardOrderServiceV1RiseOrdersStatusPostUpdateOrderStatusRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateOrderStatus(giftCardOrderGiftCardOrderServiceV1RiseOrdersStatusPostUpdateOrderStatusRequestBody: GiftCardOrderGiftCardOrderServiceV1RiseOrdersStatusPostUpdateOrderStatusRequestBody, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateOrderStatus(giftCardOrderGiftCardOrderServiceV1RiseOrdersStatusPostUpdateOrderStatusRequestBody, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GiftCardOrderApi.updateOrderStatus']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * GiftCardOrderApi - factory interface
 */
export const GiftCardOrderApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = GiftCardOrderApiFp(configuration)
    return {
        /**
         * Creates an Order for a Rise Gift Card.
         * @param {GiftCardOrderGiftCardOrderServiceV1RiseOrdersPostCreateOrderRequestBody} giftCardOrderGiftCardOrderServiceV1RiseOrdersPostCreateOrderRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createOrder(giftCardOrderGiftCardOrderServiceV1RiseOrdersPostCreateOrderRequestBody: GiftCardOrderGiftCardOrderServiceV1RiseOrdersPostCreateOrderRequestBody, options?: RawAxiosRequestConfig): AxiosPromise<CreateOrderResponse> {
            return localVarFp.createOrder(giftCardOrderGiftCardOrderServiceV1RiseOrdersPostCreateOrderRequestBody, options).then((request) => request(axios, basePath));
        },
        /**
         * Fulfills an order in an async manner.
         * @param {GiftCardOrderGiftCardOrderServiceV1RiseOrdersFulfillPostFulfillOrderRequestBody} giftCardOrderGiftCardOrderServiceV1RiseOrdersFulfillPostFulfillOrderRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fulfillOrder(giftCardOrderGiftCardOrderServiceV1RiseOrdersFulfillPostFulfillOrderRequestBody: GiftCardOrderGiftCardOrderServiceV1RiseOrdersFulfillPostFulfillOrderRequestBody, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.fulfillOrder(giftCardOrderGiftCardOrderServiceV1RiseOrdersFulfillPostFulfillOrderRequestBody, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves a list of Orders, given the provided paging, filtering, and sorting]. Up to 1,000 Orders can be returned per request. To learn how to query Orders, see [API Query Language](https://platform.rise.ai/docs/#tag/About-API-Query-Language).
         * @param {GiftCardOrderGiftCardOrderServiceV1RiseOrdersQueryPostQueryOrdersRequestBody} giftCardOrderGiftCardOrderServiceV1RiseOrdersQueryPostQueryOrdersRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        queryOrders(giftCardOrderGiftCardOrderServiceV1RiseOrdersQueryPostQueryOrdersRequestBody: GiftCardOrderGiftCardOrderServiceV1RiseOrdersQueryPostQueryOrdersRequestBody, options?: RawAxiosRequestConfig): AxiosPromise<QueryOrdersResponse1> {
            return localVarFp.queryOrders(giftCardOrderGiftCardOrderServiceV1RiseOrdersQueryPostQueryOrdersRequestBody, options).then((request) => request(axios, basePath));
        },
        /**
         * Updates a Rise Gift Card Order.
         * @param {string} orderId Order ID.
         * @param {GiftCardOrderGiftCardOrderServiceV1RiseOrdersOrderIdPatchUpdateOrderRequestBody} giftCardOrderGiftCardOrderServiceV1RiseOrdersOrderIdPatchUpdateOrderRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateOrder(orderId: string, giftCardOrderGiftCardOrderServiceV1RiseOrdersOrderIdPatchUpdateOrderRequestBody: GiftCardOrderGiftCardOrderServiceV1RiseOrdersOrderIdPatchUpdateOrderRequestBody, options?: RawAxiosRequestConfig): AxiosPromise<UpdateOrderResponse> {
            return localVarFp.updateOrder(orderId, giftCardOrderGiftCardOrderServiceV1RiseOrdersOrderIdPatchUpdateOrderRequestBody, options).then((request) => request(axios, basePath));
        },
        /**
         * Updates order payment status and fulfills it accordingly, in an async manner.
         * @param {GiftCardOrderGiftCardOrderServiceV1RiseOrdersStatusPostUpdateOrderStatusRequestBody} giftCardOrderGiftCardOrderServiceV1RiseOrdersStatusPostUpdateOrderStatusRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateOrderStatus(giftCardOrderGiftCardOrderServiceV1RiseOrdersStatusPostUpdateOrderStatusRequestBody: GiftCardOrderGiftCardOrderServiceV1RiseOrdersStatusPostUpdateOrderStatusRequestBody, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.updateOrderStatus(giftCardOrderGiftCardOrderServiceV1RiseOrdersStatusPostUpdateOrderStatusRequestBody, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * GiftCardOrderApi - object-oriented interface
 */
export class GiftCardOrderApi extends BaseAPI {
    /**
     * Creates an Order for a Rise Gift Card.
     * @param {GiftCardOrderGiftCardOrderServiceV1RiseOrdersPostCreateOrderRequestBody} giftCardOrderGiftCardOrderServiceV1RiseOrdersPostCreateOrderRequestBody 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public createOrder(giftCardOrderGiftCardOrderServiceV1RiseOrdersPostCreateOrderRequestBody: GiftCardOrderGiftCardOrderServiceV1RiseOrdersPostCreateOrderRequestBody, options?: RawAxiosRequestConfig) {
        return GiftCardOrderApiFp(this.configuration).createOrder(giftCardOrderGiftCardOrderServiceV1RiseOrdersPostCreateOrderRequestBody, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Fulfills an order in an async manner.
     * @param {GiftCardOrderGiftCardOrderServiceV1RiseOrdersFulfillPostFulfillOrderRequestBody} giftCardOrderGiftCardOrderServiceV1RiseOrdersFulfillPostFulfillOrderRequestBody 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public fulfillOrder(giftCardOrderGiftCardOrderServiceV1RiseOrdersFulfillPostFulfillOrderRequestBody: GiftCardOrderGiftCardOrderServiceV1RiseOrdersFulfillPostFulfillOrderRequestBody, options?: RawAxiosRequestConfig) {
        return GiftCardOrderApiFp(this.configuration).fulfillOrder(giftCardOrderGiftCardOrderServiceV1RiseOrdersFulfillPostFulfillOrderRequestBody, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves a list of Orders, given the provided paging, filtering, and sorting]. Up to 1,000 Orders can be returned per request. To learn how to query Orders, see [API Query Language](https://platform.rise.ai/docs/#tag/About-API-Query-Language).
     * @param {GiftCardOrderGiftCardOrderServiceV1RiseOrdersQueryPostQueryOrdersRequestBody} giftCardOrderGiftCardOrderServiceV1RiseOrdersQueryPostQueryOrdersRequestBody 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public queryOrders(giftCardOrderGiftCardOrderServiceV1RiseOrdersQueryPostQueryOrdersRequestBody: GiftCardOrderGiftCardOrderServiceV1RiseOrdersQueryPostQueryOrdersRequestBody, options?: RawAxiosRequestConfig) {
        return GiftCardOrderApiFp(this.configuration).queryOrders(giftCardOrderGiftCardOrderServiceV1RiseOrdersQueryPostQueryOrdersRequestBody, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Updates a Rise Gift Card Order.
     * @param {string} orderId Order ID.
     * @param {GiftCardOrderGiftCardOrderServiceV1RiseOrdersOrderIdPatchUpdateOrderRequestBody} giftCardOrderGiftCardOrderServiceV1RiseOrdersOrderIdPatchUpdateOrderRequestBody 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public updateOrder(orderId: string, giftCardOrderGiftCardOrderServiceV1RiseOrdersOrderIdPatchUpdateOrderRequestBody: GiftCardOrderGiftCardOrderServiceV1RiseOrdersOrderIdPatchUpdateOrderRequestBody, options?: RawAxiosRequestConfig) {
        return GiftCardOrderApiFp(this.configuration).updateOrder(orderId, giftCardOrderGiftCardOrderServiceV1RiseOrdersOrderIdPatchUpdateOrderRequestBody, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Updates order payment status and fulfills it accordingly, in an async manner.
     * @param {GiftCardOrderGiftCardOrderServiceV1RiseOrdersStatusPostUpdateOrderStatusRequestBody} giftCardOrderGiftCardOrderServiceV1RiseOrdersStatusPostUpdateOrderStatusRequestBody 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public updateOrderStatus(giftCardOrderGiftCardOrderServiceV1RiseOrdersStatusPostUpdateOrderStatusRequestBody: GiftCardOrderGiftCardOrderServiceV1RiseOrdersStatusPostUpdateOrderStatusRequestBody, options?: RawAxiosRequestConfig) {
        return GiftCardOrderApiFp(this.configuration).updateOrderStatus(giftCardOrderGiftCardOrderServiceV1RiseOrdersStatusPostUpdateOrderStatusRequestBody, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * OAuthApi - axios parameter creator
 */
export const OAuthApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Creates an access token.  Use this access token as Authorization header to call any other Rise api.  The token is valid for 4 hours.
         * @param {OAuthOauth2TokenPostSomeOperationRequestBody} [oAuthOauth2TokenPostSomeOperationRequestBody] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        someOperation: async (oAuthOauth2TokenPostSomeOperationRequestBody?: OAuthOauth2TokenPostSomeOperationRequestBody, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/oauth2/token`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(oAuthOauth2TokenPostSomeOperationRequestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * OAuthApi - functional programming interface
 */
export const OAuthApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = OAuthApiAxiosParamCreator(configuration)
    return {
        /**
         * Creates an access token.  Use this access token as Authorization header to call any other Rise api.  The token is valid for 4 hours.
         * @param {OAuthOauth2TokenPostSomeOperationRequestBody} [oAuthOauth2TokenPostSomeOperationRequestBody] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async someOperation(oAuthOauth2TokenPostSomeOperationRequestBody?: OAuthOauth2TokenPostSomeOperationRequestBody, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateAccessTokenResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.someOperation(oAuthOauth2TokenPostSomeOperationRequestBody, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OAuthApi.someOperation']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * OAuthApi - factory interface
 */
export const OAuthApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = OAuthApiFp(configuration)
    return {
        /**
         * Creates an access token.  Use this access token as Authorization header to call any other Rise api.  The token is valid for 4 hours.
         * @param {OAuthOauth2TokenPostSomeOperationRequestBody} [oAuthOauth2TokenPostSomeOperationRequestBody] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        someOperation(oAuthOauth2TokenPostSomeOperationRequestBody?: OAuthOauth2TokenPostSomeOperationRequestBody, options?: RawAxiosRequestConfig): AxiosPromise<CreateAccessTokenResponse> {
            return localVarFp.someOperation(oAuthOauth2TokenPostSomeOperationRequestBody, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * OAuthApi - object-oriented interface
 */
export class OAuthApi extends BaseAPI {
    /**
     * Creates an access token.  Use this access token as Authorization header to call any other Rise api.  The token is valid for 4 hours.
     * @param {OAuthOauth2TokenPostSomeOperationRequestBody} [oAuthOauth2TokenPostSomeOperationRequestBody] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public someOperation(oAuthOauth2TokenPostSomeOperationRequestBody?: OAuthOauth2TokenPostSomeOperationRequestBody, options?: RawAxiosRequestConfig) {
        return OAuthApiFp(this.configuration).someOperation(oAuthOauth2TokenPostSomeOperationRequestBody, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * RecipientApi - axios parameter creator
 */
export const RecipientApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Creates a Recipient. Note: This method is already called by GiftCardOrderService when an order is fulfilled.
         * @param {RecipientGiftCardRecipientServiceV1RiseRecipientsPostCreateRecipientRequestBody} recipientGiftCardRecipientServiceV1RiseRecipientsPostCreateRecipientRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createRecipient: async (recipientGiftCardRecipientServiceV1RiseRecipientsPostCreateRecipientRequestBody: RecipientGiftCardRecipientServiceV1RiseRecipientsPostCreateRecipientRequestBody, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'recipientGiftCardRecipientServiceV1RiseRecipientsPostCreateRecipientRequestBody' is not null or undefined
            assertParamExists('createRecipient', 'recipientGiftCardRecipientServiceV1RiseRecipientsPostCreateRecipientRequestBody', recipientGiftCardRecipientServiceV1RiseRecipientsPostCreateRecipientRequestBody)
            const localVarPath = `/v1/rise/recipients`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(recipientGiftCardRecipientServiceV1RiseRecipientsPostCreateRecipientRequestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deletes a Recipient by ID.
         * @param {string} recipientId Id of the Recipient to delete.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteRecipient: async (recipientId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'recipientId' is not null or undefined
            assertParamExists('deleteRecipient', 'recipientId', recipientId)
            const localVarPath = `/v1/rise/recipients/{recipientId}`
                .replace(`{${"recipientId"}}`, encodeURIComponent(String(recipientId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves a Recipient by ID.
         * @param {string} recipientId ID of the Recipient to retrieve.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRecipient: async (recipientId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'recipientId' is not null or undefined
            assertParamExists('getRecipient', 'recipientId', recipientId)
            const localVarPath = `/v1/rise/recipients/{recipientId}`
                .replace(`{${"recipientId"}}`, encodeURIComponent(String(recipientId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves a list of Recipients, given the provided paging, filtering, and sorting. To learn how to query Recipients, see [API Query Language](https://platform.rise.ai/docs/#tag/About-API-Query-Language).
         * @param {RecipientGiftCardRecipientServiceV1RiseRecipientsQueryPostQueryRecipientsRequestBody} recipientGiftCardRecipientServiceV1RiseRecipientsQueryPostQueryRecipientsRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        queryRecipients: async (recipientGiftCardRecipientServiceV1RiseRecipientsQueryPostQueryRecipientsRequestBody: RecipientGiftCardRecipientServiceV1RiseRecipientsQueryPostQueryRecipientsRequestBody, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'recipientGiftCardRecipientServiceV1RiseRecipientsQueryPostQueryRecipientsRequestBody' is not null or undefined
            assertParamExists('queryRecipients', 'recipientGiftCardRecipientServiceV1RiseRecipientsQueryPostQueryRecipientsRequestBody', recipientGiftCardRecipientServiceV1RiseRecipientsQueryPostQueryRecipientsRequestBody)
            const localVarPath = `/v1/rise/recipients/query`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(recipientGiftCardRecipientServiceV1RiseRecipientsQueryPostQueryRecipientsRequestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * RecipientApi - functional programming interface
 */
export const RecipientApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = RecipientApiAxiosParamCreator(configuration)
    return {
        /**
         * Creates a Recipient. Note: This method is already called by GiftCardOrderService when an order is fulfilled.
         * @param {RecipientGiftCardRecipientServiceV1RiseRecipientsPostCreateRecipientRequestBody} recipientGiftCardRecipientServiceV1RiseRecipientsPostCreateRecipientRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createRecipient(recipientGiftCardRecipientServiceV1RiseRecipientsPostCreateRecipientRequestBody: RecipientGiftCardRecipientServiceV1RiseRecipientsPostCreateRecipientRequestBody, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateRecipientResponse1>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createRecipient(recipientGiftCardRecipientServiceV1RiseRecipientsPostCreateRecipientRequestBody, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RecipientApi.createRecipient']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Deletes a Recipient by ID.
         * @param {string} recipientId Id of the Recipient to delete.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteRecipient(recipientId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteRecipient(recipientId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RecipientApi.deleteRecipient']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieves a Recipient by ID.
         * @param {string} recipientId ID of the Recipient to retrieve.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRecipient(recipientId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetRecipientResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRecipient(recipientId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RecipientApi.getRecipient']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieves a list of Recipients, given the provided paging, filtering, and sorting. To learn how to query Recipients, see [API Query Language](https://platform.rise.ai/docs/#tag/About-API-Query-Language).
         * @param {RecipientGiftCardRecipientServiceV1RiseRecipientsQueryPostQueryRecipientsRequestBody} recipientGiftCardRecipientServiceV1RiseRecipientsQueryPostQueryRecipientsRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async queryRecipients(recipientGiftCardRecipientServiceV1RiseRecipientsQueryPostQueryRecipientsRequestBody: RecipientGiftCardRecipientServiceV1RiseRecipientsQueryPostQueryRecipientsRequestBody, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<QueryRecipientsResponse1>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.queryRecipients(recipientGiftCardRecipientServiceV1RiseRecipientsQueryPostQueryRecipientsRequestBody, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RecipientApi.queryRecipients']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * RecipientApi - factory interface
 */
export const RecipientApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = RecipientApiFp(configuration)
    return {
        /**
         * Creates a Recipient. Note: This method is already called by GiftCardOrderService when an order is fulfilled.
         * @param {RecipientGiftCardRecipientServiceV1RiseRecipientsPostCreateRecipientRequestBody} recipientGiftCardRecipientServiceV1RiseRecipientsPostCreateRecipientRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createRecipient(recipientGiftCardRecipientServiceV1RiseRecipientsPostCreateRecipientRequestBody: RecipientGiftCardRecipientServiceV1RiseRecipientsPostCreateRecipientRequestBody, options?: RawAxiosRequestConfig): AxiosPromise<CreateRecipientResponse1> {
            return localVarFp.createRecipient(recipientGiftCardRecipientServiceV1RiseRecipientsPostCreateRecipientRequestBody, options).then((request) => request(axios, basePath));
        },
        /**
         * Deletes a Recipient by ID.
         * @param {string} recipientId Id of the Recipient to delete.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteRecipient(recipientId: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteRecipient(recipientId, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves a Recipient by ID.
         * @param {string} recipientId ID of the Recipient to retrieve.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRecipient(recipientId: string, options?: RawAxiosRequestConfig): AxiosPromise<GetRecipientResponse> {
            return localVarFp.getRecipient(recipientId, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves a list of Recipients, given the provided paging, filtering, and sorting. To learn how to query Recipients, see [API Query Language](https://platform.rise.ai/docs/#tag/About-API-Query-Language).
         * @param {RecipientGiftCardRecipientServiceV1RiseRecipientsQueryPostQueryRecipientsRequestBody} recipientGiftCardRecipientServiceV1RiseRecipientsQueryPostQueryRecipientsRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        queryRecipients(recipientGiftCardRecipientServiceV1RiseRecipientsQueryPostQueryRecipientsRequestBody: RecipientGiftCardRecipientServiceV1RiseRecipientsQueryPostQueryRecipientsRequestBody, options?: RawAxiosRequestConfig): AxiosPromise<QueryRecipientsResponse1> {
            return localVarFp.queryRecipients(recipientGiftCardRecipientServiceV1RiseRecipientsQueryPostQueryRecipientsRequestBody, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * RecipientApi - object-oriented interface
 */
export class RecipientApi extends BaseAPI {
    /**
     * Creates a Recipient. Note: This method is already called by GiftCardOrderService when an order is fulfilled.
     * @param {RecipientGiftCardRecipientServiceV1RiseRecipientsPostCreateRecipientRequestBody} recipientGiftCardRecipientServiceV1RiseRecipientsPostCreateRecipientRequestBody 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public createRecipient(recipientGiftCardRecipientServiceV1RiseRecipientsPostCreateRecipientRequestBody: RecipientGiftCardRecipientServiceV1RiseRecipientsPostCreateRecipientRequestBody, options?: RawAxiosRequestConfig) {
        return RecipientApiFp(this.configuration).createRecipient(recipientGiftCardRecipientServiceV1RiseRecipientsPostCreateRecipientRequestBody, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Deletes a Recipient by ID.
     * @param {string} recipientId Id of the Recipient to delete.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public deleteRecipient(recipientId: string, options?: RawAxiosRequestConfig) {
        return RecipientApiFp(this.configuration).deleteRecipient(recipientId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves a Recipient by ID.
     * @param {string} recipientId ID of the Recipient to retrieve.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getRecipient(recipientId: string, options?: RawAxiosRequestConfig) {
        return RecipientApiFp(this.configuration).getRecipient(recipientId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves a list of Recipients, given the provided paging, filtering, and sorting. To learn how to query Recipients, see [API Query Language](https://platform.rise.ai/docs/#tag/About-API-Query-Language).
     * @param {RecipientGiftCardRecipientServiceV1RiseRecipientsQueryPostQueryRecipientsRequestBody} recipientGiftCardRecipientServiceV1RiseRecipientsQueryPostQueryRecipientsRequestBody 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public queryRecipients(recipientGiftCardRecipientServiceV1RiseRecipientsQueryPostQueryRecipientsRequestBody: RecipientGiftCardRecipientServiceV1RiseRecipientsQueryPostQueryRecipientsRequestBody, options?: RawAxiosRequestConfig) {
        return RecipientApiFp(this.configuration).queryRecipients(recipientGiftCardRecipientServiceV1RiseRecipientsQueryPostQueryRecipientsRequestBody, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * TransactionApi - axios parameter creator
 */
export const TransactionApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Query Transactions using [API Query Language](https://platform.rise.ai/docs/#tag/About-API-Query-Language).
         * @param {TransactionTransactionQueryServiceV1RiseGiftCardsTransactionsQueryPostQueryTransactionsRequestBody} transactionTransactionQueryServiceV1RiseGiftCardsTransactionsQueryPostQueryTransactionsRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        queryTransactions: async (transactionTransactionQueryServiceV1RiseGiftCardsTransactionsQueryPostQueryTransactionsRequestBody: TransactionTransactionQueryServiceV1RiseGiftCardsTransactionsQueryPostQueryTransactionsRequestBody, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'transactionTransactionQueryServiceV1RiseGiftCardsTransactionsQueryPostQueryTransactionsRequestBody' is not null or undefined
            assertParamExists('queryTransactions', 'transactionTransactionQueryServiceV1RiseGiftCardsTransactionsQueryPostQueryTransactionsRequestBody', transactionTransactionQueryServiceV1RiseGiftCardsTransactionsQueryPostQueryTransactionsRequestBody)
            const localVarPath = `/v1/rise/gift-cards/transactions/query`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(transactionTransactionQueryServiceV1RiseGiftCardsTransactionsQueryPostQueryTransactionsRequestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TransactionApi - functional programming interface
 */
export const TransactionApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = TransactionApiAxiosParamCreator(configuration)
    return {
        /**
         * Query Transactions using [API Query Language](https://platform.rise.ai/docs/#tag/About-API-Query-Language).
         * @param {TransactionTransactionQueryServiceV1RiseGiftCardsTransactionsQueryPostQueryTransactionsRequestBody} transactionTransactionQueryServiceV1RiseGiftCardsTransactionsQueryPostQueryTransactionsRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async queryTransactions(transactionTransactionQueryServiceV1RiseGiftCardsTransactionsQueryPostQueryTransactionsRequestBody: TransactionTransactionQueryServiceV1RiseGiftCardsTransactionsQueryPostQueryTransactionsRequestBody, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<QueryTransactionsResponse1>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.queryTransactions(transactionTransactionQueryServiceV1RiseGiftCardsTransactionsQueryPostQueryTransactionsRequestBody, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TransactionApi.queryTransactions']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * TransactionApi - factory interface
 */
export const TransactionApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = TransactionApiFp(configuration)
    return {
        /**
         * Query Transactions using [API Query Language](https://platform.rise.ai/docs/#tag/About-API-Query-Language).
         * @param {TransactionTransactionQueryServiceV1RiseGiftCardsTransactionsQueryPostQueryTransactionsRequestBody} transactionTransactionQueryServiceV1RiseGiftCardsTransactionsQueryPostQueryTransactionsRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        queryTransactions(transactionTransactionQueryServiceV1RiseGiftCardsTransactionsQueryPostQueryTransactionsRequestBody: TransactionTransactionQueryServiceV1RiseGiftCardsTransactionsQueryPostQueryTransactionsRequestBody, options?: RawAxiosRequestConfig): AxiosPromise<QueryTransactionsResponse1> {
            return localVarFp.queryTransactions(transactionTransactionQueryServiceV1RiseGiftCardsTransactionsQueryPostQueryTransactionsRequestBody, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * TransactionApi - object-oriented interface
 */
export class TransactionApi extends BaseAPI {
    /**
     * Query Transactions using [API Query Language](https://platform.rise.ai/docs/#tag/About-API-Query-Language).
     * @param {TransactionTransactionQueryServiceV1RiseGiftCardsTransactionsQueryPostQueryTransactionsRequestBody} transactionTransactionQueryServiceV1RiseGiftCardsTransactionsQueryPostQueryTransactionsRequestBody 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public queryTransactions(transactionTransactionQueryServiceV1RiseGiftCardsTransactionsQueryPostQueryTransactionsRequestBody: TransactionTransactionQueryServiceV1RiseGiftCardsTransactionsQueryPostQueryTransactionsRequestBody, options?: RawAxiosRequestConfig) {
        return TransactionApiFp(this.configuration).queryTransactions(transactionTransactionQueryServiceV1RiseGiftCardsTransactionsQueryPostQueryTransactionsRequestBody, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * WalletApi - axios parameter creator
 */
export const WalletApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Count wallets based on the given filter.
         * @param {WalletWalletServiceV1RiseWalletsCountPostCountWalletsRequestBody} walletWalletServiceV1RiseWalletsCountPostCountWalletsRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        countWallets: async (walletWalletServiceV1RiseWalletsCountPostCountWalletsRequestBody: WalletWalletServiceV1RiseWalletsCountPostCountWalletsRequestBody, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'walletWalletServiceV1RiseWalletsCountPostCountWalletsRequestBody' is not null or undefined
            assertParamExists('countWallets', 'walletWalletServiceV1RiseWalletsCountPostCountWalletsRequestBody', walletWalletServiceV1RiseWalletsCountPostCountWalletsRequestBody)
            const localVarPath = `/v1/rise/wallets/count`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(walletWalletServiceV1RiseWalletsCountPostCountWalletsRequestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Creates a new Wallet.
         * @param {WalletWalletServiceV1RiseWalletsPostCreateWalletRequestBody} walletWalletServiceV1RiseWalletsPostCreateWalletRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createWallet: async (walletWalletServiceV1RiseWalletsPostCreateWalletRequestBody: WalletWalletServiceV1RiseWalletsPostCreateWalletRequestBody, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'walletWalletServiceV1RiseWalletsPostCreateWalletRequestBody' is not null or undefined
            assertParamExists('createWallet', 'walletWalletServiceV1RiseWalletsPostCreateWalletRequestBody', walletWalletServiceV1RiseWalletsPostCreateWalletRequestBody)
            const localVarPath = `/v1/rise/wallets`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(walletWalletServiceV1RiseWalletsPostCreateWalletRequestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a CustomerReference by source (i.e. source channel, tenant, and customer IDs).
         * @param {CustomerReferenceQuery} query Customer Reference query object.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCustomerReference: async (query: CustomerReferenceQuery, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'query' is not null or undefined
            assertParamExists('getCustomerReference', 'query', query)
            const localVarPath = `/v1/rise/customers`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (query !== undefined) {
                for (const [key, value] of Object.entries(query)) {
                    localVarQueryParameter[key] = value;
                }
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves or creates a Wallet for the provided customer reference.  - In case the Wallet doesn\'t exist - creates a new Wallet with the provided customer reference. - In case the Wallet already exists - returns the existing Wallet. - If the provided customer reference doesn\'t exist yet - adds it to the wallet. - If the provided customer reference already exists - doesn\'t update anything.
         * @param {WalletWalletServiceV1RiseWalletsIssuePostGetOrCreateWalletRequestBody} walletWalletServiceV1RiseWalletsIssuePostGetOrCreateWalletRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrCreateWallet: async (walletWalletServiceV1RiseWalletsIssuePostGetOrCreateWalletRequestBody: WalletWalletServiceV1RiseWalletsIssuePostGetOrCreateWalletRequestBody, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'walletWalletServiceV1RiseWalletsIssuePostGetOrCreateWalletRequestBody' is not null or undefined
            assertParamExists('getOrCreateWallet', 'walletWalletServiceV1RiseWalletsIssuePostGetOrCreateWalletRequestBody', walletWalletServiceV1RiseWalletsIssuePostGetOrCreateWalletRequestBody)
            const localVarPath = `/v1/rise/wallets/issue`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(walletWalletServiceV1RiseWalletsIssuePostGetOrCreateWalletRequestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a Wallet by ID, email, or a customer reference in the wallet.
         * @param {object} query Query object.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWallet: async (query: object, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'query' is not null or undefined
            assertParamExists('getWallet', 'query', query)
            const localVarPath = `/v1/rise/wallets`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (query !== undefined) {
                for (const [key, value] of Object.entries(query)) {
                    localVarQueryParameter[key] = value;
                }
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Query wallets enriched with gift card and contact information. See [API Query Language](https://platform.rise.ai/docs/#tag/About-API-Query-Language).
         * @param {WalletActionWalletActionServiceV1RiseWalletActionsQueryPostQueryWalletActionsRequestBody} walletActionWalletActionServiceV1RiseWalletActionsQueryPostQueryWalletActionsRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        queryWallets: async (walletActionWalletActionServiceV1RiseWalletActionsQueryPostQueryWalletActionsRequestBody: WalletActionWalletActionServiceV1RiseWalletActionsQueryPostQueryWalletActionsRequestBody, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'walletActionWalletActionServiceV1RiseWalletActionsQueryPostQueryWalletActionsRequestBody' is not null or undefined
            assertParamExists('queryWallets', 'walletActionWalletActionServiceV1RiseWalletActionsQueryPostQueryWalletActionsRequestBody', walletActionWalletActionServiceV1RiseWalletActionsQueryPostQueryWalletActionsRequestBody)
            const localVarPath = `/v1/rise/wallets/query`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(walletActionWalletActionServiceV1RiseWalletActionsQueryPostQueryWalletActionsRequestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Query wallets by contact using [API Query Language](https://platform.rise.ai/docs/#tag/About-API-Query-Language). The result is a list of wallets with gift card and contact information.
         * @param {WalletWalletServiceV1RiseWalletsQueryByContactPostQueryWalletsByContactRequestBody} walletWalletServiceV1RiseWalletsQueryByContactPostQueryWalletsByContactRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        queryWalletsByContact: async (walletWalletServiceV1RiseWalletsQueryByContactPostQueryWalletsByContactRequestBody: WalletWalletServiceV1RiseWalletsQueryByContactPostQueryWalletsByContactRequestBody, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'walletWalletServiceV1RiseWalletsQueryByContactPostQueryWalletsByContactRequestBody' is not null or undefined
            assertParamExists('queryWalletsByContact', 'walletWalletServiceV1RiseWalletsQueryByContactPostQueryWalletsByContactRequestBody', walletWalletServiceV1RiseWalletsQueryByContactPostQueryWalletsByContactRequestBody)
            const localVarPath = `/v1/rise/wallets/query_by_contact`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(walletWalletServiceV1RiseWalletsQueryByContactPostQueryWalletsByContactRequestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * WalletApi - functional programming interface
 */
export const WalletApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = WalletApiAxiosParamCreator(configuration)
    return {
        /**
         * Count wallets based on the given filter.
         * @param {WalletWalletServiceV1RiseWalletsCountPostCountWalletsRequestBody} walletWalletServiceV1RiseWalletsCountPostCountWalletsRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async countWallets(walletWalletServiceV1RiseWalletsCountPostCountWalletsRequestBody: WalletWalletServiceV1RiseWalletsCountPostCountWalletsRequestBody, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CountWalletsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.countWallets(walletWalletServiceV1RiseWalletsCountPostCountWalletsRequestBody, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WalletApi.countWallets']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Creates a new Wallet.
         * @param {WalletWalletServiceV1RiseWalletsPostCreateWalletRequestBody} walletWalletServiceV1RiseWalletsPostCreateWalletRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createWallet(walletWalletServiceV1RiseWalletsPostCreateWalletRequestBody: WalletWalletServiceV1RiseWalletsPostCreateWalletRequestBody, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateWalletResponse1>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createWallet(walletWalletServiceV1RiseWalletsPostCreateWalletRequestBody, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WalletApi.createWallet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get a CustomerReference by source (i.e. source channel, tenant, and customer IDs).
         * @param {CustomerReferenceQuery} query Customer Reference query object.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCustomerReference(query: CustomerReferenceQuery, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetCustomerReferenceResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCustomerReference(query, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WalletApi.getCustomerReference']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieves or creates a Wallet for the provided customer reference.  - In case the Wallet doesn\'t exist - creates a new Wallet with the provided customer reference. - In case the Wallet already exists - returns the existing Wallet. - If the provided customer reference doesn\'t exist yet - adds it to the wallet. - If the provided customer reference already exists - doesn\'t update anything.
         * @param {WalletWalletServiceV1RiseWalletsIssuePostGetOrCreateWalletRequestBody} walletWalletServiceV1RiseWalletsIssuePostGetOrCreateWalletRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getOrCreateWallet(walletWalletServiceV1RiseWalletsIssuePostGetOrCreateWalletRequestBody: WalletWalletServiceV1RiseWalletsIssuePostGetOrCreateWalletRequestBody, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetOrCreateWalletResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getOrCreateWallet(walletWalletServiceV1RiseWalletsIssuePostGetOrCreateWalletRequestBody, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WalletApi.getOrCreateWallet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get a Wallet by ID, email, or a customer reference in the wallet.
         * @param {object} query Query object.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getWallet(query: object, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetWalletResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getWallet(query, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WalletApi.getWallet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Query wallets enriched with gift card and contact information. See [API Query Language](https://platform.rise.ai/docs/#tag/About-API-Query-Language).
         * @param {WalletActionWalletActionServiceV1RiseWalletActionsQueryPostQueryWalletActionsRequestBody} walletActionWalletActionServiceV1RiseWalletActionsQueryPostQueryWalletActionsRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async queryWallets(walletActionWalletActionServiceV1RiseWalletActionsQueryPostQueryWalletActionsRequestBody: WalletActionWalletActionServiceV1RiseWalletActionsQueryPostQueryWalletActionsRequestBody, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<QueryWalletsResponse1>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.queryWallets(walletActionWalletActionServiceV1RiseWalletActionsQueryPostQueryWalletActionsRequestBody, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WalletApi.queryWallets']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Query wallets by contact using [API Query Language](https://platform.rise.ai/docs/#tag/About-API-Query-Language). The result is a list of wallets with gift card and contact information.
         * @param {WalletWalletServiceV1RiseWalletsQueryByContactPostQueryWalletsByContactRequestBody} walletWalletServiceV1RiseWalletsQueryByContactPostQueryWalletsByContactRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async queryWalletsByContact(walletWalletServiceV1RiseWalletsQueryByContactPostQueryWalletsByContactRequestBody: WalletWalletServiceV1RiseWalletsQueryByContactPostQueryWalletsByContactRequestBody, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<QueryWalletsByContactResponse1>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.queryWalletsByContact(walletWalletServiceV1RiseWalletsQueryByContactPostQueryWalletsByContactRequestBody, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WalletApi.queryWalletsByContact']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * WalletApi - factory interface
 */
export const WalletApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = WalletApiFp(configuration)
    return {
        /**
         * Count wallets based on the given filter.
         * @param {WalletWalletServiceV1RiseWalletsCountPostCountWalletsRequestBody} walletWalletServiceV1RiseWalletsCountPostCountWalletsRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        countWallets(walletWalletServiceV1RiseWalletsCountPostCountWalletsRequestBody: WalletWalletServiceV1RiseWalletsCountPostCountWalletsRequestBody, options?: RawAxiosRequestConfig): AxiosPromise<CountWalletsResponse> {
            return localVarFp.countWallets(walletWalletServiceV1RiseWalletsCountPostCountWalletsRequestBody, options).then((request) => request(axios, basePath));
        },
        /**
         * Creates a new Wallet.
         * @param {WalletWalletServiceV1RiseWalletsPostCreateWalletRequestBody} walletWalletServiceV1RiseWalletsPostCreateWalletRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createWallet(walletWalletServiceV1RiseWalletsPostCreateWalletRequestBody: WalletWalletServiceV1RiseWalletsPostCreateWalletRequestBody, options?: RawAxiosRequestConfig): AxiosPromise<CreateWalletResponse1> {
            return localVarFp.createWallet(walletWalletServiceV1RiseWalletsPostCreateWalletRequestBody, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a CustomerReference by source (i.e. source channel, tenant, and customer IDs).
         * @param {CustomerReferenceQuery} query Customer Reference query object.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCustomerReference(query: CustomerReferenceQuery, options?: RawAxiosRequestConfig): AxiosPromise<GetCustomerReferenceResponse> {
            return localVarFp.getCustomerReference(query, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves or creates a Wallet for the provided customer reference.  - In case the Wallet doesn\'t exist - creates a new Wallet with the provided customer reference. - In case the Wallet already exists - returns the existing Wallet. - If the provided customer reference doesn\'t exist yet - adds it to the wallet. - If the provided customer reference already exists - doesn\'t update anything.
         * @param {WalletWalletServiceV1RiseWalletsIssuePostGetOrCreateWalletRequestBody} walletWalletServiceV1RiseWalletsIssuePostGetOrCreateWalletRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrCreateWallet(walletWalletServiceV1RiseWalletsIssuePostGetOrCreateWalletRequestBody: WalletWalletServiceV1RiseWalletsIssuePostGetOrCreateWalletRequestBody, options?: RawAxiosRequestConfig): AxiosPromise<GetOrCreateWalletResponse> {
            return localVarFp.getOrCreateWallet(walletWalletServiceV1RiseWalletsIssuePostGetOrCreateWalletRequestBody, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a Wallet by ID, email, or a customer reference in the wallet.
         * @param {object} query Query object.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWallet(query: object, options?: RawAxiosRequestConfig): AxiosPromise<GetWalletResponse> {
            return localVarFp.getWallet(query, options).then((request) => request(axios, basePath));
        },
        /**
         * Query wallets enriched with gift card and contact information. See [API Query Language](https://platform.rise.ai/docs/#tag/About-API-Query-Language).
         * @param {WalletActionWalletActionServiceV1RiseWalletActionsQueryPostQueryWalletActionsRequestBody} walletActionWalletActionServiceV1RiseWalletActionsQueryPostQueryWalletActionsRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        queryWallets(walletActionWalletActionServiceV1RiseWalletActionsQueryPostQueryWalletActionsRequestBody: WalletActionWalletActionServiceV1RiseWalletActionsQueryPostQueryWalletActionsRequestBody, options?: RawAxiosRequestConfig): AxiosPromise<QueryWalletsResponse1> {
            return localVarFp.queryWallets(walletActionWalletActionServiceV1RiseWalletActionsQueryPostQueryWalletActionsRequestBody, options).then((request) => request(axios, basePath));
        },
        /**
         * Query wallets by contact using [API Query Language](https://platform.rise.ai/docs/#tag/About-API-Query-Language). The result is a list of wallets with gift card and contact information.
         * @param {WalletWalletServiceV1RiseWalletsQueryByContactPostQueryWalletsByContactRequestBody} walletWalletServiceV1RiseWalletsQueryByContactPostQueryWalletsByContactRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        queryWalletsByContact(walletWalletServiceV1RiseWalletsQueryByContactPostQueryWalletsByContactRequestBody: WalletWalletServiceV1RiseWalletsQueryByContactPostQueryWalletsByContactRequestBody, options?: RawAxiosRequestConfig): AxiosPromise<QueryWalletsByContactResponse1> {
            return localVarFp.queryWalletsByContact(walletWalletServiceV1RiseWalletsQueryByContactPostQueryWalletsByContactRequestBody, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * WalletApi - object-oriented interface
 */
export class WalletApi extends BaseAPI {
    /**
     * Count wallets based on the given filter.
     * @param {WalletWalletServiceV1RiseWalletsCountPostCountWalletsRequestBody} walletWalletServiceV1RiseWalletsCountPostCountWalletsRequestBody 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public countWallets(walletWalletServiceV1RiseWalletsCountPostCountWalletsRequestBody: WalletWalletServiceV1RiseWalletsCountPostCountWalletsRequestBody, options?: RawAxiosRequestConfig) {
        return WalletApiFp(this.configuration).countWallets(walletWalletServiceV1RiseWalletsCountPostCountWalletsRequestBody, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Creates a new Wallet.
     * @param {WalletWalletServiceV1RiseWalletsPostCreateWalletRequestBody} walletWalletServiceV1RiseWalletsPostCreateWalletRequestBody 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public createWallet(walletWalletServiceV1RiseWalletsPostCreateWalletRequestBody: WalletWalletServiceV1RiseWalletsPostCreateWalletRequestBody, options?: RawAxiosRequestConfig) {
        return WalletApiFp(this.configuration).createWallet(walletWalletServiceV1RiseWalletsPostCreateWalletRequestBody, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a CustomerReference by source (i.e. source channel, tenant, and customer IDs).
     * @param {CustomerReferenceQuery} query Customer Reference query object.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getCustomerReference(query: CustomerReferenceQuery, options?: RawAxiosRequestConfig) {
        return WalletApiFp(this.configuration).getCustomerReference(query, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves or creates a Wallet for the provided customer reference.  - In case the Wallet doesn\'t exist - creates a new Wallet with the provided customer reference. - In case the Wallet already exists - returns the existing Wallet. - If the provided customer reference doesn\'t exist yet - adds it to the wallet. - If the provided customer reference already exists - doesn\'t update anything.
     * @param {WalletWalletServiceV1RiseWalletsIssuePostGetOrCreateWalletRequestBody} walletWalletServiceV1RiseWalletsIssuePostGetOrCreateWalletRequestBody 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getOrCreateWallet(walletWalletServiceV1RiseWalletsIssuePostGetOrCreateWalletRequestBody: WalletWalletServiceV1RiseWalletsIssuePostGetOrCreateWalletRequestBody, options?: RawAxiosRequestConfig) {
        return WalletApiFp(this.configuration).getOrCreateWallet(walletWalletServiceV1RiseWalletsIssuePostGetOrCreateWalletRequestBody, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a Wallet by ID, email, or a customer reference in the wallet.
     * @param {object} query Query object.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getWallet(query: object, options?: RawAxiosRequestConfig) {
        return WalletApiFp(this.configuration).getWallet(query, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Query wallets enriched with gift card and contact information. See [API Query Language](https://platform.rise.ai/docs/#tag/About-API-Query-Language).
     * @param {WalletActionWalletActionServiceV1RiseWalletActionsQueryPostQueryWalletActionsRequestBody} walletActionWalletActionServiceV1RiseWalletActionsQueryPostQueryWalletActionsRequestBody 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public queryWallets(walletActionWalletActionServiceV1RiseWalletActionsQueryPostQueryWalletActionsRequestBody: WalletActionWalletActionServiceV1RiseWalletActionsQueryPostQueryWalletActionsRequestBody, options?: RawAxiosRequestConfig) {
        return WalletApiFp(this.configuration).queryWallets(walletActionWalletActionServiceV1RiseWalletActionsQueryPostQueryWalletActionsRequestBody, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Query wallets by contact using [API Query Language](https://platform.rise.ai/docs/#tag/About-API-Query-Language). The result is a list of wallets with gift card and contact information.
     * @param {WalletWalletServiceV1RiseWalletsQueryByContactPostQueryWalletsByContactRequestBody} walletWalletServiceV1RiseWalletsQueryByContactPostQueryWalletsByContactRequestBody 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public queryWalletsByContact(walletWalletServiceV1RiseWalletsQueryByContactPostQueryWalletsByContactRequestBody: WalletWalletServiceV1RiseWalletsQueryByContactPostQueryWalletsByContactRequestBody, options?: RawAxiosRequestConfig) {
        return WalletApiFp(this.configuration).queryWalletsByContact(walletWalletServiceV1RiseWalletsQueryByContactPostQueryWalletsByContactRequestBody, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * WalletActionApi - axios parameter creator
 */
export const WalletActionApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Creates a new WalletAction.
         * @param {WalletActionWalletActionServiceV1RiseWalletActionsPostCreateWalletActionRequestBody} walletActionWalletActionServiceV1RiseWalletActionsPostCreateWalletActionRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createWalletAction: async (walletActionWalletActionServiceV1RiseWalletActionsPostCreateWalletActionRequestBody: WalletActionWalletActionServiceV1RiseWalletActionsPostCreateWalletActionRequestBody, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'walletActionWalletActionServiceV1RiseWalletActionsPostCreateWalletActionRequestBody' is not null or undefined
            assertParamExists('createWalletAction', 'walletActionWalletActionServiceV1RiseWalletActionsPostCreateWalletActionRequestBody', walletActionWalletActionServiceV1RiseWalletActionsPostCreateWalletActionRequestBody)
            const localVarPath = `/v1/rise/wallet_actions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(walletActionWalletActionServiceV1RiseWalletActionsPostCreateWalletActionRequestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Creates a new WalletAction by customer reference instead of wallet ID. If the customer already has a wallet, the action will be created on that wallet. If the customer does not have a wallet, a new wallet will be created for them.
         * @param {WalletActionWalletActionServiceV1RiseWalletActionsByCustomerReferencePostCreateWalletActionByCustomerReferenceRequestBody} walletActionWalletActionServiceV1RiseWalletActionsByCustomerReferencePostCreateWalletActionByCustomerReferenceRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createWalletActionByCustomerReference: async (walletActionWalletActionServiceV1RiseWalletActionsByCustomerReferencePostCreateWalletActionByCustomerReferenceRequestBody: WalletActionWalletActionServiceV1RiseWalletActionsByCustomerReferencePostCreateWalletActionByCustomerReferenceRequestBody, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'walletActionWalletActionServiceV1RiseWalletActionsByCustomerReferencePostCreateWalletActionByCustomerReferenceRequestBody' is not null or undefined
            assertParamExists('createWalletActionByCustomerReference', 'walletActionWalletActionServiceV1RiseWalletActionsByCustomerReferencePostCreateWalletActionByCustomerReferenceRequestBody', walletActionWalletActionServiceV1RiseWalletActionsByCustomerReferencePostCreateWalletActionByCustomerReferenceRequestBody)
            const localVarPath = `/v1/rise/wallet_actions/by_customer_reference`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(walletActionWalletActionServiceV1RiseWalletActionsByCustomerReferencePostCreateWalletActionByCustomerReferenceRequestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Disable a WalletAction immediately and deduct the remaining balance from the wallet.
         * @param {string} walletActionId ID of the WalletAction to delete.
         * @param {WalletActionWalletActionServiceV1RiseWalletActionsWalletActionIdDisablePostDisableWalletActionRequestBody} walletActionWalletActionServiceV1RiseWalletActionsWalletActionIdDisablePostDisableWalletActionRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        disableWalletAction: async (walletActionId: string, walletActionWalletActionServiceV1RiseWalletActionsWalletActionIdDisablePostDisableWalletActionRequestBody: WalletActionWalletActionServiceV1RiseWalletActionsWalletActionIdDisablePostDisableWalletActionRequestBody, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'walletActionId' is not null or undefined
            assertParamExists('disableWalletAction', 'walletActionId', walletActionId)
            // verify required parameter 'walletActionWalletActionServiceV1RiseWalletActionsWalletActionIdDisablePostDisableWalletActionRequestBody' is not null or undefined
            assertParamExists('disableWalletAction', 'walletActionWalletActionServiceV1RiseWalletActionsWalletActionIdDisablePostDisableWalletActionRequestBody', walletActionWalletActionServiceV1RiseWalletActionsWalletActionIdDisablePostDisableWalletActionRequestBody)
            const localVarPath = `/v1/rise/wallet_actions/{walletActionId}/disable`
                .replace(`{${"walletActionId"}}`, encodeURIComponent(String(walletActionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(walletActionWalletActionServiceV1RiseWalletActionsWalletActionIdDisablePostDisableWalletActionRequestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} transactionId ID of the transaction to get refundable amounts for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRefundableAmounts: async (transactionId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'transactionId' is not null or undefined
            assertParamExists('getRefundableAmounts', 'transactionId', transactionId)
            const localVarPath = `/v1/rise/wallet_actions/refund/amounts`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (transactionId !== undefined) {
                localVarQueryParameter['transactionId'] = transactionId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Query wallet actions that have not been entirely redeemed using [API Query Language](https://platform.rise.ai/docs/#tag/About-API-Query-Language). Results are enriched with the remaining balance of each wallet action. Note: The returned result may contain fewer items than the requested page limit—or even be empty—while still providing a next cursor, because of in memory filtering. Always check the next cursor to determine if there are more items to fetch.
         * @param {WalletActionWalletActionServiceV1RiseWalletActionsQueryPostQueryWalletActionsRequestBody} walletActionWalletActionServiceV1RiseWalletActionsQueryPostQueryWalletActionsRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        queryUnredeemedWalletActions: async (walletActionWalletActionServiceV1RiseWalletActionsQueryPostQueryWalletActionsRequestBody: WalletActionWalletActionServiceV1RiseWalletActionsQueryPostQueryWalletActionsRequestBody, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'walletActionWalletActionServiceV1RiseWalletActionsQueryPostQueryWalletActionsRequestBody' is not null or undefined
            assertParamExists('queryUnredeemedWalletActions', 'walletActionWalletActionServiceV1RiseWalletActionsQueryPostQueryWalletActionsRequestBody', walletActionWalletActionServiceV1RiseWalletActionsQueryPostQueryWalletActionsRequestBody)
            const localVarPath = `/v1/rise/wallet_actions/query/unredeemed`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(walletActionWalletActionServiceV1RiseWalletActionsQueryPostQueryWalletActionsRequestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Query WalletActions using [API Query Language](https://platform.rise.ai/docs/#tag/About-API-Query-Language).
         * @param {WalletActionWalletActionServiceV1RiseWalletActionsQueryPostQueryWalletActionsRequestBody} walletActionWalletActionServiceV1RiseWalletActionsQueryPostQueryWalletActionsRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        queryWalletActions: async (walletActionWalletActionServiceV1RiseWalletActionsQueryPostQueryWalletActionsRequestBody: WalletActionWalletActionServiceV1RiseWalletActionsQueryPostQueryWalletActionsRequestBody, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'walletActionWalletActionServiceV1RiseWalletActionsQueryPostQueryWalletActionsRequestBody' is not null or undefined
            assertParamExists('queryWalletActions', 'walletActionWalletActionServiceV1RiseWalletActionsQueryPostQueryWalletActionsRequestBody', walletActionWalletActionServiceV1RiseWalletActionsQueryPostQueryWalletActionsRequestBody)
            const localVarPath = `/v1/rise/wallet_actions/query`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(walletActionWalletActionServiceV1RiseWalletActionsQueryPostQueryWalletActionsRequestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Query all WalletActions using [API Query Language](https://platform.rise.ai/docs/#tag/About-API-Query-Language). Results are enriched with the remaining balance of each WalletAction.
         * @param {WalletActionWalletActionServiceV1RiseWalletActionsQueryPostQueryWalletActionsRequestBody} walletActionWalletActionServiceV1RiseWalletActionsQueryPostQueryWalletActionsRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        queryWalletActionsBalances: async (walletActionWalletActionServiceV1RiseWalletActionsQueryPostQueryWalletActionsRequestBody: WalletActionWalletActionServiceV1RiseWalletActionsQueryPostQueryWalletActionsRequestBody, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'walletActionWalletActionServiceV1RiseWalletActionsQueryPostQueryWalletActionsRequestBody' is not null or undefined
            assertParamExists('queryWalletActionsBalances', 'walletActionWalletActionServiceV1RiseWalletActionsQueryPostQueryWalletActionsRequestBody', walletActionWalletActionServiceV1RiseWalletActionsQueryPostQueryWalletActionsRequestBody)
            const localVarPath = `/v1/rise/wallet_actions/query/balances`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(walletActionWalletActionServiceV1RiseWalletActionsQueryPostQueryWalletActionsRequestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update a WalletAction, supports partial update. Pass the latest `revision` for a successful update.
         * @param {string} walletActionId WalletAction ID.
         * @param {WalletActionWalletActionServiceV1RiseWalletActionsWalletActionIdPatchUpdateWalletActionRequestBody} walletActionWalletActionServiceV1RiseWalletActionsWalletActionIdPatchUpdateWalletActionRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateWalletAction: async (walletActionId: string, walletActionWalletActionServiceV1RiseWalletActionsWalletActionIdPatchUpdateWalletActionRequestBody: WalletActionWalletActionServiceV1RiseWalletActionsWalletActionIdPatchUpdateWalletActionRequestBody, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'walletActionId' is not null or undefined
            assertParamExists('updateWalletAction', 'walletActionId', walletActionId)
            // verify required parameter 'walletActionWalletActionServiceV1RiseWalletActionsWalletActionIdPatchUpdateWalletActionRequestBody' is not null or undefined
            assertParamExists('updateWalletAction', 'walletActionWalletActionServiceV1RiseWalletActionsWalletActionIdPatchUpdateWalletActionRequestBody', walletActionWalletActionServiceV1RiseWalletActionsWalletActionIdPatchUpdateWalletActionRequestBody)
            const localVarPath = `/v1/rise/wallet_actions/{walletActionId}`
                .replace(`{${"walletActionId"}}`, encodeURIComponent(String(walletActionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(walletActionWalletActionServiceV1RiseWalletActionsWalletActionIdPatchUpdateWalletActionRequestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * WalletActionApi - functional programming interface
 */
export const WalletActionApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = WalletActionApiAxiosParamCreator(configuration)
    return {
        /**
         * Creates a new WalletAction.
         * @param {WalletActionWalletActionServiceV1RiseWalletActionsPostCreateWalletActionRequestBody} walletActionWalletActionServiceV1RiseWalletActionsPostCreateWalletActionRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createWalletAction(walletActionWalletActionServiceV1RiseWalletActionsPostCreateWalletActionRequestBody: WalletActionWalletActionServiceV1RiseWalletActionsPostCreateWalletActionRequestBody, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateWalletActionResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createWalletAction(walletActionWalletActionServiceV1RiseWalletActionsPostCreateWalletActionRequestBody, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WalletActionApi.createWalletAction']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Creates a new WalletAction by customer reference instead of wallet ID. If the customer already has a wallet, the action will be created on that wallet. If the customer does not have a wallet, a new wallet will be created for them.
         * @param {WalletActionWalletActionServiceV1RiseWalletActionsByCustomerReferencePostCreateWalletActionByCustomerReferenceRequestBody} walletActionWalletActionServiceV1RiseWalletActionsByCustomerReferencePostCreateWalletActionByCustomerReferenceRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createWalletActionByCustomerReference(walletActionWalletActionServiceV1RiseWalletActionsByCustomerReferencePostCreateWalletActionByCustomerReferenceRequestBody: WalletActionWalletActionServiceV1RiseWalletActionsByCustomerReferencePostCreateWalletActionByCustomerReferenceRequestBody, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateWalletActionByCustomerReferenceResponse1>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createWalletActionByCustomerReference(walletActionWalletActionServiceV1RiseWalletActionsByCustomerReferencePostCreateWalletActionByCustomerReferenceRequestBody, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WalletActionApi.createWalletActionByCustomerReference']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Disable a WalletAction immediately and deduct the remaining balance from the wallet.
         * @param {string} walletActionId ID of the WalletAction to delete.
         * @param {WalletActionWalletActionServiceV1RiseWalletActionsWalletActionIdDisablePostDisableWalletActionRequestBody} walletActionWalletActionServiceV1RiseWalletActionsWalletActionIdDisablePostDisableWalletActionRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async disableWalletAction(walletActionId: string, walletActionWalletActionServiceV1RiseWalletActionsWalletActionIdDisablePostDisableWalletActionRequestBody: WalletActionWalletActionServiceV1RiseWalletActionsWalletActionIdDisablePostDisableWalletActionRequestBody, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DisableWalletActionResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.disableWalletAction(walletActionId, walletActionWalletActionServiceV1RiseWalletActionsWalletActionIdDisablePostDisableWalletActionRequestBody, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WalletActionApi.disableWalletAction']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} transactionId ID of the transaction to get refundable amounts for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRefundableAmounts(transactionId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetRefundableAmountsResponse1>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRefundableAmounts(transactionId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WalletActionApi.getRefundableAmounts']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Query wallet actions that have not been entirely redeemed using [API Query Language](https://platform.rise.ai/docs/#tag/About-API-Query-Language). Results are enriched with the remaining balance of each wallet action. Note: The returned result may contain fewer items than the requested page limit—or even be empty—while still providing a next cursor, because of in memory filtering. Always check the next cursor to determine if there are more items to fetch.
         * @param {WalletActionWalletActionServiceV1RiseWalletActionsQueryPostQueryWalletActionsRequestBody} walletActionWalletActionServiceV1RiseWalletActionsQueryPostQueryWalletActionsRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async queryUnredeemedWalletActions(walletActionWalletActionServiceV1RiseWalletActionsQueryPostQueryWalletActionsRequestBody: WalletActionWalletActionServiceV1RiseWalletActionsQueryPostQueryWalletActionsRequestBody, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<QueryUnredeemedWalletActionsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.queryUnredeemedWalletActions(walletActionWalletActionServiceV1RiseWalletActionsQueryPostQueryWalletActionsRequestBody, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WalletActionApi.queryUnredeemedWalletActions']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Query WalletActions using [API Query Language](https://platform.rise.ai/docs/#tag/About-API-Query-Language).
         * @param {WalletActionWalletActionServiceV1RiseWalletActionsQueryPostQueryWalletActionsRequestBody} walletActionWalletActionServiceV1RiseWalletActionsQueryPostQueryWalletActionsRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async queryWalletActions(walletActionWalletActionServiceV1RiseWalletActionsQueryPostQueryWalletActionsRequestBody: WalletActionWalletActionServiceV1RiseWalletActionsQueryPostQueryWalletActionsRequestBody, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<QueryWalletActionResponse1>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.queryWalletActions(walletActionWalletActionServiceV1RiseWalletActionsQueryPostQueryWalletActionsRequestBody, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WalletActionApi.queryWalletActions']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Query all WalletActions using [API Query Language](https://platform.rise.ai/docs/#tag/About-API-Query-Language). Results are enriched with the remaining balance of each WalletAction.
         * @param {WalletActionWalletActionServiceV1RiseWalletActionsQueryPostQueryWalletActionsRequestBody} walletActionWalletActionServiceV1RiseWalletActionsQueryPostQueryWalletActionsRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async queryWalletActionsBalances(walletActionWalletActionServiceV1RiseWalletActionsQueryPostQueryWalletActionsRequestBody: WalletActionWalletActionServiceV1RiseWalletActionsQueryPostQueryWalletActionsRequestBody, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<QueryWalletActionBalancesResponse1>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.queryWalletActionsBalances(walletActionWalletActionServiceV1RiseWalletActionsQueryPostQueryWalletActionsRequestBody, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WalletActionApi.queryWalletActionsBalances']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update a WalletAction, supports partial update. Pass the latest `revision` for a successful update.
         * @param {string} walletActionId WalletAction ID.
         * @param {WalletActionWalletActionServiceV1RiseWalletActionsWalletActionIdPatchUpdateWalletActionRequestBody} walletActionWalletActionServiceV1RiseWalletActionsWalletActionIdPatchUpdateWalletActionRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateWalletAction(walletActionId: string, walletActionWalletActionServiceV1RiseWalletActionsWalletActionIdPatchUpdateWalletActionRequestBody: WalletActionWalletActionServiceV1RiseWalletActionsWalletActionIdPatchUpdateWalletActionRequestBody, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UpdateWalletActionResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateWalletAction(walletActionId, walletActionWalletActionServiceV1RiseWalletActionsWalletActionIdPatchUpdateWalletActionRequestBody, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WalletActionApi.updateWalletAction']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * WalletActionApi - factory interface
 */
export const WalletActionApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = WalletActionApiFp(configuration)
    return {
        /**
         * Creates a new WalletAction.
         * @param {WalletActionWalletActionServiceV1RiseWalletActionsPostCreateWalletActionRequestBody} walletActionWalletActionServiceV1RiseWalletActionsPostCreateWalletActionRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createWalletAction(walletActionWalletActionServiceV1RiseWalletActionsPostCreateWalletActionRequestBody: WalletActionWalletActionServiceV1RiseWalletActionsPostCreateWalletActionRequestBody, options?: RawAxiosRequestConfig): AxiosPromise<CreateWalletActionResponse> {
            return localVarFp.createWalletAction(walletActionWalletActionServiceV1RiseWalletActionsPostCreateWalletActionRequestBody, options).then((request) => request(axios, basePath));
        },
        /**
         * Creates a new WalletAction by customer reference instead of wallet ID. If the customer already has a wallet, the action will be created on that wallet. If the customer does not have a wallet, a new wallet will be created for them.
         * @param {WalletActionWalletActionServiceV1RiseWalletActionsByCustomerReferencePostCreateWalletActionByCustomerReferenceRequestBody} walletActionWalletActionServiceV1RiseWalletActionsByCustomerReferencePostCreateWalletActionByCustomerReferenceRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createWalletActionByCustomerReference(walletActionWalletActionServiceV1RiseWalletActionsByCustomerReferencePostCreateWalletActionByCustomerReferenceRequestBody: WalletActionWalletActionServiceV1RiseWalletActionsByCustomerReferencePostCreateWalletActionByCustomerReferenceRequestBody, options?: RawAxiosRequestConfig): AxiosPromise<CreateWalletActionByCustomerReferenceResponse1> {
            return localVarFp.createWalletActionByCustomerReference(walletActionWalletActionServiceV1RiseWalletActionsByCustomerReferencePostCreateWalletActionByCustomerReferenceRequestBody, options).then((request) => request(axios, basePath));
        },
        /**
         * Disable a WalletAction immediately and deduct the remaining balance from the wallet.
         * @param {string} walletActionId ID of the WalletAction to delete.
         * @param {WalletActionWalletActionServiceV1RiseWalletActionsWalletActionIdDisablePostDisableWalletActionRequestBody} walletActionWalletActionServiceV1RiseWalletActionsWalletActionIdDisablePostDisableWalletActionRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        disableWalletAction(walletActionId: string, walletActionWalletActionServiceV1RiseWalletActionsWalletActionIdDisablePostDisableWalletActionRequestBody: WalletActionWalletActionServiceV1RiseWalletActionsWalletActionIdDisablePostDisableWalletActionRequestBody, options?: RawAxiosRequestConfig): AxiosPromise<DisableWalletActionResponse> {
            return localVarFp.disableWalletAction(walletActionId, walletActionWalletActionServiceV1RiseWalletActionsWalletActionIdDisablePostDisableWalletActionRequestBody, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} transactionId ID of the transaction to get refundable amounts for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRefundableAmounts(transactionId: string, options?: RawAxiosRequestConfig): AxiosPromise<GetRefundableAmountsResponse1> {
            return localVarFp.getRefundableAmounts(transactionId, options).then((request) => request(axios, basePath));
        },
        /**
         * Query wallet actions that have not been entirely redeemed using [API Query Language](https://platform.rise.ai/docs/#tag/About-API-Query-Language). Results are enriched with the remaining balance of each wallet action. Note: The returned result may contain fewer items than the requested page limit—or even be empty—while still providing a next cursor, because of in memory filtering. Always check the next cursor to determine if there are more items to fetch.
         * @param {WalletActionWalletActionServiceV1RiseWalletActionsQueryPostQueryWalletActionsRequestBody} walletActionWalletActionServiceV1RiseWalletActionsQueryPostQueryWalletActionsRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        queryUnredeemedWalletActions(walletActionWalletActionServiceV1RiseWalletActionsQueryPostQueryWalletActionsRequestBody: WalletActionWalletActionServiceV1RiseWalletActionsQueryPostQueryWalletActionsRequestBody, options?: RawAxiosRequestConfig): AxiosPromise<QueryUnredeemedWalletActionsResponse> {
            return localVarFp.queryUnredeemedWalletActions(walletActionWalletActionServiceV1RiseWalletActionsQueryPostQueryWalletActionsRequestBody, options).then((request) => request(axios, basePath));
        },
        /**
         * Query WalletActions using [API Query Language](https://platform.rise.ai/docs/#tag/About-API-Query-Language).
         * @param {WalletActionWalletActionServiceV1RiseWalletActionsQueryPostQueryWalletActionsRequestBody} walletActionWalletActionServiceV1RiseWalletActionsQueryPostQueryWalletActionsRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        queryWalletActions(walletActionWalletActionServiceV1RiseWalletActionsQueryPostQueryWalletActionsRequestBody: WalletActionWalletActionServiceV1RiseWalletActionsQueryPostQueryWalletActionsRequestBody, options?: RawAxiosRequestConfig): AxiosPromise<QueryWalletActionResponse1> {
            return localVarFp.queryWalletActions(walletActionWalletActionServiceV1RiseWalletActionsQueryPostQueryWalletActionsRequestBody, options).then((request) => request(axios, basePath));
        },
        /**
         * Query all WalletActions using [API Query Language](https://platform.rise.ai/docs/#tag/About-API-Query-Language). Results are enriched with the remaining balance of each WalletAction.
         * @param {WalletActionWalletActionServiceV1RiseWalletActionsQueryPostQueryWalletActionsRequestBody} walletActionWalletActionServiceV1RiseWalletActionsQueryPostQueryWalletActionsRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        queryWalletActionsBalances(walletActionWalletActionServiceV1RiseWalletActionsQueryPostQueryWalletActionsRequestBody: WalletActionWalletActionServiceV1RiseWalletActionsQueryPostQueryWalletActionsRequestBody, options?: RawAxiosRequestConfig): AxiosPromise<QueryWalletActionBalancesResponse1> {
            return localVarFp.queryWalletActionsBalances(walletActionWalletActionServiceV1RiseWalletActionsQueryPostQueryWalletActionsRequestBody, options).then((request) => request(axios, basePath));
        },
        /**
         * Update a WalletAction, supports partial update. Pass the latest `revision` for a successful update.
         * @param {string} walletActionId WalletAction ID.
         * @param {WalletActionWalletActionServiceV1RiseWalletActionsWalletActionIdPatchUpdateWalletActionRequestBody} walletActionWalletActionServiceV1RiseWalletActionsWalletActionIdPatchUpdateWalletActionRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateWalletAction(walletActionId: string, walletActionWalletActionServiceV1RiseWalletActionsWalletActionIdPatchUpdateWalletActionRequestBody: WalletActionWalletActionServiceV1RiseWalletActionsWalletActionIdPatchUpdateWalletActionRequestBody, options?: RawAxiosRequestConfig): AxiosPromise<UpdateWalletActionResponse> {
            return localVarFp.updateWalletAction(walletActionId, walletActionWalletActionServiceV1RiseWalletActionsWalletActionIdPatchUpdateWalletActionRequestBody, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * WalletActionApi - object-oriented interface
 */
export class WalletActionApi extends BaseAPI {
    /**
     * Creates a new WalletAction.
     * @param {WalletActionWalletActionServiceV1RiseWalletActionsPostCreateWalletActionRequestBody} walletActionWalletActionServiceV1RiseWalletActionsPostCreateWalletActionRequestBody 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public createWalletAction(walletActionWalletActionServiceV1RiseWalletActionsPostCreateWalletActionRequestBody: WalletActionWalletActionServiceV1RiseWalletActionsPostCreateWalletActionRequestBody, options?: RawAxiosRequestConfig) {
        return WalletActionApiFp(this.configuration).createWalletAction(walletActionWalletActionServiceV1RiseWalletActionsPostCreateWalletActionRequestBody, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Creates a new WalletAction by customer reference instead of wallet ID. If the customer already has a wallet, the action will be created on that wallet. If the customer does not have a wallet, a new wallet will be created for them.
     * @param {WalletActionWalletActionServiceV1RiseWalletActionsByCustomerReferencePostCreateWalletActionByCustomerReferenceRequestBody} walletActionWalletActionServiceV1RiseWalletActionsByCustomerReferencePostCreateWalletActionByCustomerReferenceRequestBody 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public createWalletActionByCustomerReference(walletActionWalletActionServiceV1RiseWalletActionsByCustomerReferencePostCreateWalletActionByCustomerReferenceRequestBody: WalletActionWalletActionServiceV1RiseWalletActionsByCustomerReferencePostCreateWalletActionByCustomerReferenceRequestBody, options?: RawAxiosRequestConfig) {
        return WalletActionApiFp(this.configuration).createWalletActionByCustomerReference(walletActionWalletActionServiceV1RiseWalletActionsByCustomerReferencePostCreateWalletActionByCustomerReferenceRequestBody, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Disable a WalletAction immediately and deduct the remaining balance from the wallet.
     * @param {string} walletActionId ID of the WalletAction to delete.
     * @param {WalletActionWalletActionServiceV1RiseWalletActionsWalletActionIdDisablePostDisableWalletActionRequestBody} walletActionWalletActionServiceV1RiseWalletActionsWalletActionIdDisablePostDisableWalletActionRequestBody 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public disableWalletAction(walletActionId: string, walletActionWalletActionServiceV1RiseWalletActionsWalletActionIdDisablePostDisableWalletActionRequestBody: WalletActionWalletActionServiceV1RiseWalletActionsWalletActionIdDisablePostDisableWalletActionRequestBody, options?: RawAxiosRequestConfig) {
        return WalletActionApiFp(this.configuration).disableWalletAction(walletActionId, walletActionWalletActionServiceV1RiseWalletActionsWalletActionIdDisablePostDisableWalletActionRequestBody, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} transactionId ID of the transaction to get refundable amounts for
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getRefundableAmounts(transactionId: string, options?: RawAxiosRequestConfig) {
        return WalletActionApiFp(this.configuration).getRefundableAmounts(transactionId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Query wallet actions that have not been entirely redeemed using [API Query Language](https://platform.rise.ai/docs/#tag/About-API-Query-Language). Results are enriched with the remaining balance of each wallet action. Note: The returned result may contain fewer items than the requested page limit—or even be empty—while still providing a next cursor, because of in memory filtering. Always check the next cursor to determine if there are more items to fetch.
     * @param {WalletActionWalletActionServiceV1RiseWalletActionsQueryPostQueryWalletActionsRequestBody} walletActionWalletActionServiceV1RiseWalletActionsQueryPostQueryWalletActionsRequestBody 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public queryUnredeemedWalletActions(walletActionWalletActionServiceV1RiseWalletActionsQueryPostQueryWalletActionsRequestBody: WalletActionWalletActionServiceV1RiseWalletActionsQueryPostQueryWalletActionsRequestBody, options?: RawAxiosRequestConfig) {
        return WalletActionApiFp(this.configuration).queryUnredeemedWalletActions(walletActionWalletActionServiceV1RiseWalletActionsQueryPostQueryWalletActionsRequestBody, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Query WalletActions using [API Query Language](https://platform.rise.ai/docs/#tag/About-API-Query-Language).
     * @param {WalletActionWalletActionServiceV1RiseWalletActionsQueryPostQueryWalletActionsRequestBody} walletActionWalletActionServiceV1RiseWalletActionsQueryPostQueryWalletActionsRequestBody 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public queryWalletActions(walletActionWalletActionServiceV1RiseWalletActionsQueryPostQueryWalletActionsRequestBody: WalletActionWalletActionServiceV1RiseWalletActionsQueryPostQueryWalletActionsRequestBody, options?: RawAxiosRequestConfig) {
        return WalletActionApiFp(this.configuration).queryWalletActions(walletActionWalletActionServiceV1RiseWalletActionsQueryPostQueryWalletActionsRequestBody, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Query all WalletActions using [API Query Language](https://platform.rise.ai/docs/#tag/About-API-Query-Language). Results are enriched with the remaining balance of each WalletAction.
     * @param {WalletActionWalletActionServiceV1RiseWalletActionsQueryPostQueryWalletActionsRequestBody} walletActionWalletActionServiceV1RiseWalletActionsQueryPostQueryWalletActionsRequestBody 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public queryWalletActionsBalances(walletActionWalletActionServiceV1RiseWalletActionsQueryPostQueryWalletActionsRequestBody: WalletActionWalletActionServiceV1RiseWalletActionsQueryPostQueryWalletActionsRequestBody, options?: RawAxiosRequestConfig) {
        return WalletActionApiFp(this.configuration).queryWalletActionsBalances(walletActionWalletActionServiceV1RiseWalletActionsQueryPostQueryWalletActionsRequestBody, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update a WalletAction, supports partial update. Pass the latest `revision` for a successful update.
     * @param {string} walletActionId WalletAction ID.
     * @param {WalletActionWalletActionServiceV1RiseWalletActionsWalletActionIdPatchUpdateWalletActionRequestBody} walletActionWalletActionServiceV1RiseWalletActionsWalletActionIdPatchUpdateWalletActionRequestBody 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public updateWalletAction(walletActionId: string, walletActionWalletActionServiceV1RiseWalletActionsWalletActionIdPatchUpdateWalletActionRequestBody: WalletActionWalletActionServiceV1RiseWalletActionsWalletActionIdPatchUpdateWalletActionRequestBody, options?: RawAxiosRequestConfig) {
        return WalletActionApiFp(this.configuration).updateWalletAction(walletActionId, walletActionWalletActionServiceV1RiseWalletActionsWalletActionIdPatchUpdateWalletActionRequestBody, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * WorkflowsApi - axios parameter creator
 */
export const WorkflowsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Reports an event and activates account workflows with the specified trigger key. Only the app that created a trigger can report events for it. This means other apps can\'t report events for your triggers, and you can\'t report events for another app\'s triggers.
         * @param {WorkflowsEsbConfigResolverWorkflowsV1EventsReportPostReportEventRequestBody} workflowsEsbConfigResolverWorkflowsV1EventsReportPostReportEventRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        reportEvent: async (workflowsEsbConfigResolverWorkflowsV1EventsReportPostReportEventRequestBody: WorkflowsEsbConfigResolverWorkflowsV1EventsReportPostReportEventRequestBody, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'workflowsEsbConfigResolverWorkflowsV1EventsReportPostReportEventRequestBody' is not null or undefined
            assertParamExists('reportEvent', 'workflowsEsbConfigResolverWorkflowsV1EventsReportPostReportEventRequestBody', workflowsEsbConfigResolverWorkflowsV1EventsReportPostReportEventRequestBody)
            const localVarPath = `/workflows/v1/events/report`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(workflowsEsbConfigResolverWorkflowsV1EventsReportPostReportEventRequestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * WorkflowsApi - functional programming interface
 */
export const WorkflowsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = WorkflowsApiAxiosParamCreator(configuration)
    return {
        /**
         * Reports an event and activates account workflows with the specified trigger key. Only the app that created a trigger can report events for it. This means other apps can\'t report events for your triggers, and you can\'t report events for another app\'s triggers.
         * @param {WorkflowsEsbConfigResolverWorkflowsV1EventsReportPostReportEventRequestBody} workflowsEsbConfigResolverWorkflowsV1EventsReportPostReportEventRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async reportEvent(workflowsEsbConfigResolverWorkflowsV1EventsReportPostReportEventRequestBody: WorkflowsEsbConfigResolverWorkflowsV1EventsReportPostReportEventRequestBody, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ReportEventResponse1>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.reportEvent(workflowsEsbConfigResolverWorkflowsV1EventsReportPostReportEventRequestBody, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WorkflowsApi.reportEvent']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * WorkflowsApi - factory interface
 */
export const WorkflowsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = WorkflowsApiFp(configuration)
    return {
        /**
         * Reports an event and activates account workflows with the specified trigger key. Only the app that created a trigger can report events for it. This means other apps can\'t report events for your triggers, and you can\'t report events for another app\'s triggers.
         * @param {WorkflowsEsbConfigResolverWorkflowsV1EventsReportPostReportEventRequestBody} workflowsEsbConfigResolverWorkflowsV1EventsReportPostReportEventRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        reportEvent(workflowsEsbConfigResolverWorkflowsV1EventsReportPostReportEventRequestBody: WorkflowsEsbConfigResolverWorkflowsV1EventsReportPostReportEventRequestBody, options?: RawAxiosRequestConfig): AxiosPromise<ReportEventResponse1> {
            return localVarFp.reportEvent(workflowsEsbConfigResolverWorkflowsV1EventsReportPostReportEventRequestBody, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * WorkflowsApi - object-oriented interface
 */
export class WorkflowsApi extends BaseAPI {
    /**
     * Reports an event and activates account workflows with the specified trigger key. Only the app that created a trigger can report events for it. This means other apps can\'t report events for your triggers, and you can\'t report events for another app\'s triggers.
     * @param {WorkflowsEsbConfigResolverWorkflowsV1EventsReportPostReportEventRequestBody} workflowsEsbConfigResolverWorkflowsV1EventsReportPostReportEventRequestBody 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public reportEvent(workflowsEsbConfigResolverWorkflowsV1EventsReportPostReportEventRequestBody: WorkflowsEsbConfigResolverWorkflowsV1EventsReportPostReportEventRequestBody, options?: RawAxiosRequestConfig) {
        return WorkflowsApiFp(this.configuration).reportEvent(workflowsEsbConfigResolverWorkflowsV1EventsReportPostReportEventRequestBody, options).then((request) => request(this.axios, this.basePath));
    }
}



